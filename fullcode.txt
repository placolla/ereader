docker-compose.yml:
<code>
version: '3.8'

services:
  reader:
    container_name: reader
    build:
      context: .
      dockerfile: ./Dockerfile
    restart: always
    ports:
      - 3000:3000
    env_file:
      - ./apps/reader/.env.local

</code>

package.json:
<code>
{
  "name": "@flow/monorepo",
  "private": true,
  "packageManager": "pnpm@10.6.4+sha512.da3d715bfd22a9a105e6e8088cfc7826699332ded60c423b14ec613a185f1602206702ff0fe4c438cb15c979081ce4cb02568e364b15174503a63c7a8e2a5f6c",
  "scripts": {
    "build": "turbo run build",
    "dev": "turbo run dev --parallel",
    "lint": "turbo run lint",
    "release": "pnpm -r publish --access public",
    "prepare": "husky install"
  },
  "lint-staged": {
    "*.{js,json,css,ts,tsx,md,mdx}": "prettier --write",
    "!(pnpm-lock).{yml,yaml}": "prettier --write",
    "*.{js,ts,tsx}": "eslint --fix"
  },
  "devDependencies": {
    "@changesets/changelog-github": "0.4.4",
    "@changesets/cli": "2.22.0",
    "@typescript-eslint/eslint-plugin": "5.19.0",
    "cross-env": "7.0.3",
    "eslint": "8.13.0",
    "eslint-config-next": "12.1.5",
    "eslint-config-prettier": "8.5.0",
    "eslint-plugin-react": "7.29.4",
    "esno": "0.14.1",
    "husky": "7.0.4",
    "lint-staged": "12.3.7",
    "prettier": "2.6.2",
    "prettier-plugin-tailwindcss": "0.1.8",
    "rimraf": "3.0.2",
    "rollup": "2.72.1",
    "rollup-plugin-dts": "4.2.1",
    "rollup-plugin-typescript2": "0.31.2",
    "tsup": "5.12.7",
    "turbo": "1.11.3",
    "typescript": "4.6.3"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}

</code>

pnpm-workspace.yaml:
<code>
packages:
  - "apps/*"
  - "packages/*"

</code>

postcss.config.js:
<code>
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

</code>

prettier.config.js:
<code>
module.exports = {
  plugins: [require('prettier-plugin-tailwindcss')],
  singleQuote: true,
  semi: false,
  trailingComma: 'all',
}

</code>

README.md:
<code>
<h1 align="center"><a href="https://flowoss.com">Flow - Open Source Software (OSS)</a></h1>

<h2 align="center">Redefine ePub reader</h2>

<p align="center">Free. Open source. Browser-based.</p>

<p align="center"><img src="apps/website/public/screenshots/en-US.webp"/>
</p>

## Features

- Grid layout
- Search in book
- Image preview
- Custom typography
- Highlight and Annotation
- Theme
- Share/Download book with link
- Data export
- Cloud storage

For planed features, see our [roadmap](https://pacexy.notion.site/283696d0071c43bfb03652e8e5f47936?v=b43f4dd7a3cb4ce785d6c32b698a8ff5).

## Development

### Prerequisites

- [Node.js](https://nodejs.org)
- [pnpm](https://pnpm.io/installation)
- [Git](https://git-scm.com/downloads)

### Clone the repo

```bash
git clone https://github.com/pacexy/flow
```

### Install the dependencies

```bash
pnpm i
```

### Setup the environment variables

Copy and rename all `.env.local.example`s to `.env.local` and setup the environment variables.

### Run the apps

```bash
pnpm dev
```

## Self-hosting

Before self-hosting, you should [setup the environment variables](#setup-the-environment-variables).

### Docker

You can use docker-compose:

```sh
docker compose up -d
```

Or build the image and run it manually:

```sh
docker build -t flow .
docker run -p 3000:3000 --env-file apps/reader/.env.local flow
```

## Contributing

There are many ways in which you can participate in this project, for example:

- [Submit bugs and feature requests](https://github.com/pacexy/flow/issues/new), and help us verify as they are checked in
- [Submit pull requests](https://github.com/pacexy/flow/pulls)

## Credits

- [Epub.js](https://github.com/futurepress/epub.js/)
- [React](https://github.com/facebook/react)
- [Next.js](https://nextjs.org/)
- [TypeScript](https://www.typescriptlang.org)
- [Vercel](https://vercel.com)
- [Turborepo](https://turbo.build/repo)

</code>

tailwind.config.js:
<code>
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: 'class',
  content: [
    './apps/**/*.{js,ts,jsx,tsx}',
    './packages/**/*.{js,ts,jsx,tsx}',
    './node_modules/@literal-ui/core/**/*.js',
    './node_modules/@flow/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    extend: {},
    container: {
      center: true,
      padding: '1rem',
    },
  },
  plugins: [
    require('@flow/tailwind'),
    require('@tailwindcss/line-clamp'),
  ],
}

</code>

tsconfig.json:
<code>
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Default",
  "compilerOptions": {
    "composite": false,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "inlineSources": false,
    "isolatedModules": true,
    "moduleResolution": "node",
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "preserveWatchOutput": true,
    "skipLibCheck": true,
    "noUncheckedIndexedAccess": true,
    "strict": true,
    "baseUrl": ".",
    "paths": {
      "@flow/reader/*": ["apps/reader/src/*"],
      "@flow/internal": ["packages/internal/src/index.ts"],
      "@flow/epubjs/*": ["packages/epubjs/*"]
    }
  },
  "exclude": ["node_modules"]
}

</code>

tsconfig.next.json:
<code>
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Next.js",
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "target": "es6",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "incremental": true,
    "esModuleInterop": true,
    "module": "esnext",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve"
  },
  "include": ["src", "next-env.d.ts"],
  "exclude": ["node_modules"]
}

</code>

tsconfig.react.json:
<code>
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "React Library",
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "module": "ESNext",
    "target": "ES6",
    "jsx": "react-jsx"
  }
}

</code>

tsconfig.ts.json:
<code>
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "TypeScript Library",
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "lib": ["esnext"],
    "module": "ESNext",
    "target": "ES6"
  }
}

</code>

turbo.json:
<code>
{
  "$schema": "https://turborepo.org/schema.json",
  "pipeline": {
    "dev": {
      "dependsOn": [],
      "outputs": [],
      "cache": false
    },
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**", ".next/**"]
    },
    "lint": {
      "outputs": []
    }
  }
}

</code>

apps\reader\netlify.toml:
<code>
[build.environment]
NODE_VERSION = "16"
# https://github.com/netlify/build/issues/1633#issuecomment-907246600
NPM_FLAGS = "--version" # prevent Netlify npm install

[build]
# Set `base` to repo directory in Netlify UI
# base = 'reader'
publish = ".next"
# https://answers.netlify.com/t/using-pnpm-and-pnpm-workspaces/2759
command = "npx pnpm i --store=node_modules/.pnpm-store && npx pnpm -F reader... build"

</code>

apps\reader\next-env.d.ts:
<code>
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

</code>

apps\reader\next.config.js:
<code>
const path = require('path')

const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
})
const { withSentryConfig } = require('@sentry/nextjs')
const withPWA = require('next-pwa')({
  dest: 'public',
})
const withTM = require('next-transpile-modules')([
  '@flow/internal',
  '@flow/epubjs',
  '@material/material-color-utilities',
])

const IS_DEV = process.env.NODE_ENV === 'development'
const IS_DOCKER = process.env.DOCKER

/**
 * @type {import('@sentry/nextjs').SentryWebpackPluginOptions}
 **/
const sentryWebpackPluginOptions = {
  // Additional config options for the Sentry Webpack plugin. Keep in mind that
  // the following options are set automatically, and overriding them is not
  // recommended:
  //   release, url, org, project, authToken, configFile, stripPrefix,
  //   urlPrefix, include, ignore

  silent: true, // Suppresses all logs
  // For all available options, see:
  // https://github.com/getsentry/sentry-webpack-plugin#options.
}

/**
 * @type {import('next').NextConfig}
 **/
const config = {
  pageExtensions: ['ts', 'tsx'],
  webpack(config) {
    return config
  },
  i18n: {
    locales: ['en-US', 'zh-CN', 'ja-JP'],
    defaultLocale: 'en-US',
  },
  ...(IS_DOCKER && {
    output: 'standalone',
    experimental: {
      outputFileTracingRoot: path.join(__dirname, '../../'),
    },
  }),
}

const base = withPWA(withTM(withBundleAnalyzer(config)))

const dev = base
const docker = base
const prod = withSentryConfig(
  base,
  // Make sure adding Sentry options is the last code to run before exporting, to
  // ensure that your source maps include changes from all other Webpack plugins
  sentryWebpackPluginOptions,
)

module.exports = IS_DEV ? dev : IS_DOCKER ? docker : prod

</code>

apps\reader\package.json:
<code>
{
  "name": "@flow/reader",
  "private": true,
  "scripts": {
    "dev": "cross-env RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=false next dev -p 7127",
    "build": "next build",
    "analyze": "cross-env ANALYZE=true next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@flow/epubjs": "workspace:*",
    "@flow/internal": "workspace:*",
    "@github/mini-throttle": "2.1.0",
    "@literal-ui/core": "0.0.13",
    "@literal-ui/hooks": "0.0.8",
    "@literal-ui/next": "0.0.3",
    "@material/material-color-utilities": "0.2.0",
    "@next/bundle-analyzer": "12.1.6",
    "@sentry/nextjs": "7.12.1",
    "@types/react-highlight-words": "0.16.4",
    "babel-loader": "8.2.5",
    "clsx": "1.1.1",
    "dayjs": "1.11.2",
    "dexie": "3.2.2",
    "dexie-react-hooks": "1.1.1",
    "dropbox": "10.32.0",
    "epubjs": "0.3.93",
    "file-saver": "2.0.5",
    "jszip": "3.10.1",
    "next": "12.3.4",
    "next-seo": "5.4.0",
    "nookies": "2.5.2",
    "react": "18.0.0",
    "react-cool-virtual": "0.7.0",
    "react-dom": "18.0.0",
    "react-focus-lock": "2.9.1",
    "react-highlight-words": "0.18.0",
    "react-icons": "4.3.1",
    "react-photo-view": "1.1.2",
    "react-polymorphic-types": "2.0.0",
    "react-use": "17.4.0",
    "recoil": "0.7.6",
    "swr": "1.3.0",
    "tilg": "0.1.1",
    "use-local-storage-state": "18.1.1",
    "uuid": "8.3.2",
    "valtio": "1.6.0"
  },
  "devDependencies": {
    "@flow/tailwind": "workspace:*",
    "@tailwindcss/aspect-ratio": "0.4.2",
    "@tailwindcss/line-clamp": "0.4.2",
    "@types/file-saver": "2.0.5",
    "@types/node": "17.0.22",
    "@types/react": "17.0.43",
    "@types/uuid": "8.3.4",
    "autoprefixer": "10.4.4",
    "next-pwa": "5.6.0",
    "next-transpile-modules": "9.0.0",
    "postcss": "8.4.12",
    "tailwindcss": "3.2.0",
    "type-fest": "2.12.2"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}

</code>

apps\reader\sentry.client.config.js:
<code>
// This file configures the initialization of Sentry on the browser.
// The config you add here will be used whenever a page is visited.
// https://docs.sentry.io/platforms/javascript/guides/nextjs/

import * as Sentry from '@sentry/nextjs'

const SENTRY_DSN = process.env.SENTRY_DSN || process.env.NEXT_PUBLIC_SENTRY_DSN

Sentry.init({
  dsn:
    SENTRY_DSN ||
    'https://911830b959464866b3820e27379f4d38@o955619.ingest.sentry.io/6537954',
  // Adjust this value in production, or use tracesSampler for greater control
  tracesSampleRate: 1.0,
  // ...
  // Note: if you want to override the automatic release value, do not set a
  // `release` value here - use the environment variable `SENTRY_RELEASE`, so
  // that it will also get attached to your source maps
})

</code>

apps\reader\sentry.properties:
<code>
defaults.url=https://sentry.io/
defaults.org=pacexy
defaults.project=flow

</code>

apps\reader\sentry.server.config.js:
<code>
// This file configures the initialization of Sentry on the server.
// The config you add here will be used whenever the server handles a request.
// https://docs.sentry.io/platforms/javascript/guides/nextjs/

import * as Sentry from '@sentry/nextjs'

const SENTRY_DSN = process.env.SENTRY_DSN || process.env.NEXT_PUBLIC_SENTRY_DSN

Sentry.init({
  dsn:
    SENTRY_DSN ||
    'https://911830b959464866b3820e27379f4d38@o955619.ingest.sentry.io/6537954',
  // Adjust this value in production, or use tracesSampler for greater control
  tracesSampleRate: 1.0,
  // ...
  // Note: if you want to override the automatic release value, do not set a
  // `release` value here - use the environment variable `SENTRY_RELEASE`, so
  // that it will also get attached to your source maps
})

</code>

apps\reader\tsconfig.json:
<code>
{
  "extends": "../../tsconfig.next.json",
  "compilerOptions": {
    "experimentalDecorators": true
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}

</code>

apps\reader\locales\en-US.ts:
<code>
export default {
  'home.title': 'Home',
  'home.share': 'Share',
  'home.download': 'Download',
  'home.download_sample_book': 'Download sample book',
  'home.select': 'Select',
  'home.cancel': 'Cancel',
  'home.select_all': 'Select all',
  'home.deselect_all': 'Deselect all',
  'home.export': 'Export',
  'home.import': 'Import',
  'home.upload': 'Upload',
  'home.delete': 'Delete',

  'toc.title': 'TOC',
  'toc.library': 'Library',

  'search.title': 'Search',
  'search.files.result': '{n} results in {m} sections',

  'annotation.title': 'Annotation',
  'annotation.definitions': 'Definitions',
  'annotation.annotations': 'Annotations',
  'annotation.copy_as_markdown': 'Copy as Markdown',

  'image.title': 'Image',

  'timeline.title': 'Timeline',

  'typography.title': 'Typography',
  'typography.scope.book': 'Book',
  'typography.scope.global': 'Global',
  'typography.page_view': 'Page View',
  'typography.page_view.single_page': 'Single Page',
  'typography.page_view.double_page': 'Double Page',
  'typography.font_family': 'Font Family',
  'typography.font_size': 'Font Size',
  'typography.font_weight': 'Font Weight',
  'typography.line_height': 'Line Height',
  'typography.zoom': 'Zoom',

  'theme.title': 'Theme',
  'theme.source_color': 'Source Color',
  'theme.background_color': 'Background Color',

  'settings.title': 'Settings',
  'settings.language': 'Language',
  'settings.color_scheme': 'Color Scheme',
  'settings.color_scheme.system': 'System',
  'settings.color_scheme.light': 'Light',
  'settings.color_scheme.dark': 'Dark',
  'settings.synchronization.title': 'Synchronization',
  'settings.synchronization.authorize': 'Authorize',
  'settings.synchronization.unauthorize': 'Unauthorize',
  'settings.cache': 'Cache',
  'settings.cache.clear': 'Clear',

  'menu.copy': 'Copy',
  'menu.search_in_book': 'Search in book',
  'menu.annotate': 'Annotate',
  'menu.define': 'Define',
  'menu.undefine': 'Undefine',
  'menu.create': 'Create',
  'menu.delete': 'Delete',
  'menu.update': 'Update',

  'action.expand_all': 'Expand All',
  'action.collapse_all': 'Collapse All',
  'action.close': 'Close',
  'action.clear': 'Clear',
  'action.step_down': 'Step Down',
  'action.step_up': 'Step Up',

  untitled: 'Untitled',
} as const

</code>

apps\reader\locales\index.ts:
<code>
import en_US from '../locales/en-US'
import ja_JP from '../locales/ja-JP'
import zh_CN from '../locales/zh-CN'

// eslint-disable-next-line import/no-anonymous-default-export
export default {
  'en-US': en_US,
  'zh-CN': zh_CN,
  'ja-JP': ja_JP,
} as const

</code>

apps\reader\locales\ja-JP.ts:
<code>
export default {
  'home.title': 'ホーム',
  'home.share': '共有',
  'home.download': 'ダウンロード',
  'home.download_sample_book': 'サンプルブックをダウンロード',
  'home.select': '選択',
  'home.cancel': 'キャンセル',
  'home.select_all': 'すべて選択',
  'home.deselect_all': 'すべて選択解除',
  'home.export': 'エクスポート',
  'home.import': 'インポート',
  'home.upload': 'アップロード',
  'home.delete': '削除',

  'toc.title': '目次',
  'toc.library': 'ライブラリ',

  'search.title': '検索',
  'search.files.result': '{m}件中 {n}件該当',

  'annotation.title': '注釈',
  'annotation.definitions': '定義',
  'annotation.annotations': '注釈',
  'annotation.copy_as_markdown': 'Markdownとしてコピー',

  'image.title': '画像',

  'timeline.title': 'タイムライン',

  'typography.title': 'タイポグラフィ',
  'typography.scope.book': '本',
  'typography.scope.global': 'グローバル',
  'typography.page_view': 'ページ表示',
  'typography.page_view.single_page': '片ページ',
  'typography.page_view.double_page': '見開きページ',
  'typography.font_family': 'フォントファミリー',
  'typography.font_size': 'フォントサイズ',
  'typography.font_weight': 'フォントウェイト',
  'typography.line_height': '行の高さ',
  'typography.zoom': 'ズーム',

  'theme.title': 'テーマ',
  'theme.source_color': 'ソースカラー',
  'theme.background_color': '背景色',

  'settings.title': '設定',
  'settings.language': '言語',
  'settings.color_scheme': '配色',
  'settings.color_scheme.system': 'システム',
  'settings.color_scheme.light': 'ライト',
  'settings.color_scheme.dark': 'ダーク',
  'settings.synchronization.title': '同期',
  'settings.synchronization.authorize': '認証',
  'settings.synchronization.unauthorize': '認証解除',
  'settings.cache': 'キャッシュ',
  'settings.cache.clear': 'クリア',

  'menu.copy': 'コピー',
  'menu.search_in_book': '本を検索',
  'menu.annotate': '注釈',
  'menu.define': '定義',
  'menu.undefine': '未定義',
  'menu.create': '作成',
  'menu.delete': '削除',
  'menu.update': '更新',

  'action.expand_all': 'すべて展開',
  'action.collapse_all': 'すべて折りたたむ',
  'action.close': '閉じる',
  'action.clear': 'クリア',
  'action.step_down': 'ステップダウン',
  'action.step_up': 'ステップアップ',

  untitled: '無題',
} as const

</code>

apps\reader\locales\zh-CN.ts:
<code>
export default {
  'home.title': '主页',
  'home.share': '分享',
  'home.download': '下载',
  'home.download_sample_book': '下载样书',
  'home.select': '选择',
  'home.cancel': '取消',
  'home.select_all': '选择所有',
  'home.deselect_all': '取消选择所有',
  'home.export': '导出',
  'home.import': '导入',
  'home.upload': '上传',
  'home.delete': '删除',

  'toc.title': '目录',
  'toc.library': '图书馆',

  'search.title': '搜索',
  'search.files.result': '{n} 个结果在 {m} 个文件中',

  'annotation.title': '标注',
  'annotation.definitions': '定义',
  'annotation.annotations': '标注',
  'annotation.copy_as_markdown': '复制为 Markdown',

  'image.title': '图片',

  'timeline.title': '时间线',

  'typography.title': '排版',
  'typography.scope.book': '书籍',
  'typography.scope.global': '全局',
  'typography.page_view': '视图',
  'typography.page_view.single_page': '单页',
  'typography.page_view.double_page': '双页',
  'typography.font_family': '字体',
  'typography.font_size': '字号',
  'typography.font_weight': '字重',
  'typography.line_height': '行高',
  'typography.zoom': '缩放',

  'theme.title': '颜色主题',
  'theme.source_color': '源色',
  'theme.background_color': '背景色',

  'settings.title': '设置',
  'settings.language': '语言',
  'settings.color_scheme': '颜色模式',
  'settings.color_scheme.system': '系统',
  'settings.color_scheme.light': '浅色',
  'settings.color_scheme.dark': '深色',
  'settings.synchronization.title': '同步',
  'settings.synchronization.authorize': '授权',
  'settings.synchronization.unauthorize': '取消授权',
  'settings.cache': '缓存',
  'settings.cache.clear': '清除',

  'menu.copy': '复制',
  'menu.search_in_book': '书内搜索',
  'menu.annotate': '标注',
  'menu.define': '定义',
  'menu.undefine': '取消定义',
  'menu.create': '创建',
  'menu.delete': '删除',
  'menu.update': '更新',

  'action.expand_all': '展开全部',
  'action.collapse_all': '折叠全部',
  'action.close': '关闭',
  'action.clear': '清除',
  'action.step_down': '减少',
  'action.step_up': '增加',

  untitled: '未标题',
} as const

</code>

apps\reader\pages\index-old.tsx:
<code>
import { useEffect, useState } from 'react'
// @ts-ignore
import ePub from 'epubjs'

type Book = {
  title: string
  file: string
}

export default function Reader() {
  const [books, setBooks] = useState<Book[]>([])

  useEffect(() => {
    fetch('/api/books')
      .then((res) => res.json())
      .then((data: Book[]) => setBooks(data))
  }, [])

  useEffect(() => {
    books.forEach((book, index) => {
      const viewerId = `viewer-${index}`
      const container = document.getElementById(viewerId)
      if (!container) return

      container.innerHTML = '' // clear previous renders

      const bookInstance = ePub(book.file)
      const rendition = bookInstance.renderTo(container, {
        width: '100%',
        height: 600,
        spread: 'always',
      })

      rendition.display()
    })
  }, [books])

  return (
    <div style={{ padding: '2rem' }}>
      <h1 style={{ fontSize: '2rem' }}>📚 Available Books</h1>
      {books.map((book, index) => (
        <div key={book.file} style={{ marginBottom: '3rem' }}>
          <h2>{book.title}</h2>
          <div
            id={`viewer-${index}`}
            style={{
              border: '1px solid #ccc',
              height: '600px',
              width: '100%',
              overflow: 'hidden',
            }}
          />
        </div>
      ))}
    </div>
  )
}

</code>

apps\reader\pages\index.tsx:
<code>
import { RecoilRoot } from 'recoil'
import { Layout } from '../src/components/Layout'
import { ReaderGridView } from '../src/components/Reader'

export default function HomePage() {
  return (
    <RecoilRoot>
      <Layout>
        <ReaderGridView />
      </Layout>
    </RecoilRoot>
  )
}

</code>

apps\reader\pages\api\books.ts:
<code>
import fs from 'fs'
import path from 'path'
import type { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const booksDir = path.join(process.cwd(), 'public', 'books')


  if (!fs.existsSync(booksDir)) {
    return res.status(404).json({ error: 'Books folder not found.' })
  }

  const files = fs.readdirSync(booksDir).filter((f) => f.endsWith('.epub'))
  const bookList = files.map((f) => ({
    title: f.replace(/\.epub$/, ''),
    file: `/books/${f}`,
  }))

  res.status(200).json(bookList)
}

</code>

apps\reader\src\annotation.ts:
<code>
export type AnnotationType = keyof typeof typeMap

export const typeMap = {
  highlight: {
    style: 'backgroundColor',
    class: 'rounded',
  },
  // underline: {
  //   style: 'border-bottom-color',
  //   class: 'border-b-2',
  // },
}

export type AnnotationColor = keyof typeof colorMap

// "dark color + low opacity" is clearer than "light color + high opacity"
// from tailwind [color]-600
export const colorMap = {
  yellow: 'rgba(217, 119, 6, 0.2)',
  red: 'rgba(220, 38, 38, 0.2)',
  green: 'rgba(22, 163, 74, 0.2)',
  blue: 'rgba(37, 99, 235, 0.2)',
}

export interface Annotation {
  id: string
  bookId: string
  cfi: string
  spine: {
    index: number
    title: string
  }
  createAt: number
  updatedAt: number
  type: AnnotationType
  color: AnnotationColor
  notes?: string
  text: string
}

</code>

apps\reader\src\color.ts:
<code>
import {
  redFromArgb,
  greenFromArgb,
  blueFromArgb,
  argbFromRgb,
  hexFromArgb,
} from '@material/material-color-utilities'

export function rgbFromArgb(argb: number) {
  return [redFromArgb, greenFromArgb, blueFromArgb].map((f) => f(argb))
}

function compositeChannels(channel1: number, channel2: number, p: number) {
  return (1 - p) * channel1 + p * channel2
}

// https://en.wikipedia.org/wiki/Transparency_%28graphic%29#Compositing_calculations
export function compositeColors(color1: number, color2: number, p: number) {
  const [r1, g1, b1] = rgbFromArgb(color1)
  const [r2, g2, b2] = rgbFromArgb(color2)
  return hexFromArgb(
    argbFromRgb(
      compositeChannels(r1!, r2!, p),
      compositeChannels(g1!, g2!, p),
      compositeChannels(b1!, b2!, p),
    ),
  )
}

</code>

apps\reader\src\db.ts:
<code>
import { IS_SERVER } from '@literal-ui/hooks'
import Dexie, { Table } from 'dexie'

import { PackagingMetadataObject } from '@flow/epubjs/types/packaging'

import { Annotation } from './annotation'
import { fileToEpub } from './file'
import { TypographyConfiguration } from './state'

export interface FileRecord {
  id: string
  file: File
}

export interface CoverRecord {
  id: string
  cover: string | null
}

export interface BookRecord {
  // TODO: use file hash as id
  id: string
  name: string
  size: number
  metadata: PackagingMetadataObject
  createdAt: number
  updatedAt?: number
  cfi?: string
  percentage?: number
  definitions: string[]
  annotations: Annotation[]
  configuration?: {
    typography?: TypographyConfiguration
  }
}

export class DB extends Dexie {
  // 'books' is added by dexie when declaring the stores()
  // We just tell the typing system this is the case
  files!: Table<FileRecord>
  covers!: Table<CoverRecord>
  books!: Table<BookRecord>

  constructor(name: string) {
    super(name)

    this.version(5).stores({
      books:
        'id, name, size, metadata, createdAt, updatedAt, cfi, percentage, definitions, annotations, configuration',
    })

    this.version(4)
      .stores({
        books:
          'id, name, size, metadata, createdAt, updatedAt, cfi, percentage, definitions, annotations',
      })
      .upgrade(async (t) => {
        t.table('books')
          .toCollection()
          .modify((r) => {
            r.annotations = []
          })
      })

    this.version(3)
      .stores({
        books:
          'id, name, size, metadata, createdAt, updatedAt, cfi, percentage, definitions',
      })
      .upgrade(async (t) => {
        const files = await t.table('files').toArray()

        const metadatas = await Dexie.waitFor(
          Promise.all(
            files.map(async ({ file }) => {
              const epub = await fileToEpub(file)
              return epub.loaded.metadata
            }),
          ),
        )

        return t
          .table('books')
          .toCollection()
          .modify(async (r) => {
            const i = files.findIndex((f) => f.id === r.id)
            r.metadata = metadatas[i]
            r.size = files[i].file.size
          })
          .catch((e) => {
            console.error(e)
            throw e
          })
      })
    this.version(2)
      .stores({
        books: 'id, name, createdAt, cfi, percentage, definitions',
      })
      .upgrade(async (t) => {
        const books = await t.table('books').toArray()
        ;['covers', 'files'].forEach((tableName) => {
          t.table(tableName)
            .toCollection()
            .modify((r) => {
              const book = books.find((b) => b.name === r.id)
              if (book) r.id = book.id
            })
        })
      })
    this.version(1).stores({
      books: 'id, name, createdAt, cfi, percentage, definitions', // Primary key and indexed props
      covers: 'id, cover',
      files: 'id, file',
    })
  }
}

export const db = IS_SERVER ? null : new DB('re-reader')

</code>

apps\reader\src\dropbox.d.ts:
<code>
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import { Dropbox, DropboxAuth } from 'dropbox'

// https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation
export declare module 'dropbox' {
  interface Dropbox {
    auth: DropboxAuth
  }
}

</code>

apps\reader\src\file.ts:
<code>
import { v4 as uuidv4 } from 'uuid'

import ePub, { Book } from '@flow/epubjs'

import { BookRecord, db } from './db'
import { mapExtToMimes } from './mime'
import { unpack } from './sync'

export async function fileToEpub(file: File) {
  const data = await file.arrayBuffer()
  return ePub(data)
}

export async function handleFiles(files: Iterable<File>) {
  const books = await db?.books.toArray()
  const newBooks = []

  for (const file of files) {
    console.log(file)

    if (mapExtToMimes['.zip'].includes(file.type)) {
      unpack(file)
      continue
    }

    if (!mapExtToMimes['.epub'].includes(file.type)) {
      console.error(`Unsupported file type: ${file.type}`)
      continue
    }

    let book = books?.find((b) => b.name === file.name)

    if (!book) {
      book = await addBook(file)
    }

    newBooks.push(book)
  }

  return newBooks
}

export async function addBook(file: File) {
  const epub = await fileToEpub(file)
  const metadata = await epub.loaded.metadata

  const book: BookRecord = {
    id: uuidv4(),
    name: file.name || `${metadata.title}.epub`,
    size: file.size,
    metadata,
    createdAt: Date.now(),
    definitions: [],
    annotations: [],
  }
  db?.books.add(book)
  addFile(book.id, file, epub)
  return book
}

export async function addFile(id: string, file: File, epub?: Book) {
  db?.files.add({ id, file })

  if (!epub) {
    epub = await fileToEpub(file)
  }

  const url = await epub.coverUrl()
  const cover = url && (await toDataUrl(url))
  db?.covers.add({ id, cover })
}

export function readBlob(fn: (reader: FileReader) => void) {
  return new Promise<string>((resolve) => {
    const reader = new FileReader()
    reader.addEventListener('load', () => {
      resolve(reader.result as string)
    })
    fn(reader)
  })
}

async function toDataUrl(url: string) {
  const res = await fetch(url)
  const buffer = await res.blob()
  return readBlob((r) => r.readAsDataURL(buffer))
}

export async function fetchBook(url: string) {
  const filename = decodeURIComponent(/\/([^/]*\.epub)$/i.exec(url)?.[1] ?? '')
  const books = await db?.books.toArray()
  const book = books?.find((b) => b.name === filename)

  return (
    book ??
    fetch(url)
      .then((res) => res.blob())
      .then((blob) => addBook(new File([blob], filename)))
  )
}

</code>

apps\reader\src\mime.ts:
<code>
export const mapExtToMimes = {
  '.epub': ['application/epub+zip', 'application/epub'],
  '.zip': [
    'application/zip',
    'application/zip-compressed',
    'application/x-zip-compressed',
  ],
}

</code>

apps\reader\src\platform.ts:
<code>
import { IS_SERVER } from '@literal-ui/hooks'

// https://www.geeksforgeeks.org/how-to-detect-touch-screen-device-using-javascript
export const isTouchScreen = IS_SERVER ? false : 'ontouchstart' in window
export const scale = (value: number, valueInTouchScreen: number) =>
  isTouchScreen ? valueInTouchScreen : value

</code>

apps\reader\src\state.ts:
<code>
import { IS_SERVER } from '@literal-ui/hooks'
import { atom, AtomEffect, useRecoilState } from 'recoil'

import { RenditionSpread } from '@flow/epubjs/types/rendition'

function localStorageEffect<T>(key: string, defaultValue: T): AtomEffect<T> {
  return ({ setSelf, onSet }) => {
    if (IS_SERVER) return

    const savedValue = localStorage.getItem(key)
    if (savedValue === null) {
      localStorage.setItem(key, JSON.stringify(defaultValue))
    } else {
      setSelf(JSON.parse(savedValue))
    }

    onSet((newValue, _, isReset) => {
      isReset
        ? localStorage.removeItem(key)
        : localStorage.setItem(key, JSON.stringify(newValue))
    })
  }
}

export const navbarState = atom<boolean>({
  key: 'navbar',
  default: false,
})

export interface Settings extends TypographyConfiguration {
  theme?: ThemeConfiguration
}

export interface TypographyConfiguration {
  fontSize?: string
  fontWeight?: number
  fontFamily?: string
  lineHeight?: number
  spread?: RenditionSpread
  zoom?: number
}

interface ThemeConfiguration {
  source?: string
  background?: number
}

export const defaultSettings: Settings = {}

const settingsState = atom<Settings>({
  key: 'settings',
  default: defaultSettings,
  effects: [localStorageEffect('settings', defaultSettings)],
})

export function useSettings() {
  return useRecoilState(settingsState)
}

</code>

apps\reader\src\styles.css:
<code>
@tailwind base;
@tailwind components;
@tailwind utilities;

html,
body,
#__next,
#layout {
  height: 100%;
}

.checkbox,
.textfield,
select {
  @apply ring-surface-variant ring-1 ring-inset;
}

.textfield:focus-within,
select:focus-visible,
button:focus-visible,
a:focus-visible {
  outline: none;
  @apply ring-primary70 ring-1 ring-inset;
}

input:focus-visible,
textarea:focus-visible {
  outline: none;
}

/* https://stackoverflow.com/a/22306944/13151903 */
input[type='number']::-webkit-inner-spin-button,
input[type='number']::-webkit-outer-spin-button {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  margin: 0;
}

input[type='color']::-webkit-color-swatch-wrapper {
  padding: 0;
}
input[type='color']::-webkit-color-swatch {
  @apply border-outline-variant;
}

.scroll {
  overflow: overlay;
}
.scroll::-webkit-scrollbar {
  width: 10px;
}
.scroll:hover::-webkit-scrollbar-thumb {
  @apply bg-on-background/10 hover:bg-on-background/20 active:bg-on-background/30;
}
.scroll-parent {
  @apply flex flex-col overflow-hidden;
}

.scroll-h {
  @apply overflow-x-auto;
}
.scroll-h::-webkit-scrollbar {
  display: none; /* Safari and Chrome */
}

.match-highlight {
  @apply bg-yellow-500/30;
  color: unset;
}

p {
  @apply py-2;
}

/* https://daisyui.com/components/divider */
.divider {
  display: flex;
  flex-direction: row;
  align-items: center;
  align-self: stretch;
  height: 1rem;
  white-space: nowrap;
  @apply my-2 gap-2;
}
.divider:before,
.divider:after {
  content: '';
  flex-grow: 1;
  width: 100%;
  @apply bg-surface-variant h-px;
}

.progress-bit {
  animation-name: progress;
  animation-duration: 4s;
  animation-iteration-count: infinite;
  transform: translate3d(0px, 0px, 0px);
  animation-timing-function: linear;
}

@keyframes progress {
  from {
    transform: translateX(0%) scaleX(1);
  }
  50% {
    transform: translateX(1000%) scaleX(3);
  }
  to {
    transform: translateX(2000%) scaleX(1);
  }
}

.list-row:hover .action {
  display: block;
}

</code>

apps\reader\src\styles.ts:
<code>
import { CSSProperties } from 'react'

import { Contents } from '@flow/epubjs'

import { Settings } from './state'
import { keys } from './utils'

export const activeClass = 'bg-primary70'
export const defaultStyle = {
  html: {
    padding: '0 !important',
  },
  body: {
    background: 'transparent',
  },
  'a:any-link': {
    color: '#3b82f6 !important',
    'text-decoration': 'none !important',
  },
  '::selection': {
    'background-color': 'rgba(3, 102, 214, 0.2)',
  },
}

const camelToSnake = (str: string) =>
  str.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`)

function mapToCss(o: CSSProperties) {
  return keys(o)
    .filter((k) => o[k] !== undefined)
    .map((k) => `${camelToSnake(k)}: ${o[k]} !important;`)
    .join('\n')
}

enum Style {
  Custom = 'custom',
}

export function updateCustomStyle(
  contents: Contents | undefined,
  settings: Settings | undefined,
) {
  if (!contents || !settings) return

  const { zoom, ...other } = settings
  let css = `a, article, cite, div, li, p, pre, span, table, body {
    ${mapToCss(other)}
  }`

  if (zoom) {
    const body = contents.content as HTMLBodyElement
    const scale = (p: keyof CSSStyleDeclaration) => ({
      [p]: `${parseInt(body.style[p] as string) / zoom}px`,
    })
    css += `body {
      ${mapToCss({
        transformOrigin: 'top left',
        transform: `scale(${zoom})`,
        ...scale('width'),
        ...scale('height'),
        ...scale('columnWidth'),
        ...scale('columnGap'),
        ...scale('paddingTop'),
        ...scale('paddingBottom'),
        ...scale('paddingLeft'),
        ...scale('paddingRight'),
      })}
    }`
  }

  return contents.addStylesheetCss(css, Style.Custom)
}

export function lock(l: number, r: number, unit = 'px') {
  const minw = 400
  const maxw = 2560

  return `calc(${l}${unit} + ${r - l} * (100vw - ${minw}px) / ${maxw - minw})`
}

</code>

apps\reader\src\sync.ts:
<code>
import { Dropbox } from 'dropbox'
import { saveAs } from 'file-saver'
import JSZip from 'jszip'
import { parseCookies } from 'nookies'

import { BookRecord, db } from './db'
import { readBlob } from './file'

export const mapToToken = {
  dropbox: 'dropbox-refresh-token',
}

export const OAUTH_SUCCESS_MESSAGE = 'oauth_success'

export const dbx = new Dropbox({
  clientId: process.env.NEXT_PUBLIC_DROPBOX_CLIENT_ID,
  refreshToken: '__fake_token__',
})
let _req: Promise<void> | undefined
dbx.auth.refreshAccessToken = () => {
  const cookies = parseCookies()
  const refreshToken = cookies[mapToToken['dropbox']]
  if (!refreshToken) {
    // `reject` to skip subsequent api requests
    return Promise.reject()
  }
  _req ??= fetch(`/api/refresh`)
    .then((res) => res.json())
    .then((data) => {
      dbx.auth.setAccessToken(data.accessToken)
      dbx.auth.setAccessTokenExpiresAt(data.accessTokenExpiresAt)
    })
    .finally(() => {
      // will fail if no refresh token
      _req = undefined
    })
  return _req
}

interface SerializedBooks {
  version: number
  dbVersion: number
  books: BookRecord[]
}

const VERSION = 1
export const DATA_FILENAME = 'data.json'

function serializeData(books?: BookRecord[]) {
  return JSON.stringify({
    version: VERSION,
    dbVersion: db?.verno,
    books,
  })
}

function deserializeData(text: string) {
  const { version, dbVersion, books } = JSON.parse(text) as SerializedBooks

  if (version < VERSION) {
    // migrate `data.json`
  }
  if (db && dbVersion < db.verno) {
    // migrate `BookRecord`
  }

  return books
}

export async function uploadData(books: BookRecord[]) {
  return dbx.filesUpload({
    path: `/${DATA_FILENAME}`,
    mode: { '.tag': 'overwrite' },
    contents: serializeData(books),
  })
}

export const dropboxFilesFetcher = (path: string) => {
  return dbx.filesListFolder({ path }).then((d) => d.result.entries)
}

export const dropboxBooksFetcher = (path: string) => {
  return dbx
    .filesDownload({ path })
    .then((d) => {
      const blob: Blob = (d.result as any).fileBlob
      return readBlob((r) => r.readAsText(blob))
    })
    .then((d) => deserializeData(d))
}

export async function pack() {
  const books = await db?.books.toArray()
  const covers = await db?.covers.toArray()
  const files = await db?.files.toArray()

  const zip = new JSZip()
  zip.file(DATA_FILENAME, serializeData(books))
  zip.file('covers.json', JSON.stringify(covers))

  const folder = zip.folder('files')
  files?.forEach((f) => folder?.file(f.file.name, f.file))

  const date = new Intl.DateTimeFormat('fr-CA').format().replaceAll('-', '')

  return zip.generateAsync({ type: 'blob' }).then((content) => {
    saveAs(content, `flow_backup_${date}.zip`)
  })
}

export async function unpack(file: File) {
  const zip = new JSZip()
  await zip.loadAsync(file)

  const booksJSON = zip.file(DATA_FILENAME)
  const coversJSON = zip.file('covers.json')
  if (!booksJSON || !coversJSON) return

  const books = deserializeData(await booksJSON.async('text'))

  db?.books.bulkPut(books)

  const coversText = await coversJSON.async('text')
  db?.covers.bulkPut(JSON.parse(coversText))

  const folder = zip.folder('files')
  folder?.forEach(async (_, f) => {
    const book = books.find((b) => `files/${b.name}` === f.name)
    if (!book) return

    const data = await f.async('blob')
    const file = new File([data], book.name)
    db?.files.put({ file, id: book.id })
  })
}

</code>

apps\reader\src\utils.ts:
<code>
export function keys<T extends object>(o: T) {
  return Object.keys(o) as (keyof T)[]
}

export function clamp(value: number, min: number, max: number) {
  return Math.min(Math.max(value, min), max)
}

export function last<T>(array: T[]) {
  return array[array.length - 1]
}

export function group<T>(array: T[], getKey: (item: T) => string | number) {
  const o: Record<string, T[]> = {}

  array.forEach((item) => {
    const key = getKey(item)
    o[key] = [...(o[key] ?? []), item]
  })

  return o
}

export function copy(text: string) {
  return navigator.clipboard.writeText(text)
}

</code>

apps\reader\src\web.d.ts:
<code>
// https://github.com/christianliebel/paint/blob/850a57cd3cc6f6532791abb6d20d9228ceffb74f/types/static.d.ts#L66
// Type declarations for File Handling API

interface LaunchParams {
  files: FileSystemFileHandle[]
}

interface LaunchQueue {
  setConsumer(consumer: (launchParams: LaunchParams) => any): void
}

interface LocalFont {
  family: string
  fullName: string
  postscriptName: string
  style: string
}

interface Window {
  launchQueue: LaunchQueue
  queryLocalFonts: () => Promise<LocalFont[]>
}

</code>

apps\reader\src\components\Annotation.tsx:
<code>
import { useEffect } from 'react'
import { useSnapshot } from 'valtio'

import { colorMap, Annotation as IAnnotation } from '../annotation'
import { useSetAction } from '../hooks'
import { BookTab, compareHref } from '../models'

// avoid click penetration
let clickedAnnotation = false

export const getClickedAnnotation = () => clickedAnnotation
export const setClickedAnnotation = (v: boolean) => (clickedAnnotation = v)

interface FindMatchProps {
  tab: BookTab
}
const FindMatches: React.FC<FindMatchProps> = ({ tab }) => {
  const setAction = useSetAction()
  const { rendition, results, currentHref } = useSnapshot(tab)

  useEffect(() => {
    const result = results?.find((r) => compareHref(currentHref, r.id))

    const matches = result?.subitems
    matches?.forEach((m) => {
      try {
        const h = rendition?.annotations.highlight(
          m.cfi!,
          undefined,
          undefined,
          undefined,
          {
            // tailwind yellow-500
            fill: 'rgba(234, 179, 8, 0.3)',
            'fill-opacity': 'unset',
          },
        )

        const g = h?.mark.element as SVGGElement
        g?.addEventListener('click', () => {
          setClickedAnnotation(true)
        })
      } catch (error) {
        // ignore matched text in `<title>`
      }
    })

    return () => {
      matches?.forEach((m) => {
        rendition?.annotations.remove(m.cfi!, 'highlight')
      })
    }
  }, [currentHref, rendition?.annotations, results, setAction])

  return null
}

interface DefinitionProps {
  tab: BookTab
  definition: string
}
const Definition: React.FC<DefinitionProps> = ({ tab, definition }) => {
  const setAction = useSetAction()
  const { rendition, currentHref } = useSnapshot(tab)

  useEffect(() => {
    const result = tab.searchInSection(definition)
    const matches = result?.subitems

    matches?.forEach((m) => {
      try {
        const h = rendition?.annotations.highlight(
          m.cfi!,
          undefined,
          undefined,
          undefined,
          {
            // tailwind gray-600
            fill: 'rgba(75, 85, 99, 0.15)',
            'fill-opacity': 'unset',
          },
        )

        const g = h?.mark.element as SVGGElement

        // `<rect>` should be reserved to response `click`
        g?.addEventListener('click', () => {
          tab.setAnnotationRange(m.cfi!)
          setClickedAnnotation(true)
        })
      } catch (error) {
        // ignore matched text in `<title>`
      }
    })

    return () => {
      matches?.forEach((m) =>
        rendition?.annotations.remove(m.cfi!, 'highlight'),
      )
    }
  }, [currentHref, definition, rendition?.annotations, setAction, tab])

  return null
}

interface AnnotationProps {
  tab: BookTab
  annotation: IAnnotation
}
const Annotation: React.FC<AnnotationProps> = ({ tab, annotation }) => {
  const { rendition } = useSnapshot(tab)

  useEffect(() => {
    const h = rendition?.annotations[annotation.type](
      annotation.cfi,
      undefined,
      undefined,
      undefined,
      {
        fill: colorMap[annotation.color],
        'fill-opacity': '0.5',
      },
    )

    const g = h?.mark?.element as SVGGElement

    // `<rect>` should be reserved to response `click`
    g?.addEventListener('click', () => {
      tab.setAnnotationRange(annotation.cfi)
      setClickedAnnotation(true)
    })

    return () => {
      rendition?.annotations.remove(annotation.cfi, annotation.type)
    }
  }, [
    annotation.cfi,
    annotation.color,
    annotation.type,
    rendition?.annotations,
    tab,
  ])

  return null
}

interface AnnotationsProps {
  tab: BookTab
}
export const Annotations: React.FC<AnnotationsProps> = ({ tab }) => {
  const { book, section } = useSnapshot(tab)

  return (
    <>
      <FindMatches tab={tab} />
      {/* with `key`, react will mount/unmount it automatically */}
      {book.annotations
        // seems to fix annotation flash when executing `next()` and `display()`
        .filter((a) => a.spine.index === section?.index)
        .map((annotation) => (
          <Annotation key={annotation.id} tab={tab} annotation={annotation} />
        ))}
      {book.definitions.map((definition) => (
        <Definition key={definition} tab={tab} definition={definition} />
      ))}
    </>
  )
}

</code>

apps\reader\src\components\Button.tsx:
<code>
import { StateLayer } from '@literal-ui/core'
import clsx from 'clsx'
import { ComponentProps } from 'react'
import { IconType } from 'react-icons'

interface IconButtonProps extends ComponentProps<'button'> {
  Icon: IconType
  size?: number
}
export function IconButton({
  className,
  Icon,
  size = 16,
  ...props
}: IconButtonProps) {
  return (
    <button className={clsx('relative block p-0.5', className)} {...props}>
      <StateLayer />
      <Icon size={size} />
    </button>
  )
}

const variantMap = {
  primary: 'bg-primary-container text-on-primary-container',
  secondary: 'bg-outline/10 text-on-surface-variant',
}

export interface ButtonProps extends ComponentProps<'button'> {
  variant?: keyof typeof variantMap
  compact?: boolean
}
export const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  compact = false,
  className,
  ...props
}) => {
  return (
    <button
      className={clsx(
        'typescale-label-large disabled:bg-disabled disabled:text-on-disabled',
        variantMap[variant],
        compact ? 'px-2 py-1' : 'px-3 py-1.5',
        className,
      )}
      {...props}
    />
  )
}

</code>

apps\reader\src\components\ErrorBoundary.tsx:
<code>
import React, { Component, ErrorInfo, ReactNode } from 'react'

interface Props {
  children?: ReactNode
}

interface State {
  hasError: boolean
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
  }

  public static getDerivedStateFromError(_: Error): State {
    // Update state so the next render will show the fallback UI.
    return { hasError: true }
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo)
  }

  public render() {
    if (this.state.hasError) {
      return <h1>Sorry.. there was an error</h1>
    }

    return this.props.children
  }
}

</code>

apps\reader\src\components\Form.tsx:
<code>
import clsx from 'clsx'
import {
  ElementType,
  useRef,
  useEffect,
  RefObject,
  ComponentProps,
} from 'react'
import { IconType } from 'react-icons'
import { MdCheck, MdClose } from 'react-icons/md'
import { PolymorphicPropsWithoutRef } from 'react-polymorphic-types'

import { useMobile, useTranslation } from '../hooks'

import { IconButton } from './Button'

type Action = {
  title: string
  Icon: IconType
  onClick: (el: HTMLInputElement | null) => void
}

export type TextFieldProps<T extends ElementType> = PolymorphicPropsWithoutRef<
  {
    name: string
    hideLabel?: boolean
    autoFocus?: boolean
    actions?: Action[]
    datalist?: React.ReactNode[]
    onClear?: () => void
    // https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/#generic-forwardrefs
    mRef?: RefObject<HTMLInputElement> | null
  },
  T
>
export function TextField<T extends ElementType = 'input'>({
  name,
  as,
  className,
  hideLabel = false,
  autoFocus,
  actions = [],
  datalist,
  onClear,
  mRef: outerRef,
  ...props
}: TextFieldProps<T>) {
  const Component = as || 'input'
  const isInput = Component === 'input'
  const innerRef = useRef<HTMLInputElement>(null)
  const datalistId = `${name}-datalist` // TODO: use `useId`
  const ref = outerRef || innerRef
  const mobile = useMobile()
  const t = useTranslation()

  if (onClear) {
    actions = [
      ...actions,
      {
        title: t('action.clear'),
        Icon: MdClose,
        onClick: onClear,
      },
    ]
  }

  useEffect(() => {
    if (mobile === false && autoFocus) {
      setTimeout(() => {
        ref.current?.focus()
      })
    }
  }, [autoFocus, mobile, ref])

  return (
    <div className={clsx('flex flex-col', className)}>
      <Label name={name} hide={hideLabel}>
        {name}
      </Label>
      <div className="bg-default textfield flex grow items-center">
        <Component
          ref={ref}
          name={name}
          id={name}
          className={clsx(
            'typescale-body-medium text-on-surface-variant placeholder:text-outline/60 w-0 flex-1 bg-transparent py-1 px-1.5 !text-[13px]',
            isInput || 'scroll h-full resize-none',
          )}
          {...(datalist && { list: datalistId })}
          {...props}
        />
        {datalist && <datalist id={datalistId}>{datalist}</datalist>}
        {!!actions.length && (
          <div className="mx-1 flex gap-0.5">
            {actions.map(({ onClick, ...a }) => (
              <IconButton
                className="text-outline !p-px"
                key={a.title}
                onClick={() => {
                  onClick(ref.current)
                }}
                {...a}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  )
}

interface CheckboxProps extends ComponentProps<'input'> {
  name: string
}
export const Checkbox: React.FC<CheckboxProps> = ({ name, ...props }) => {
  return (
    <div className="flex items-center">
      <Label name={name} />
      <div className="checkbox bg-default relative ml-auto rounded-sm">
        <input
          type="checkbox"
          name={name}
          id={name}
          className="peer block h-4 w-4 appearance-none"
          {...props}
        />
        <MdCheck className="text-on-surface-variant pointer-events-none invisible absolute top-0 peer-checked:visible" />
      </div>
    </div>
  )
}

interface SelectProps extends ComponentProps<'select'> {
  name?: string
}
export const Select: React.FC<SelectProps> = ({
  name,
  className,
  ...props
}) => {
  return (
    <div className={clsx('flex flex-col', className)}>
      {name && <Label name={name} />}
      <select
        name={name}
        id={name}
        className={clsx(
          'typescale-body-medium text-on-surface-variant bg-default max-w-xs px-0.5 py-1 !text-[13px]',
        )}
        {...props}
      ></select>
    </div>
  )
}

interface ColorPickerProps extends ComponentProps<'input'> {
  name?: string
}
export const ColorPicker: React.FC<ColorPickerProps> = ({
  name,
  className,
  ...props
}) => {
  return (
    <div className={clsx('flex flex-col', className)}>
      {name && <Label name={name} />}
      <input
        type="color"
        name={name}
        id={name}
        className="h-6 w-12"
        {...props}
      />
    </div>
  )
}

interface LabelProps extends ComponentProps<'label'> {
  name: string
  hide?: boolean
}
export const Label: React.FC<LabelProps> = ({
  name,
  hide = false,
  className,
}) => {
  return (
    <label
      htmlFor={name}
      className={clsx(
        'typescale-label-medium text-on-surface-variant mb-1 block !text-[13px]',
        hide && 'hidden',
        className,
      )}
    >
      {name}
    </label>
  )
}

</code>

apps\reader\src\components\index.ts:
<code>
export * from './Annotation'
export * from './base'
export * from './Button'
export * from './ErrorBoundary'
export * from './Form'
export * from './Layout'
export * from './Page'
export * from './pages'
export * from './Reader'
export * from './Row'
export * from './Tab'
export * from './TextSelectionMenu'
export * from './Theme'

</code>

apps\reader\src\components\Layout.tsx:
<code>
import { Overlay } from '@literal-ui/core'
import clsx from 'clsx'
import { ComponentProps, useEffect, useState } from 'react'
import { useMemo } from 'react'
import { IconType } from 'react-icons'
import {
  MdFormatUnderlined,
  MdOutlineImage,
  MdSearch,
  MdToc,
  MdTimeline,
  MdOutlineLightMode,
} from 'react-icons/md'
import { RiFontSize, RiHome6Line, RiSettings5Line } from 'react-icons/ri'
import { useRecoilState } from 'recoil'

import {
  Env,
  Action,
  useAction,
  useBackground,
  useColorScheme,
  useMobile,
  useSetAction,
  useTranslation,
} from '../hooks'
import { reader, useReaderSnapshot } from '../models'
import { navbarState } from '../state'
import { activeClass } from '../styles'

import { SplitView, useSplitViewItem } from './base'
import { Settings } from './pages'
import { AnnotationView } from './viewlets/AnnotationView'
import { ImageView } from './viewlets/ImageView'
import { SearchView } from './viewlets/SearchView'
import { ThemeView } from './viewlets/ThemeView'
import { TimelineView } from './viewlets/TimelineView'
import { TocView } from './viewlets/TocView'
import { TypographyView } from './viewlets/TypographyView'

export const Layout: React.FC = ({ children }) => {
  useColorScheme()

  const [ready, setReady] = useState(false)
  const setAction = useSetAction()
  const mobile = useMobile()

  useEffect(() => {
    if (mobile === undefined) return
    setAction(mobile ? undefined : 'toc')
    setReady(true)
  }, [mobile, setAction])

  return (
    <div id="layout" className="select-none">
      <SplitView>
        {mobile === false && <ActivityBar />}
        {mobile === true && <NavigationBar />}
        {ready && <SideBar />}
        {ready && <Reader>{children}</Reader>}
      </SplitView>
    </div>
  )
}

interface IAction {
  name: string
  title: string
  Icon: IconType
  env: number
}
interface IViewAction extends IAction {
  name: Action
  View: React.FC<any>
}

const viewActions: IViewAction[] = [
  {
    name: 'toc',
    title: 'toc',
    Icon: MdToc,
    View: TocView,
    env: Env.Desktop | Env.Mobile,
  },
  {
    name: 'search',
    title: 'search',
    Icon: MdSearch,
    View: SearchView,
    env: Env.Desktop | Env.Mobile,
  },
  {
    name: 'annotation',
    title: 'annotation',
    Icon: MdFormatUnderlined,
    View: AnnotationView,
    env: Env.Desktop | Env.Mobile,
  },
  {
    name: 'image',
    title: 'image',
    Icon: MdOutlineImage,
    View: ImageView,
    env: Env.Desktop,
  },
  {
    name: 'timeline',
    title: 'timeline',
    Icon: MdTimeline,
    View: TimelineView,
    env: Env.Desktop,
  },
  {
    name: 'typography',
    title: 'typography',
    Icon: RiFontSize,
    View: TypographyView,
    env: Env.Desktop | Env.Mobile,
  },
  {
    name: 'theme',
    title: 'theme',
    Icon: MdOutlineLightMode,
    View: ThemeView,
    env: Env.Desktop | Env.Mobile,
  },
]

const ActivityBar: React.FC = () => {
  useSplitViewItem(ActivityBar, {
    preferredSize: 48,
    minSize: 48,
    maxSize: 48,
  })
  return (
    <div className="ActivityBar flex flex-col justify-between">
      <ViewActionBar env={Env.Desktop} />
      <PageActionBar env={Env.Desktop} />
    </div>
  )
}

interface EnvActionBarProps extends ComponentProps<'div'> {
  env: Env
}

function ViewActionBar({ className, env }: EnvActionBarProps) {
  const [action, setAction] = useAction()
  const t = useTranslation()

  return (
    <ActionBar className={className}>
      {viewActions
        .filter((a) => a.env & env)
        .map(({ name, title, Icon }) => {
          const active = action === name
          return (
            <Action
              title={t(`${title}.title`)}
              Icon={Icon}
              active={active}
              onClick={() => setAction(active ? undefined : name)}
              key={name}
            />
          )
        })}
    </ActionBar>
  )
}

function PageActionBar({ env }: EnvActionBarProps) {
  const mobile = useMobile()
  const [action, setAction] = useState('Home')
  const t = useTranslation()

  interface IPageAction extends IAction {
    Component?: React.FC
    disabled?: boolean
  }

  const pageActions: IPageAction[] = useMemo(
    () => [
      {
        name: 'home',
        title: 'home',
        Icon: RiHome6Line,
        env: Env.Mobile,
      },
      {
        name: 'settings',
        title: 'settings',
        Icon: RiSettings5Line,
        Component: Settings,
        env: Env.Desktop | Env.Mobile,
      },
    ],
    [],
  )

  return (
    <ActionBar>
      {pageActions
        .filter((a) => a.env & env)
        .map(({ name, title, Icon, Component, disabled }, i) => (
          <Action
            title={t(`${title}.title`)}
            Icon={Icon}
            active={mobile ? action === name : undefined}
            disabled={disabled}
            onClick={() => {
              Component ? reader.addTab(Component) : reader.clear()
              setAction(name)
            }}
            key={i}
          />
        ))}
    </ActionBar>
  )
}

function NavigationBar() {
  const r = useReaderSnapshot()
  const readMode = r.focusedTab?.isBook
  const [visible, setVisible] = useRecoilState(navbarState)

  return (
    <>
      {visible && (
        <Overlay
          className="!bg-transparent"
          onClick={() => setVisible(false)}
        />
      )}
      <div className="NavigationBar bg-surface border-surface-variant fixed inset-x-0 bottom-0 z-10 border-t">
        {readMode ? (
          <ViewActionBar
            env={Env.Mobile}
            className={clsx(visible || 'hidden')}
          />
        ) : (
          <PageActionBar env={Env.Mobile} />
        )}
      </div>
    </>
  )
}

interface ActionBarProps extends ComponentProps<'ul'> {}
function ActionBar({ className, ...props }: ActionBarProps) {
  return (
    <ul className={clsx('ActionBar flex sm:flex-col', className)} {...props} />
  )
}

interface ActionProps extends ComponentProps<'button'> {
  Icon: IconType
  active?: boolean
}
const Action: React.FC<ActionProps> = ({
  className,
  Icon,
  active,
  ...props
}) => {
  const mobile = useMobile()
  return (
    <button
      className={clsx(
        'Action relative flex h-12 w-12 flex-1 items-center justify-center sm:flex-initial',
        active ? 'text-on-surface-variant' : 'text-outline/70',
        props.disabled ? 'text-on-disabled' : 'hover:text-on-surface-variant ',
        className,
      )}
      {...props}
    >
      {active &&
        (mobile || (
          <div
            className={clsx('absolute', 'inset-y-0 left-0 w-0.5', activeClass)}
          />
        ))}
      <Icon size={28} />
    </button>
  )
}

const SideBar: React.FC = () => {
  const [action, setAction] = useAction()
  const mobile = useMobile()
  const t = useTranslation()

  const { size } = useSplitViewItem(SideBar, {
    preferredSize: 240,
    minSize: 160,
    visible: !!action,
  })

  return (
    <>
      {action && mobile && <Overlay onClick={() => setAction(undefined)} />}
      <div
        className={clsx(
          'SideBar bg-surface flex flex-col',
          !action && '!hidden',
          mobile ? 'absolute inset-y-0 right-0 z-10' : '',
        )}
        style={{ width: mobile ? '75%' : size }}
      >
        {viewActions.map(({ name, title, View }) => (
          <View
            key={name}
            name={t(`${name}.title`)}
            title={t(`${title}.title`)}
            className={clsx(name !== action && '!hidden')}
          />
        ))}
      </div>
    </>
  )
}

interface ReaderProps extends ComponentProps<'div'> {}
const Reader: React.FC = ({ className, ...props }: ReaderProps) => {
  useSplitViewItem(Reader)
  const [bg] = useBackground()

  const r = useReaderSnapshot()
  const readMode = r.focusedTab?.isBook

  return (
    <div
      className={clsx(
        'Reader flex-1 overflow-hidden',
        readMode || 'mb-12 sm:mb-0',
        bg,
      )}
      {...props}
    />
  )
}

</code>

apps\reader\src\components\Page.tsx:
<code>
import clsx from 'clsx'
import { ComponentProps } from 'react'

interface PageProps extends ComponentProps<'div'> {
  headline: string
}
export const Page: React.FC<PageProps> = ({
  className,
  children,
  headline,
  ...props
}) => {
  return (
    <div className={clsx('p-4', className)} {...props}>
      <h1
        className={clsx(
          'typescale-title-large text-on-surface-variant mb-4',
          className,
        )}
        {...props}
      >
        {headline}
      </h1>
      {children}
    </div>
  )
}

</code>

apps\reader\src\components\Reader.tsx:
<code>
import { useEventListener } from '@literal-ui/hooks'
import clsx from 'clsx'
import React, {
  ComponentProps,
  useCallback,
  useEffect,
  useRef,
  useState,
} from 'react'
import { MdChevronRight, MdWebAsset } from 'react-icons/md'
import { RiBookLine } from 'react-icons/ri'
import { PhotoSlider } from 'react-photo-view'
import { useSetRecoilState } from 'recoil'
import useTilg from 'tilg'
import { useSnapshot } from 'valtio'

import { RenditionSpread } from '@flow/epubjs/types/rendition'
import { navbarState } from '@flow/reader/state'

import { db } from '../db'
import { handleFiles } from '../file'
import {
  hasSelection,
  useBackground,
  useColorScheme,
  useDisablePinchZooming,
  useMobile,
  useSync,
  useTranslation,
  useTypography,
} from '../hooks'
import { BookTab, reader, useReaderSnapshot } from '../models'
import { isTouchScreen } from '../platform'
import { updateCustomStyle } from '../styles'

import {
  getClickedAnnotation,
  setClickedAnnotation,
  Annotations,
} from './Annotation'
import { Tab } from './Tab'
import { TextSelectionMenu } from './TextSelectionMenu'
import { DropZone, SplitView, useDndContext, useSplitViewItem } from './base'
import * as pages from './pages'

function handleKeyDown(tab?: BookTab) {
  return (e: KeyboardEvent) => {
    try {
      switch (e.code) {
        case 'ArrowLeft':
        case 'ArrowUp':
          tab?.prev()
          break
        case 'ArrowRight':
        case 'ArrowDown':
          tab?.next()
          break
        case 'Space':
          e.shiftKey ? tab?.prev() : tab?.next()
      }
    } catch (error) {
      // ignore `rendition is undefined` error
    }
  }
}

export function ReaderGridView() {
  const { groups } = useReaderSnapshot()

  useEventListener('keydown', handleKeyDown(reader.focusedBookTab))

  if (!groups.length) return null
  return (
    <SplitView className={clsx('ReaderGridView')}>
      {groups.map(({ id }, i) => (
        <ReaderGroup key={id} index={i} />
      ))}
    </SplitView>
  )
}

interface ReaderGroupProps {
  index: number
}
function ReaderGroup({ index }: ReaderGroupProps) {
  const group = reader.groups[index]!
  const { focusedIndex } = useReaderSnapshot()
  const { tabs, selectedIndex } = useSnapshot(group)
  const t = useTranslation()

  const { size } = useSplitViewItem(`${ReaderGroup.name}.${index}`, {
    // to disable sash resize
    visible: false,
  })

  const handleMouseDown = useCallback(() => {
    reader.selectGroup(index)
  }, [index])

  return (
    <div
      className="ReaderGroup flex flex-1 flex-col overflow-hidden focus:outline-none"
      onMouseDown={handleMouseDown}
      style={{ width: size }}
    >
      <Tab.List
        className="hidden sm:flex"
        onDelete={() => reader.removeGroup(index)}
      >
        {tabs.map((tab, i) => {
          const selected = i === selectedIndex
          const focused = index === focusedIndex && selected
          return (
            <Tab
              key={tab.id}
              selected={selected}
              focused={focused}
              onClick={() => group.selectTab(i)}
              onDelete={() => reader.removeTab(i, index)}
              Icon={tab instanceof BookTab ? RiBookLine : MdWebAsset}
              draggable
              onDragStart={(e) => {
                e.dataTransfer.setData('text/plain', `${index},${i}`)
              }}
            >
              {tab.isBook ? tab.title : t(`${tab.title}.title`)}
            </Tab>
          )
        })}
      </Tab.List>

      <DropZone
        className={clsx('flex-1', isTouchScreen || 'h-0')}
        split
        onDrop={async (e, position) => {
          // read `e.dataTransfer` first to avoid get empty value after `await`
          const files = e.dataTransfer.files
          let tabs = []

          if (files.length) {
            tabs = await handleFiles(files)
          } else {
            const text = e.dataTransfer.getData('text/plain')
            const fromTab = text.includes(',')

            if (fromTab) {
              const indexes = text.split(',')
              const groupIdx = Number(indexes[0])

              if (index === groupIdx) {
                if (group.tabs.length === 1) return
                if (position === 'universe') return
              }

              const tabIdx = Number(indexes[1])
              const tab = reader.removeTab(tabIdx, groupIdx)
              if (tab) tabs.push(tab)
            } else {
              const id = text
              const tabParam =
                Object.values(pages).find((p) => p.displayName === id) ??
                (await db?.books.get(id))
              if (tabParam) tabs.push(tabParam)
            }
          }

          if (tabs.length) {
            switch (position) {
              case 'left':
                reader.addGroup(tabs, index)
                break
              case 'right':
                reader.addGroup(tabs, index + 1)
                break
              default:
                tabs.forEach((t) => reader.addTab(t, index))
            }
          }
        }}
      >
        {group.tabs.map((tab, i) => (
          <PaneContainer active={i === selectedIndex} key={tab.id}>
            {tab instanceof BookTab ? (
              <BookPane tab={tab} onMouseDown={handleMouseDown} />
            ) : (
              <tab.Component />
            )}
          </PaneContainer>
        ))}
      </DropZone>
    </div>
  )
}

interface PaneContainerProps {
  active: boolean
}
const PaneContainer: React.FC<PaneContainerProps> = ({ active, children }) => {
  return <div className={clsx('h-full', active || 'hidden')}>{children}</div>
}

interface BookPaneProps {
  tab: BookTab
  onMouseDown: () => void
}

function BookPane({ tab, onMouseDown }: BookPaneProps) {
  const ref = useRef<HTMLDivElement>(null)
  const prevSize = useRef(0)
  const typography = useTypography(tab)
  const { dark } = useColorScheme()
  const [background] = useBackground()

  const { iframe, rendition, rendered, container } = useSnapshot(tab)

  useTilg()

  useEffect(() => {
    const el = ref.current
    if (!el) return

    const observer = new ResizeObserver(([e]) => {
      const size = e?.contentRect.width ?? 0
      // `display: hidden` will lead `rect` to 0
      if (size !== 0 && prevSize.current !== 0) {
        reader.resize()
      }
      prevSize.current = size
    })

    observer.observe(el)

    return () => {
      observer.disconnect()
    }
  }, [])

  useSync(tab)

  const setNavbar = useSetRecoilState(navbarState)
  const mobile = useMobile()

  const applyCustomStyle = useCallback(() => {
    const contents = rendition?.getContents()[0]
    updateCustomStyle(contents, typography)
  }, [rendition, typography])

  useEffect(() => {
    tab.onRender = applyCustomStyle
  }, [applyCustomStyle, tab])

  useEffect(() => {
    if (ref.current) tab.render(ref.current)
  }, [tab])

  useEffect(() => {
    /**
     * when `spread` changes, we should call `spread()` to re-layout,
     * then call {@link updateCustomStyle} to update custom style
     * according to the latest layout
     */
    rendition?.spread(typography.spread ?? RenditionSpread.Auto)
  }, [typography.spread, rendition])

  useEffect(() => applyCustomStyle(), [applyCustomStyle])

  useEffect(() => {
    if (dark === undefined) return
    // set `!important` when in dark mode
    rendition?.themes.override('color', dark ? '#bfc8ca' : '#3f484a', dark)
  }, [rendition, dark])

  const [src, setSrc] = useState<string>()

  useEffect(() => {
    if (src) {
      if (document.activeElement instanceof HTMLElement)
        document.activeElement?.blur()
    }
  }, [src])

  const { setDragEvent } = useDndContext()

  // `dragenter` not fired in iframe when the count of times is even, so use `dragover`
  useEventListener(iframe, 'dragover', (e: any) => {
    console.log('drag enter in iframe')
    setDragEvent(e)
  })

  useEventListener(iframe, 'mousedown', onMouseDown)

  useEventListener(iframe, 'click', (e) => {
    // https://developer.chrome.com/blog/tap-to-search
    e.preventDefault()

    for (const el of e.composedPath() as any) {
      // `instanceof` may not work in iframe
      if (el.tagName === 'A' && el.href) {
        tab.showPrevLocation()
        return
      }
      if (
        mobile === false &&
        el.tagName === 'IMG' &&
        el.src.startsWith('blob:')
      ) {
        setSrc(el.src)
        return
      }
    }

    if (isTouchScreen && container) {
      if (getClickedAnnotation()) {
        setClickedAnnotation(false)
        return
      }

      const w = container.clientWidth
      const x = e.clientX % w
      const threshold = 0.3
      const side = w * threshold

      if (x < side) {
        tab.prev()
      } else if (w - x < side) {
        tab.next()
      } else if (mobile) {
        setNavbar((a) => !a)
      }
    }
  })

  useEventListener(iframe, 'wheel', (e) => {
    if (e.deltaY < 0) {
      tab.prev()
    } else {
      tab.next()
    }
  })

  useEventListener(iframe, 'keydown', handleKeyDown(tab))

  useEventListener(iframe, 'touchstart', (e) => {
    const x0 = e.targetTouches[0]?.clientX ?? 0
    const y0 = e.targetTouches[0]?.clientY ?? 0
    const t0 = Date.now()

    if (!iframe) return

    // When selecting text with long tap, `touchend` is not fired,
    // so instead of use `addEventlistener`, we should use `on*`
    // to remove the previous listener.
    iframe.ontouchend = function handleTouchEnd(e: TouchEvent) {
      iframe.ontouchend = undefined
      const selection = iframe.getSelection()
      if (hasSelection(selection)) return

      const x1 = e.changedTouches[0]?.clientX ?? 0
      const y1 = e.changedTouches[0]?.clientY ?? 0
      const t1 = Date.now()

      const deltaX = x1 - x0
      const deltaY = y1 - y0
      const deltaT = t1 - t0

      const absX = Math.abs(deltaX)
      const absY = Math.abs(deltaY)

      if (absX < 10) return

      if (absY / absX > 2) {
        if (deltaT > 100 || absX < 30) {
          return
        }
      }

      if (deltaX > 0) {
        tab.prev()
      }

      if (deltaX < 0) {
        tab.next()
      }
    }
  })

  useDisablePinchZooming(iframe)

  return (
    <div className={clsx('flex h-full flex-col', mobile && 'py-[3vw]')}>
      <PhotoSlider
        images={[{ src, key: 0 }]}
        visible={!!src}
        onClose={() => setSrc(undefined)}
        maskOpacity={0.6}
        bannerVisible={false}
      />
      <ReaderPaneHeader tab={tab} />
      <div
        ref={ref}
        className={clsx('relative flex-1', isTouchScreen || 'h-0')}
        // `color-scheme: dark` will make iframe background white
        style={{ colorScheme: 'auto' }}
      >
        <div
          className={clsx(
            'absolute inset-0',
            // do not cover `sash`
            'z-20',
            rendered && 'hidden',
            background,
          )}
        />
        <TextSelectionMenu tab={tab} />
        <Annotations tab={tab} />
      </div>
      <ReaderPaneFooter tab={tab} />
    </div>
  )
}

interface ReaderPaneHeaderProps {
  tab: BookTab
}
const ReaderPaneHeader: React.FC<ReaderPaneHeaderProps> = ({ tab }) => {
  const { location } = useSnapshot(tab)
  const navPath = tab.getNavPath()

  useEffect(() => {
    navPath.forEach((i) => (i.expanded = true))
  }, [navPath])

  return (
    <Bar>
      <div className="scroll-h flex">
        {navPath.map((item, i) => (
          <button
            key={i}
            className="hover:text-on-surface flex shrink-0 items-center"
          >
            {item.label}
            {i !== navPath.length - 1 && <MdChevronRight size={20} />}
          </button>
        ))}
      </div>
      {location && (
        <div className="shrink-0">
          {location.start.displayed.page} / {location.start.displayed.total}
        </div>
      )}
    </Bar>
  )
}

interface FooterProps {
  tab: BookTab
}
const ReaderPaneFooter: React.FC<FooterProps> = ({ tab }) => {
  const { locationToReturn, location, book } = useSnapshot(tab)

  return (
    <Bar>
      {locationToReturn ? (
        <>
          <button
            className={clsx(locationToReturn || 'invisible')}
            onClick={() => {
              tab.hidePrevLocation()
              tab.display(locationToReturn.end.cfi, false)
            }}
          >
            Return to {locationToReturn.end.cfi}
          </button>
          <button
            onClick={() => {
              tab.hidePrevLocation()
            }}
          >
            Stay
          </button>
        </>
      ) : (
        <>
          <div>{location?.start.href}</div>
          <div>{((book.percentage ?? 0) * 100).toFixed()}%</div>
        </>
      )}
    </Bar>
  )
}

interface LineProps extends ComponentProps<'div'> {}
const Bar: React.FC<LineProps> = ({ className, ...props }) => {
  return (
    <div
      className={clsx(
        'typescale-body-small text-outline flex h-6 items-center justify-between gap-2 px-[4vw] sm:px-2',
        className,
      )}
      {...props}
    ></div>
  )
}

</code>

apps\reader\src\components\Row.tsx:
<code>
import { StateLayer } from '@literal-ui/core'
import clsx from 'clsx'
import { ComponentProps, useEffect, useRef } from 'react'
import { MdClose } from 'react-icons/md'
import { VscChevronDown, VscChevronRight } from 'react-icons/vsc'

import { LIST_ITEM_SIZE, useTranslation } from '../hooks'
import { scale } from '../platform'

import { IconButton } from './Button'

interface RowProps extends ComponentProps<'div'> {
  expanded?: boolean
  active?: boolean
  depth?: number
  label?: string
  description?: string | number
  info?: string
  subitems?: Readonly<any[]>
  toggle?: () => void
  onActivate?: () => void
  onDelete?: () => void
  badge?: boolean
}
export const Row: React.FC<RowProps> = ({
  title,
  label,
  description,
  info,
  expanded = false,
  active = false,
  depth = 0,
  subitems,
  toggle,
  onActivate,
  className,
  children,
  badge,
  onClick,
  onDelete,
  ...props
}) => {
  const trans = useTranslation()
  const onActivateRef = useRef(onActivate)
  onActivateRef.current = onActivate

  const childCount = subitems?.length
  const t = children || label || title

  useEffect(() => {
    if (active) onActivateRef.current?.()
  }, [active])

  return (
    <div
      className={clsx(
        'list-row relative flex cursor-pointer items-center text-left',
        active && 'bg-outline/20',
        className,
      )}
      style={{
        paddingLeft: depth * 8,
        paddingRight: 12,
        height: LIST_ITEM_SIZE,
      }}
      title={title}
      onClick={onClick ?? toggle}
      {...props}
    >
      <StateLayer />
      <Twisty
        expanded={expanded}
        className={clsx(!childCount && 'invisible')}
        onClick={(e) => {
          e.stopPropagation()
          toggle?.()
        }}
      />
      <div
        className={clsx(
          'typescale-body-small truncate',
          t ? 'text-on-surface-variant' : 'text-outline/60',
        )}
        style={{
          fontSize: scale(12, 14),
          marginLeft: scale(0, 2),
        }}
      >
        {t || trans('untitled')}
        {description && (
          <span
            className="text-outline"
            style={{
              fontSize: scale(11, 12),
              marginLeft: scale(4, 6),
            }}
          >
            {description}
          </span>
        )}
      </div>
      <div className="ml-auto">
        {badge && childCount && (
          <div
            className="bg-tertiary-container text-on-tertiary-container rounded-full px-1.5 py-px"
            style={{
              fontSize: scale(11, 12),
            }}
          >
            {childCount}
          </div>
        )}
        {onDelete && (
          <IconButton
            className="action hidden"
            Icon={MdClose}
            onClick={(e) => {
              e.stopPropagation()
              onDelete?.()
            }}
          />
        )}
        <span className="text-outline">{info}</span>
      </div>
    </div>
  )
}

interface TwistyProps extends ComponentProps<'svg'> {
  expanded: boolean
}
export const Twisty: React.FC<TwistyProps> = ({
  expanded,
  className,
  ...props
}) => {
  const Icon = expanded ? VscChevronDown : VscChevronRight
  return (
    <Icon
      size={20}
      className={clsx('text-outline shrink-0', className)}
      style={{ padding: scale(2, 1) }}
      {...props}
    />
  )
}

</code>

apps\reader\src\components\Tab.tsx:
<code>
import clsx from 'clsx'
import { ComponentProps } from 'react'
import { IconType } from 'react-icons'
import { MdClose } from 'react-icons/md'

import { useBackground, useTranslation } from '../hooks'
import { activeClass } from '../styles'

import { IconButton } from './Button'

interface TabProps extends ComponentProps<'div'> {
  onDelete?: () => void
  selected?: boolean
  focused?: boolean
  Icon: IconType
  children?: string
}
export function Tab({
  selected,
  focused,
  Icon,
  className,
  children,
  onDelete,
  ...props
}: TabProps) {
  const [bg] = useBackground()
  const t = useTranslation()

  if (!children) return null
  return (
    <div
      role="tab"
      className={clsx(
        ' typescale-body-small relative flex cursor-pointer items-center gap-1 p-2 pr-1',
        selected ? `text-outline ${bg}` : `text-outline/60 hover:${bg}`,
        focused && '!text-on-surface',
        className,
      )}
      title={children}
      {...props}
    >
      {focused && (
        <div className={clsx('absolute inset-x-0 top-0 h-px', activeClass)} />
      )}
      <Icon size={16} className="text-outline" />
      <span className="max-w-[200px] truncate">{children}</span>
      <IconButton
        title={t('action.close')}
        Icon={MdClose}
        onClick={(e) => {
          e.stopPropagation()
          onDelete?.()
        }}
      />
    </div>
  )
}

interface ListProps extends ComponentProps<'ul'> {
  onDelete?: () => void
}
const List: React.FC<ListProps> = ({ className, onDelete, ...props }) => {
  const t = useTranslation()

  return (
    <div
      className={clsx(
        'bg-primary/5 flex items-center justify-between',
        className,
      )}
    >
      <ul className={clsx('scroll-h flex')} {...props} />
      <IconButton
        className="mx-2"
        title={t('action.close')}
        Icon={MdClose}
        onClick={(e) => {
          e.stopPropagation()
          onDelete?.()
        }}
      />
    </div>
  )
}

Tab.List = List

</code>

apps\reader\src\components\TextSelectionMenu.tsx:
<code>
import { Overlay } from '@literal-ui/core'
import clsx from 'clsx'
import { useCallback, useRef, useState } from 'react'
import FocusLock from 'react-focus-lock'
import {
  MdCopyAll,
  MdOutlineAddBox,
  MdOutlineEdit,
  MdOutlineIndeterminateCheckBox,
  MdSearch,
} from 'react-icons/md'
import { useSnapshot } from 'valtio'

import { typeMap, colorMap } from '../annotation'
import {
  isForwardSelection,
  useMobile,
  useSetAction,
  useTextSelection,
  useTranslation,
  useTypography,
} from '../hooks'
import { BookTab } from '../models'
import { isTouchScreen, scale } from '../platform'
import { copy, keys, last } from '../utils'

import { Button, IconButton } from './Button'
import { TextField } from './Form'
import { layout, LayoutAnchorMode, LayoutAnchorPosition } from './base'

interface TextSelectionMenuProps {
  tab: BookTab
}
export const TextSelectionMenu: React.FC<TextSelectionMenuProps> = ({
  tab,
}) => {
  const { rendition, annotationRange } = useSnapshot(tab)

  // `manager` is not reactive, so we need to use getter
  const view = useCallback(() => {
    return rendition?.manager?.views._views[0]
  }, [rendition])

  const win = view()?.window
  const [selection, setSelection] = useTextSelection(win)

  const el = view()?.element as HTMLElement
  if (!el) return null

  // it is possible that both `selection` and `tab.annotationRange`
  // are set when select end within an annotation
  const range = selection?.getRangeAt(0) ?? annotationRange
  if (!range) return null

  // prefer to display above the selection to avoid text selection helpers
  // https://stackoverflow.com/questions/68081757/hide-the-two-text-selection-helpers-in-mobile-browsers
  const forward = isTouchScreen
    ? false
    : selection
    ? isForwardSelection(selection)
    : true

  const rects = [...range.getClientRects()].filter((r) => Math.round(r.width))
  const anchorRect = rects && (forward ? last(rects) : rects[0])
  if (!anchorRect) return null

  const contents = range.cloneContents()
  const text = contents.textContent?.trim()
  if (!text) return null

  return (
    // to reset inner state
    <TextSelectionMenuRenderer
      tab={tab}
      range={range as Range}
      anchorRect={anchorRect}
      containerRect={el.parentElement!.getBoundingClientRect()}
      viewRect={el.getBoundingClientRect()}
      text={text}
      forward={forward}
      hide={() => {
        if (selection) {
          selection.removeAllRanges()
          setSelection(undefined)
        }
        /**
         * {@link range}
         */
        if (tab.annotationRange) {
          tab.annotationRange = undefined
        }
      }}
    />
  )
}

const ICON_SIZE = scale(22, 28)
const ANNOTATION_SIZE = scale(24, 30)

interface TextSelectionMenuRendererProps {
  tab: BookTab
  range: Range
  anchorRect: DOMRect
  containerRect: DOMRect
  viewRect: DOMRect
  text: string
  forward: boolean
  hide: () => void
}
const TextSelectionMenuRenderer: React.FC<TextSelectionMenuRendererProps> = ({
  tab,
  range,
  anchorRect,
  containerRect,
  viewRect,
  forward,
  text,
  hide,
}) => {
  const setAction = useSetAction()
  const ref = useRef<HTMLInputElement>(null)
  const [width, setWidth] = useState(0)
  const [height, setHeight] = useState(0)
  const mobile = useMobile()
  const t = useTranslation('menu')

  const cfi = tab.rangeToCfi(range)
  const annotation = tab.book.annotations.find((a) => a.cfi === cfi)
  const [annotate, setAnnotate] = useState(!!annotation)

  const position = forward
    ? LayoutAnchorPosition.Before
    : LayoutAnchorPosition.After

  const { zoom } = useTypography(tab)
  const endContainer = forward ? range.endContainer : range.startContainer
  const _lineHeight = parseFloat(
    getComputedStyle(endContainer.parentElement!).lineHeight,
  )
  // no custom line height and the origin is keyword, e.g. 'normal'.
  const lineHeight = isNaN(_lineHeight)
    ? anchorRect.height
    : _lineHeight * (zoom ?? 1)

  return (
    <FocusLock disabled={mobile}>
      <Overlay
        // cover `sash`
        className="!z-50 !bg-transparent"
        onMouseDown={hide}
      />
      <div
        ref={(el) => {
          if (!el) return
          setWidth(el.clientWidth)
          setHeight(el.clientHeight)
          if (!mobile) {
            el.focus()
          }
        }}
        className={clsx(
          'bg-surface text-on-surface-variant shadow-1 absolute z-50 p-2 focus:outline-none',
        )}
        style={{
          left: layout(containerRect.width, width, {
            offset: anchorRect.left + viewRect.left - containerRect.left,
            size: anchorRect.width,
            mode: LayoutAnchorMode.ALIGN,
            position,
          }),
          top: layout(containerRect.height, height, {
            offset: anchorRect.top - (lineHeight - anchorRect.height) / 2,
            size: lineHeight,
            position,
          }),
        }}
        tabIndex={-1}
        onKeyDown={(e) => {
          e.stopPropagation()
          if (e.key === 'c' && e.ctrlKey) {
            copy(text)
          }
        }}
      >
        {annotate ? (
          <div className="mb-3">
            <TextField
              mRef={ref}
              as="textarea"
              name="notes"
              defaultValue={annotation?.notes}
              hideLabel
              className="h-40 w-72"
              autoFocus
            />
          </div>
        ) : (
          <div className="text-on-surface-variant -mx- mb-3 flex gap-1">
            <IconButton
              title={t('copy')}
              Icon={MdCopyAll}
              size={ICON_SIZE}
              onClick={() => {
                hide()
                copy(text)
              }}
            />
            <IconButton
              title={t('search_in_book')}
              Icon={MdSearch}
              size={ICON_SIZE}
              onClick={() => {
                hide()
                setAction('search')
                tab.setKeyword(text)
              }}
            />
            <IconButton
              title={t('annotate')}
              Icon={MdOutlineEdit}
              size={ICON_SIZE}
              onClick={() => {
                setAnnotate(true)
              }}
            />
            {tab.isDefined(text) ? (
              <IconButton
                title={t('undefine')}
                Icon={MdOutlineIndeterminateCheckBox}
                size={ICON_SIZE}
                onClick={() => {
                  hide()
                  tab.undefine(text)
                }}
              />
            ) : (
              <IconButton
                title={t('define')}
                Icon={MdOutlineAddBox}
                size={ICON_SIZE}
                onClick={() => {
                  hide()
                  tab.define([text])
                }}
              />
            )}
          </div>
        )}
        <div className="space-y-2">
          {keys(typeMap).map((type) => (
            <div key={type} className="flex gap-2">
              {keys(colorMap).map((color) => (
                <div
                  key={color}
                  style={{
                    [typeMap[type].style]: colorMap[color],
                    width: ANNOTATION_SIZE,
                    height: ANNOTATION_SIZE,
                    fontSize: scale(16, 20),
                  }}
                  className={clsx(
                    'typescale-body-large text-on-surface-variant flex cursor-pointer items-center justify-center',
                    typeMap[type].class,
                  )}
                  onClick={() => {
                    tab.putAnnotation(
                      type,
                      cfi,
                      color,
                      text,
                      ref.current?.value,
                    )
                    hide()
                  }}
                >
                  A
                </div>
              ))}
            </div>
          ))}
        </div>
        {annotate && (
          <div className="mt-3 flex">
            {annotation && (
              <Button
                compact
                variant="secondary"
                onClick={() => {
                  tab.removeAnnotation(cfi)
                  hide()
                }}
              >
                {t('delete')}
              </Button>
            )}
            <Button
              className="ml-auto"
              compact
              onClick={() => {
                tab.putAnnotation(
                  annotation?.type ?? 'highlight',
                  cfi,
                  annotation?.color ?? 'yellow',
                  text,
                  ref.current?.value,
                )
                hide()
              }}
            >
              {t(annotation ? 'update' : 'create')}
            </Button>
          </div>
        )}
      </div>
    </FocusLock>
  )
}

</code>

apps\reader\src\components\Theme.tsx:
<code>
import {
  themeFromSourceColor,
  argbFromHex,
  Theme,
} from '@material/material-color-utilities'
import Head from 'next/head'
import { useEffect, useMemo } from 'react'

import { range } from '@flow/internal'

import { rgbFromArgb } from '../color'
import { useSetTheme, useSourceColor } from '../hooks'

// let `tailwindcss` generate classes
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const classNamesToGenerate = [
  'bg-surface',
  'bg-surface1',
  'bg-surface2',
  'bg-surface3',
  'bg-surface4',
  'bg-surface5',
  'hover:bg-surface',
  'hover:bg-surface1',
  'hover:bg-surface2',
  'hover:bg-surface3',
  'hover:bg-surface4',
  'hover:bg-surface5',
]

function camelToSnake(s: string) {
  return s.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()
}

function generateCss(theme: Theme) {
  const tones = range(4).map((i) => (i + 5) * 10)
  const generateRef = () => {
    return Object.entries(theme.palettes)
      .flatMap(([k, palette]) =>
        tones.map((i) => {
          const argb = palette.tone(i)
          const rgb = rgbFromArgb(argb).join(' ')
          return `--md-ref-palette-${camelToSnake(k)}${i}:${rgb};`
        }),
      )
      .join('')
  }

  const generateSys = (schemeName: 'light' | 'dark') => {
    let css = `color-scheme: ${schemeName};`
    const scheme = theme.schemes[schemeName]
    Object.entries(scheme.toJSON()).forEach(([key, argb]) => {
      const token = camelToSnake(key)
      const rgb = rgbFromArgb(argb).join(' ')
      css += `--md-sys-color-${token}:${rgb};`
    })
    return css
  }

  return (
    `:root {${generateRef()}}` +
    `:root, .light {${generateSys('light')}}` +
    `:root.dark {${generateSys('dark')}}`
  )
}

export function Theme() {
  const { sourceColor } = useSourceColor()
  const setTheme = useSetTheme()

  const theme = useMemo(
    () => themeFromSourceColor(argbFromHex(sourceColor)),
    [sourceColor],
  )

  useEffect(() => {
    setTheme(theme)
  }, [setTheme, theme])

  return (
    <Head>
      <style
        id="theme"
        dangerouslySetInnerHTML={{ __html: generateCss(theme) }}
      ></style>
    </Head>
  )
}

</code>

apps\reader\src\components\base\ActionBar.tsx:
<code>
import clsx from 'clsx'
import { ComponentProps } from 'react'
import { IconType } from 'react-icons'

import { IconButton } from '../Button'

export interface Action {
  id: string
  title: string
  Icon: IconType
  handle: () => void
}

interface ActionBarProps extends ComponentProps<'ul'> {
  actions: Action[]
}
export const ActionBar: React.FC<ActionBarProps> = ({ actions, className }) => {
  return (
    <ul className={clsx('text-on-surface-variant flex gap-1', className)}>
      {actions.map(({ id, title, Icon, handle }) => (
        <li key={id} title={title}>
          <IconButton
            Icon={Icon}
            onClick={(e) => {
              e.stopPropagation()
              handle()
            }}
          />
        </li>
      ))}
    </ul>
  )
}

</code>

apps\reader\src\components\base\ContextView.tsx:
<code>
// https://github.com/microsoft/vscode/blob/36fdf6b697cba431beb6e391b5a8c5f3606975a1/src/vs/base/browser/ui/contextview/contextview.ts

export const enum LayoutAnchorPosition {
  Before,
  After,
}

export enum LayoutAnchorMode {
  AVOID,
  ALIGN,
}

interface ILayoutAnchor {
  offset: number
  size: number
  mode?: LayoutAnchorMode
  /** preferred anchor position */
  position: LayoutAnchorPosition
}

/**
 * {@link ./ContextView.excalidraw}
 *
 * Lays out a one dimensional view next to an anchor in a viewport.
 *
 * @returns The view offset within the viewport.
 */
export function layout(
  viewportSize: number,
  viewSize: number,
  anchor: ILayoutAnchor,
) {
  const layoutAfterAnchorBoundary =
    anchor.mode === LayoutAnchorMode.ALIGN
      ? anchor.offset
      : anchor.offset + anchor.size
  const layoutBeforeAnchorBoundary =
    anchor.mode === LayoutAnchorMode.ALIGN
      ? anchor.offset + anchor.size
      : anchor.offset

  if (anchor.position === LayoutAnchorPosition.Before) {
    if (viewSize <= viewportSize - layoutAfterAnchorBoundary) {
      return layoutAfterAnchorBoundary // happy case, lay it out after the anchor
    }

    if (viewSize <= layoutBeforeAnchorBoundary) {
      return layoutBeforeAnchorBoundary - viewSize // ok case, lay it out before the anchor
    }

    return Math.max(viewportSize - viewSize, 0) // sad case, lay it over the anchor
  } else {
    if (viewSize <= layoutBeforeAnchorBoundary) {
      return layoutBeforeAnchorBoundary - viewSize // happy case, lay it out before the anchor
    }

    if (viewSize <= viewportSize - layoutAfterAnchorBoundary) {
      return layoutAfterAnchorBoundary // ok case, lay it out after the anchor
    }

    return 0 // sad case, lay it over the anchor
  }
}

</code>

apps\reader\src\components\base\DropZone.tsx:
<code>
import clsx from 'clsx'
import {
  useContext,
  useState,
  createContext,
  DragEvent,
  useCallback,
  useEffect,
} from 'react'

interface DropZoneProps {
  className?: string
  onDrop?: (e: DragEvent<HTMLDivElement>, position?: Position) => void
  split?: boolean
}
export const DropZone: React.FC<DropZoneProps> = (props) => {
  return (
    <DndProvider>
      <DropZoneInner {...props} />
    </DndProvider>
  )
}

type Position = 'universe' | 'left' | 'right' | 'top' | 'bottom'

// > During the drag, in an event listener for the dragenter and dragover events, you use the data types of the data being dragged to check whether a drop is allowed.
// https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Drag_operations#drag_data
function accept(e?: DragEvent) {
  const dt = e?.dataTransfer
  return !!dt?.types.every((t) => ['text/plain', 'Files'].includes(t))
}

const DropZoneInner: React.FC<DropZoneProps> = ({
  children,
  className,
  onDrop,
  split = false,
}) => {
  const { dragover, setDragEvent } = useDndContext()
  const [position, setPosition] = useState<Position>()
  // console.log(dragover, position)

  useEffect(() => {
    if (!dragover) setPosition(undefined)
  }, [dragover])

  const handleDragover = useCallback(
    (e: DragEvent<HTMLDivElement>) => {
      e.stopPropagation()
      e.preventDefault()

      setPosition(() => {
        if (!split) return 'universe'

        const rect = (e.target as HTMLDivElement).getBoundingClientRect()
        if (!rect.width || !rect.height) return

        const offsetLeft = (e.clientX - rect.left) / rect.width
        const offsetTop = (e.clientY - rect.top) / rect.height
        const offsetRight = 1 - offsetLeft
        const offsetBottom = 1 - offsetTop
        const threshold = 0.15

        // TODO: add `offsetTop` and `offsetBottom`
        const minOffset = Math.min(offsetLeft, offsetRight)

        if (minOffset > threshold) return 'universe'
        if (minOffset === offsetLeft) return 'left'
        if (minOffset === offsetRight) return 'right'
        if (minOffset === offsetTop) return 'top'
        if (minOffset === offsetBottom) return 'bottom'
      })
    },
    [split],
  )

  return (
    <div
      className={clsx('relative', className)}
      // https://developer.mozilla.org/en-US/docs/Web/API/File/Using_files_from_web_applications#selecting_files_using_drag_and_drop
      onDragEnter={(e) => {
        console.log('drag enter', e.dataTransfer.types)
        if (dragover) return

        setDragEvent(e)
        e.stopPropagation()
        e.preventDefault()
      }}
    >
      {children}

      {dragover && (
        <div
          className={clsx(
            'bg-outline/20 absolute z-10 transition',
            position === 'left' && 'inset-y-0 right-1/2 left-0',
            position === 'right' && 'inset-y-0 right-0 left-1/2',
            position === 'top' && 'inset-x-0 top-0 bottom-1/2',
            position === 'bottom' && 'inset-x-0 top-1/2 bottom-0',
            position === 'universe' && 'inset-0',
          )}
        ></div>
      )}
      {dragover && (
        <div
          className="absolute inset-0 z-10"
          onDragOver={handleDragover}
          onDragLeave={(e) => {
            console.log('drag leave', e.target)
            setDragEvent()
          }}
          onDrop={(e) => {
            console.log('drop', e)
            setDragEvent()
            e.stopPropagation()
            e.preventDefault()
            onDrop?.(e, position)
          }}
        ></div>
      )}
    </div>
  )
}

const DndContext = createContext<{
  dragover: boolean
  setDragEvent: (e?: DragEvent) => void
}>({ dragover: false, setDragEvent: () => {} })
const DndProvider: React.FC = ({ children }) => {
  const [dragover, setDragover] = useState(false)

  const setDragEvent = useCallback((e?: DragEvent) => {
    setDragover(accept(e))
  }, [])

  return (
    <DndContext.Provider value={{ dragover, setDragEvent }}>
      {children}
    </DndContext.Provider>
  )
}

export function useDndContext() {
  return useContext(DndContext)
}

</code>

apps\reader\src\components\base\GridView.tsx:
<code>
interface GridViewProps {}
export const GridView: React.FC<GridViewProps> = () => {
  return <div></div>
}

</code>

apps\reader\src\components\base\index.ts:
<code>
export * from './ActionBar'
export * from './ContextView'
export * from './DropZone'
export * from './GridView'
export * from './PaneView'
export * from './SplitView'

</code>

apps\reader\src\components\base\PaneView.tsx:
<code>
import clsx from 'clsx'
import { ComponentProps, forwardRef, useState } from 'react'

import { scale } from '@flow/reader/platform'

import { Twisty } from '../Row'
import { Action, ActionBar } from '../base'

import { SplitView, useSplitViewItem } from './SplitView'

interface PaneProps extends ComponentProps<'div'> {
  headline: string
  preferredSize?: number
  actions?: Action[]
}
export const Pane = forwardRef<HTMLDivElement, PaneProps>(function Pane(
  { className, headline, preferredSize, children, actions, ...props },
  ref,
) {
  const [expanded, setExpanded] = useState(true)
  const { size } = useSplitViewItem(headline, {
    preferredSize,
    visible: expanded,
  })
  return (
    <div
      className={clsx('Pane scroll-parent group', size && 'shrink-0')}
      style={{
        height: expanded ? size : 24,
      }}
    >
      <div
        role="button"
        className="flex h-6 shrink-0 items-center"
        onClick={() => setExpanded((e) => !e)}
      >
        <Twisty expanded={expanded} />
        <div
          className="typescale-label-small text-on-surface-variant !font-bold"
          style={{ fontSize: scale(11, 12) }}
        >
          {headline.toUpperCase()}
        </div>
        {actions && (
          <ActionBar
            actions={actions}
            className="invisible ml-auto flex pr-1 group-hover:visible"
          />
        )}
      </div>
      <div
        ref={ref}
        className={clsx(
          'scroll typescale-body-small text-on-surface-variant',
          !expanded && 'hidden',
          className,
        )}
        {...props}
      >
        {children}
      </div>
    </div>
  )
})

export interface PaneViewProps extends ComponentProps<'div'> {
  name: string
  title: string
  actions?: Action[]
}
export function PaneView({
  className,
  name,
  title,
  actions,
  ...props
}: PaneViewProps) {
  return (
    <>
      <div
        className={clsx(
          'flex items-center justify-between px-5 py-2.5',
          className,
        )}
      >
        <h2
          title={title}
          className="text-on-surface"
          style={{ fontSize: scale(11, 12) }}
        >
          {name?.toUpperCase()}
        </h2>
        {actions && <ActionBar actions={actions} className="-mr-1" />}
      </div>
      <SplitView
        vertical
        className={clsx('scroll-parent', className)}
        {...props}
      />
    </>
  )
}

</code>

apps\reader\src\components\base\SplitView.tsx:
<code>
import { Overlay } from '@literal-ui/core'
import { Maybe } from '@literal-ui/hooks'
import clsx from 'clsx'
import {
  Children,
  ComponentProps,
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useState,
} from 'react'

import { useMobile } from '@flow/reader/hooks'
import { clamp } from '@flow/reader/utils'

interface ISplitViewItem {
  key: string
  visible?: boolean
  resize?: (size: number) => void
}
interface SplitViewContext {
  registerView(key: string, view: ISplitViewItem): void
}
const SplitViewContext = createContext<Partial<SplitViewContext>>({})
SplitViewContext.displayName = 'SplitViewContext'

function useSplitView() {
  return useContext(SplitViewContext)
}

function useRegisterView(key: string, view: ISplitViewItem) {
  const { registerView } = useSplitView()

  useEffect(() => {
    registerView?.(key, view)
  }, [key, registerView, view])
}

function useSize(
  preferredSize?: number,
  minSize = 0,
  maxSize = Number.POSITIVE_INFINITY,
) {
  const [size, setSize] = useState(preferredSize)
  const resize = useCallback(
    (delta: number) => {
      setSize((size) => size && clamp(size + delta, minSize, maxSize))
    },
    [maxSize, minSize],
  )
  return [size, resize] as const
}

export function useSplitViewItem(
  key: React.FC | string,
  {
    preferredSize,
    minSize = 0,
    maxSize = Number.POSITIVE_INFINITY,
    visible = true,
  }: {
    preferredSize?: number
    minSize?: number
    maxSize?: number
    visible?: boolean
  } = {},
) {
  const [size, _resize] = useSize(preferredSize, minSize, maxSize)
  const resize = minSize === maxSize ? undefined : _resize
  const stringKey = typeof key === 'string' ? key : key.name
  const view = useMemo(
    () => ({
      key: stringKey,
      resize,
      visible,
    }),
    [stringKey, resize, visible],
  )
  useRegisterView(stringKey, view)

  return { size }
}

interface SplitViewProps extends ComponentProps<'div'> {
  vertical?: boolean
}

export const SplitView = ({
  children,
  className,
  vertical = false,
}: SplitViewProps) => {
  const [viewMap, setViewMap] = useState(new Map<string, ISplitViewItem>())
  const views = [...viewMap.values()]

  const registerView = useCallback((key: string, view: ISplitViewItem) => {
    setViewMap((map) => {
      map.set(key, view)
      return new Map(map)
    })
  }, [])

  const childList = Children.toArray(children)
  if (!childList.length) return null

  return (
    <div className={clsx('SplitView relative h-full', className)}>
      <SplitViewContext.Provider value={{ registerView }}>
        <div
          className={clsx(
            'SplitViewContainer flex h-full',
            vertical && 'flex-col',
          )}
        >
          {childList.reduce((a, c, i) => (
            <>
              {a}
              <Sash vertical={vertical} views={[views[i - 1], views[i]]} />
              {c}
            </>
          ))}
        </div>
      </SplitViewContext.Provider>
    </div>
  )
}

const SASH_SIZE = 4
interface SashProps {
  vertical: boolean
  views: Maybe<ISplitViewItem>[]
}
const Sash: React.FC<SashProps> = ({ vertical, views }) => {
  const [hover, setHover] = useState(false)
  const [active, setActive] = useState(false)
  const mobile = useMobile()

  const enabled = views.every((v) => v?.visible && v?.resize)

  return (
    <div
      className={clsx(
        'sash relative z-30 shrink-0',
        (mobile || !enabled) && 'pointer-events-none',
        vertical ? 'cursor-ns-resize' : 'cursor-ew-resize',
      )}
      style={{
        [vertical ? 'height' : 'width']: SASH_SIZE,
        [vertical ? 'marginBlock' : 'marginInline']: -SASH_SIZE / 2,
      }}
      onMouseEnter={() => {
        setHover(true)
      }}
      onMouseLeave={() => {
        setHover(false)
      }}
      onMouseDown={() => {
        setActive(true)

        function handleMouseMove(e: MouseEvent) {
          const delta = vertical ? e.movementY : e.movementX
          views.forEach((v, i) => {
            v?.resize?.(delta * (-1) ** i)
          })
        }

        window.addEventListener('mousemove', handleMouseMove)
        window.addEventListener('mouseup', function handleMouseUp() {
          // `mouseleave` not fire when `mousedown`
          setHover(false)
          setActive(false)
          window.removeEventListener('mousemove', handleMouseMove)
          window.removeEventListener('mouseup', handleMouseUp)
        })
      }}
    >
      <div
        className={clsx(
          'pointer-events-none absolute inset-0 border-black/10 transition-[background-color]',
          vertical
            ? 'top-1/2 -translate-y-1/2 border-b'
            : 'left-1/2 -translate-x-1/2 border-r',
          (hover || active) && 'bg-primary70 h-full w-full border-none',
        )}
      ></div>
      {active && <Overlay className="!bg-transparent" />}
    </div>
  )
}

</code>

apps\reader\src\components\pages\index.ts:
<code>
export * from './settings'

</code>

apps\reader\src\components\pages\settings.tsx:
<code>
import { useEventListener } from '@literal-ui/hooks'
import Dexie from 'dexie'
import { useRouter } from 'next/router'
import { parseCookies, destroyCookie } from 'nookies'

import {
  ColorScheme,
  useColorScheme,
  useForceRender,
  useTranslation,
} from '@flow/reader/hooks'
import { dbx, mapToToken, OAUTH_SUCCESS_MESSAGE } from '@flow/reader/sync'

import { Button } from '../Button'
import { Select } from '../Form'
import { Page } from '../Page'

export const Settings: React.FC = () => {
  const { scheme, setScheme } = useColorScheme()
  const { asPath, push, locale } = useRouter()
  const t = useTranslation('settings')

  return (
    <Page headline={t('title')}>
      <div className="space-y-6">
        <Item title={t('language')}>
          <Select
            value={locale}
            onChange={(e) => {
              push(asPath, undefined, { locale: e.target.value })
            }}
          >
            <option value="en-US">English</option>
            <option value="zh-CN">简体中文</option>
            <option value="ja-JP">日本語</option>
          </Select>
        </Item>
        <Item title={t('color_scheme')}>
          <Select
            value={scheme}
            onChange={(e) => {
              setScheme(e.target.value as ColorScheme)
            }}
          >
            <option value="system">{t('color_scheme.system')}</option>
            <option value="light">{t('color_scheme.light')}</option>
            <option value="dark">{t('color_scheme.dark')}</option>
          </Select>
        </Item>
        <Synchronization />
        <Item title={t('cache')}>
          <Button
            variant="secondary"
            onClick={() => {
              window.localStorage.clear()
              Dexie.getDatabaseNames().then((names) => {
                names.forEach((n) => Dexie.delete(n))
              })
            }}
          >
            {t('cache.clear')}
          </Button>
        </Item>
      </div>
    </Page>
  )
}

const Synchronization: React.FC = () => {
  const cookies = parseCookies()
  const refreshToken = cookies[mapToToken['dropbox']]
  const render = useForceRender()
  const t = useTranslation('settings.synchronization')

  useEventListener('message', (e) => {
    if (e.data === OAUTH_SUCCESS_MESSAGE) {
      // init app (generate access token, fetch remote data, etc.)
      window.location.reload()
    }
  })

  return (
    <Item title={t('title')}>
      <Select>
        <option value="dropbox">Dropbox</option>
      </Select>
      <div className="mt-2">
        {refreshToken ? (
          <Button
            variant="secondary"
            onClick={() => {
              destroyCookie(null, mapToToken['dropbox'])
              render()
            }}
          >
            {t('unauthorize')}
          </Button>
        ) : (
          <Button
            onClick={() => {
              const redirectUri =
                window.location.origin + '/api/callback/dropbox'

              dbx.auth
                .getAuthenticationUrl(
                  redirectUri,
                  JSON.stringify({ redirectUri }),
                  'code',
                  'offline',
                )
                .then((url) => {
                  window.open(url as string, '_blank')
                })
            }}
          >
            {t('authorize')}
          </Button>
        )}
      </div>
    </Item>
  )
}

interface PartProps {
  title: string
}
const Item: React.FC<PartProps> = ({ title, children }) => {
  return (
    <div>
      <h3 className="typescale-title-small text-on-surface-variant">{title}</h3>
      <div className="mt-2">{children}</div>
    </div>
  )
}

Settings.displayName = 'settings'

</code>

apps\reader\src\components\viewlets\AnnotationView.tsx:
<code>
import { useBoolean } from '@literal-ui/hooks'
import React, { Fragment } from 'react'
import { useMemo } from 'react'
import { VscCopy } from 'react-icons/vsc'

import { Annotation } from '@flow/reader/annotation'
import { useTranslation } from '@flow/reader/hooks'
import { reader, useReaderSnapshot } from '@flow/reader/models'
import { copy, group, keys } from '@flow/reader/utils'

import { Row } from '../Row'
import { PaneViewProps, PaneView, Pane } from '../base'

export const AnnotationView: React.FC<PaneViewProps> = (props) => {
  return (
    <PaneView {...props}>
      <DefinitionPane />
      <AnnotationPane />
    </PaneView>
  )
}

const DefinitionPane: React.FC = () => {
  const { focusedBookTab } = useReaderSnapshot()
  const t = useTranslation('annotation')

  return (
    <Pane headline={t('definitions')} preferredSize={120}>
      {focusedBookTab?.book.definitions.map((d) => {
        return (
          <Row
            key={d}
            onDelete={() => {
              reader.focusedBookTab?.undefine(d)
            }}
          >
            {d}
          </Row>
        )
      })}
    </Pane>
  )
}

const AnnotationPane: React.FC = () => {
  const { focusedBookTab } = useReaderSnapshot()
  const t = useTranslation('annotation')

  const annotations = useMemo(
    () => (focusedBookTab?.book.annotations as Annotation[]) ?? [],
    [focusedBookTab?.book.annotations],
  )

  const groupedAnnotation = useMemo(() => {
    return group(annotations ?? [], (a) => a.spine.index)
  }, [annotations])

  const exportAnnotations = () => {
    // process annotations to be under each section
    // group annotations by title
    const grouped = group(annotations, (a) => a.spine.title)
    const exported: Record<string, any[]> = {}
    for (const chapter in grouped) {
      const annotations =
        grouped[chapter]?.map((a) => {
          const annotation: Record<string, any> = {}
          if (a.notes !== undefined) annotation.notes = a.notes
          if (a.text !== undefined) annotation.text = a.text
          return annotation
        }) ?? []
      exported[chapter] = annotations
    }

    // Copy to clipboard as markdown
    const exportedAnnotationsMd = Object.entries(exported)
      .map(([chapter, annotations]) => {
        return `## ${chapter}\n${annotations
          .map((a) => `- ${a.text} ${a.notes ? `(${a.notes})` : ''}`)
          .join('\n')}`
      })
      .join('\n\n')
    copy(exportedAnnotationsMd)
  }

  return (
    <Pane
      headline={t('annotations')}
      actions={
        annotations.length > 0
          ? [
              {
                id: 'copy-all',
                title: t('copy_as_markdown'),
                Icon: VscCopy,
                handle() {
                  exportAnnotations()
                },
              },
            ]
          : undefined
      }
    >
      {keys(groupedAnnotation).map((k) => (
        <AnnotationBlock key={k} annotations={groupedAnnotation[k]!} />
      ))}
    </Pane>
  )
}

interface AnnotationBlockProps {
  annotations: Annotation[]
}
const AnnotationBlock: React.FC<AnnotationBlockProps> = ({ annotations }) => {
  const [expanded, toggle] = useBoolean(true)

  return (
    <div>
      <Row
        depth={1}
        badge
        expanded={expanded}
        toggle={toggle}
        subitems={annotations}
      >
        {annotations[0]?.spine.title}
      </Row>

      {expanded && (
        <div>
          {annotations.map((a) => (
            <Fragment key={a.id}>
              <Row
                depth={2}
                onClick={() => {
                  reader.focusedBookTab?.display(a.cfi)
                }}
                onDelete={() => {
                  reader.focusedBookTab?.removeAnnotation(a.cfi)
                }}
              >
                {a.text}
              </Row>
              {a.notes && (
                <Row
                  depth={3}
                  onClick={() => {
                    reader.focusedBookTab?.display(a.cfi)
                  }}
                >
                  <span className="text-outline">{a.notes}</span>
                </Row>
              )}
            </Fragment>
          ))}
        </div>
      )}
    </div>
  )
}

</code>

apps\reader\src\components\viewlets\ImageView.tsx:
<code>
import { useBoolean } from '@literal-ui/hooks'

import { ISection, reader, useReaderSnapshot } from '@flow/reader/models'

import { Row } from '../Row'
import { PaneView, PaneViewProps } from '../base'

export const ImageView: React.FC<PaneViewProps> = (props) => {
  const { focusedBookTab } = useReaderSnapshot()
  const sections = focusedBookTab?.sections?.filter((s) => s.images.length) as
    | ISection[]
    | undefined

  if ((sections?.length ?? 0) > 500) return null

  return (
    <PaneView {...props}>
      <div className="scroll">
        {sections?.map((s) => (
          <Block key={s.href} section={s} />
        ))}
      </div>
    </PaneView>
  )
}

interface BlockProps {
  section: ISection
}
const Block: React.FC<BlockProps> = ({ section }) => {
  const { focusedBookTab } = useReaderSnapshot()
  const [expanded, toggle] = useBoolean(false)

  const resources = focusedBookTab?.epub?.resources
  if (!resources) return null

  const blobs = resources.replacementUrls
  const assets = resources.assets

  return (
    <div>
      <Row badge expanded={expanded} toggle={toggle} subitems={section.images}>
        {section.navitem?.label}
      </Row>

      {expanded && (
        <div>
          {section.images.map((src) => {
            const i = assets.findIndex((a: any) => src.includes(a.href))
            const asset = assets[i]
            const blob = blobs[i]

            if (!blob) return null
            return (
              <img
                className="w-full cursor-pointer px-5 py-2"
                key={i}
                src={blob}
                alt={asset.href}
                onClick={() => {
                  reader.focusedBookTab?.displayFromSelector(
                    `img[src*="${asset.href}"]`,
                    section,
                  )
                }}
              />
            )
          })}
        </div>
      )}
    </div>
  )
}

</code>

apps\reader\src\components\viewlets\SearchView.tsx:
<code>
import { useState, useEffect, useMemo } from 'react'
import Highlighter from 'react-highlight-words'
import { VscCollapseAll, VscExpandAll } from 'react-icons/vsc'

import { useAction, useList, useTranslation } from '@flow/reader/hooks'
import {
  flatTree,
  IMatch,
  useReaderSnapshot,
  reader,
} from '@flow/reader/models'

import { TextField } from '../Form'
import { Row } from '../Row'
import { PaneViewProps, PaneView } from '../base'

// When inputting with IME and storing state in `valtio`,
// unexpected rendering with `e.target.value === ''` occurs,
// which leads to `<input>` and IME flash to empty,
// while this will not happen when using `React.useState`,
// so we should create an intermediate `keyword` state to fix this.
function useIntermediateKeyword() {
  const [keyword, setKeyword] = useState('')
  const { focusedBookTab } = useReaderSnapshot()

  useEffect(() => {
    setKeyword(focusedBookTab?.keyword ?? '')
  }, [focusedBookTab?.keyword])

  useEffect(() => {
    reader.focusedBookTab?.setKeyword(keyword)
  }, [keyword])

  return [keyword, setKeyword] as const
}

export const SearchView: React.FC<PaneViewProps> = (props) => {
  const [action] = useAction()
  const { focusedBookTab } = useReaderSnapshot()
  const t = useTranslation()

  const [keyword, setKeyword] = useIntermediateKeyword()

  const results = focusedBookTab?.results
  const expanded = results?.some((r) => r.expanded)

  return (
    <PaneView
      actions={[
        {
          id: expanded ? 'collapse-all' : 'expand-all',
          title: t(expanded ? 'action.collapse_all' : 'action.expand_all'),
          Icon: expanded ? VscCollapseAll : VscExpandAll,
          handle() {
            reader.focusedBookTab?.results?.forEach(
              (r) => (r.expanded = !expanded),
            )
          },
        },
      ]}
      {...props}
    >
      <div className="scroll-parent">
        <div className="px-5 py-px">
          <TextField
            as="input"
            name="keyword"
            autoFocus={action === 'search'}
            hideLabel
            value={keyword}
            placeholder={t('search.title')}
            onChange={(e) => setKeyword(e.target.value)}
            onClear={() => setKeyword('')}
          />
        </div>
        {keyword && results && (
          <ResultList results={results as IMatch[]} keyword={keyword} />
        )}
      </div>
    </PaneView>
  )
}

interface ResultListProps {
  results: IMatch[]
  keyword: string
}
const ResultList: React.FC<ResultListProps> = ({ results, keyword }) => {
  const rows = useMemo(
    () => results.flatMap((r) => flatTree(r)) ?? [],
    [results],
  )
  const { outerRef, innerRef, items } = useList(rows)
  const t = useTranslation('search')

  const sectionCount = results.length
  const resultCount = results.reduce((a, r) => r.subitems!.length + a, 0)

  return (
    <>
      <div className="typescale-body-small text-outline px-5  py-2">
        {t('files.result')
          .replace('{n}', '' + resultCount)
          .replace('{m}', '' + sectionCount)}
      </div>
      <div ref={outerRef} className="scroll">
        <div ref={innerRef}>
          {items.map(({ index }) => (
            <ResultRow key={index} result={rows[index]} keyword={keyword} />
          ))}
        </div>
      </div>
    </>
  )
}

interface ResultRowProps {
  result?: IMatch
  keyword: string
}
const ResultRow: React.FC<ResultRowProps> = ({ result, keyword }) => {
  if (!result) return null
  const { cfi, depth, expanded, subitems, id } = result
  let { excerpt, description } = result
  const tab = reader.focusedBookTab
  const isResult = depth === 1

  excerpt = excerpt.trim()
  description = description?.trim()

  return (
    <Row
      title={description ? `${description} / ${excerpt}` : excerpt}
      label={excerpt}
      description={description}
      depth={depth}
      active={tab?.activeResultID === id}
      expanded={expanded}
      subitems={subitems}
      badge={isResult}
      {...(!isResult && {
        onClick: () => {
          if (tab) {
            tab.activeResultID = id
            tab.display(cfi)
          }
        },
      })}
      toggle={() => tab?.toggleResult(id)}
    >
      {!isResult && (
        <Highlighter
          highlightClassName="match-highlight"
          searchWords={[keyword]}
          textToHighlight={excerpt}
          autoEscape
        />
      )}
    </Row>
  )
}

</code>

apps\reader\src\components\viewlets\ThemeView.tsx:
<code>
import clsx from 'clsx'
import { ComponentProps } from 'react'

import { range } from '@flow/internal'
import {
  useBackground,
  useColorScheme,
  useSourceColor,
  useTranslation,
} from '@flow/reader/hooks'

import { ColorPicker, Label } from '../Form'
import { PaneViewProps, PaneView, Pane } from '../base'

export const ThemeView: React.FC<PaneViewProps> = (props) => {
  const { setScheme } = useColorScheme()
  const { sourceColor, setSourceColor } = useSourceColor()
  const [, setBackground] = useBackground()
  const t = useTranslation('theme')

  return (
    <PaneView {...props}>
      <Pane headline={t('title')} className="space-y-3 px-5 pt-2 pb-4">
        <div>
          <ColorPicker
            name={t('source_color')}
            defaultValue={sourceColor}
            onChange={(e) => {
              setSourceColor(e.target.value)
            }}
          />
        </div>
        <div>
          <Label name={t('background_color')}></Label>
          <div className="flex gap-2">
            {range(7)
              .filter((i) => !(i % 2))
              .map((i) => i - 1)
              .map((i) => (
                <Background
                  key={i}
                  className={i > 0 ? `bg-surface${i}` : 'bg-white'}
                  onClick={() => {
                    setScheme('light')
                    setBackground(i)
                  }}
                />
              ))}
            <Background
              className="bg-black"
              onClick={() => {
                setScheme('dark')
              }}
            />
          </div>
        </div>
      </Pane>
    </PaneView>
  )
}

interface BackgroundProps extends ComponentProps<'div'> {}
const Background: React.FC<BackgroundProps> = ({ className, ...props }) => {
  return (
    <div
      className={clsx('border-outline-variant light h-6 w-6 border', className)}
      {...props}
    ></div>
  )
}

</code>

apps\reader\src\components\viewlets\TimelineView.tsx:
<code>
import dayjs from 'dayjs'
import relativeTime from 'dayjs/plugin/relativeTime'

import { useList, useTranslation } from '@flow/reader/hooks'
import { reader, useReaderSnapshot } from '@flow/reader/models'

import { Row } from '../Row'
import { PaneViewProps, PaneView, Pane } from '../base'

dayjs.extend(relativeTime)
export const TimelineView: React.FC<PaneViewProps> = (props) => {
  const { focusedBookTab } = useReaderSnapshot()
  const rows = focusedBookTab?.timeline
  const { outerRef, innerRef, items } = useList(rows)
  const t = useTranslation('timeline')

  return (
    <PaneView {...props}>
      <Pane headline={t('title')} ref={outerRef}>
        {rows && (
          <div ref={innerRef}>
            {items.map(({ index }) => {
              const row = rows[index]
              if (!row) return null

              const { location, timestamp } = row
              const { cfi, href, displayed } = location.start
              return (
                <Row
                  key={timestamp}
                  description={displayed.page}
                  info={dayjs(timestamp).format('HH:mm')}
                  title={focusedBookTab.mapSectionToNavItem(href)?.label}
                  onClick={() => {
                    reader.focusedBookTab?.display(cfi)
                  }}
                />
              )
            })}
          </div>
        )}
      </Pane>
    </PaneView>
  )
}

</code>

apps\reader\src\components\viewlets\TocView.tsx:
<code>
import { StateLayer } from '@literal-ui/core'
import { useMemo } from 'react'
import { VscCollapseAll, VscExpandAll } from 'react-icons/vsc'

import {
  useLibrary,
  useList,
  useMobile,
  useTranslation,
} from '@flow/reader/hooks'
import {
  compareHref,
  dfs,
  flatTree,
  INavItem,
  reader,
  useReaderSnapshot,
} from '@flow/reader/models'

import { Row } from '../Row'
import { PaneViewProps, PaneView, Pane } from '../base'

export const TocView: React.FC<PaneViewProps> = (props) => {
  const mobile = useMobile()
  return (
    <PaneView {...props}>
      {mobile || <LibraryPane />}
      <TocPane />
    </PaneView>
  )
}

const LibraryPane: React.FC = () => {
  const books = useLibrary()
  const t = useTranslation('toc')
  return (
    <Pane headline={t('library')} preferredSize={240}>
      {books?.map((book) => (
        <button
          key={book.id}
          className="relative w-full truncate py-1 pl-5 pr-3 text-left"
          title={book.name}
          draggable
          onClick={() => reader.addTab(book)}
          onDragStart={(e) => {
            e.dataTransfer.setData('text/plain', book.id)
          }}
        >
          <StateLayer />
          {book.name}
        </button>
      ))}
    </Pane>
  )
}

const TocPane: React.FC = () => {
  const t = useTranslation()
  const { focusedBookTab } = useReaderSnapshot()
  const toc = focusedBookTab?.nav?.toc as INavItem[] | undefined
  const rows = useMemo(() => toc?.flatMap((i) => flatTree(i)), [toc])
  const expanded = toc?.some((r) => r.expanded)
  const currentNavItem = focusedBookTab?.currentNavItem

  const { outerRef, innerRef, items, scrollToItem } = useList(rows)

  return (
    <Pane
      headline={t('toc.title')}
      ref={outerRef}
      actions={[
        {
          id: expanded ? 'collapse-all' : 'expand-all',
          title: t(expanded ? 'action.collapse_all' : 'action.expand_all'),
          Icon: expanded ? VscCollapseAll : VscExpandAll,
          handle() {
            reader.focusedBookTab?.nav?.toc?.forEach((r) =>
              dfs(r as INavItem, (i) => (i.expanded = !expanded)),
            )
          },
        },
      ]}
    >
      {rows && (
        <div ref={innerRef}>
          {items.map(({ index }) => (
            <TocRow
              key={index}
              currentNavItem={currentNavItem as INavItem}
              item={rows[index]}
              onActivate={() => scrollToItem(index)}
            />
          ))}
        </div>
      )}
    </Pane>
  )
}

interface TocRowProps {
  currentNavItem?: INavItem
  item?: INavItem
  onActivate: () => void
}
const TocRow: React.FC<TocRowProps> = ({
  currentNavItem,
  item,
  onActivate,
}) => {
  if (!item) return null
  const { label, subitems, depth, expanded, id, href } = item
  const tab = reader.focusedBookTab

  return (
    <Row
      title={label.trim()}
      depth={depth}
      active={href === currentNavItem?.href}
      expanded={expanded}
      subitems={subitems}
      onClick={() => {
        const [, id] = href.split('#')
        const section = tab?.sections?.find((s) => compareHref(s.href, href))

        if (!section) return

        if (id) {
          tab?.displayFromSelector(`#${id}`, section, false)
        } else {
          tab?.display(section.href, false)
        }
      }}
      // `tab` can not be proxy here
      toggle={() => tab?.toggle(id)}
      onActivate={onActivate}
    />
  )
}

</code>

apps\reader\src\components\viewlets\TypographyView.tsx:
<code>
import clsx from 'clsx'
import { useCallback, useRef, useState } from 'react'
import { MdAdd, MdRemove } from 'react-icons/md'

import { RenditionSpread } from '@flow/epubjs/types/rendition'
import { useTranslation } from '@flow/reader/hooks'
import { reader, useReaderSnapshot } from '@flow/reader/models'
import {
  defaultSettings,
  TypographyConfiguration,
  useSettings,
} from '@flow/reader/state'
import { keys } from '@flow/reader/utils'

import { Select, TextField, TextFieldProps } from '../Form'
import { PaneViewProps, PaneView, Pane } from '../base'

// Define an interface for the Font object

enum TypographyScope {
  Book,
  Global,
}

export const TypographyView: React.FC<PaneViewProps> = (props) => {
  const { focusedBookTab } = useReaderSnapshot()
  const [settings, setSettings] = useSettings()
  const [scope, setScope] = useState(TypographyScope.Book)
  const t = useTranslation('typography')

  const [localFonts, setLocalFonts] = useState<string[]>()

  const { fontFamily, fontSize, fontWeight, lineHeight, zoom, spread } =
    scope === TypographyScope.Book
      ? focusedBookTab?.book.configuration?.typography ?? defaultSettings
      : settings

  const setTypography = useCallback(
    <K extends keyof TypographyConfiguration>(
      k: K,
      v: TypographyConfiguration[K],
    ) => {
      if (scope === TypographyScope.Book) {
        reader.focusedBookTab?.updateBook({
          configuration: {
            ...reader.focusedBookTab.book.configuration,
            typography: {
              ...reader.focusedBookTab.book.configuration?.typography,
              [k]: v,
            },
          },
        })
      } else {
        setSettings((prev) => ({
          ...prev,
          [k]: v,
        }))
      }
    },
    [scope, setSettings],
  )

  const queryLocalFonts = useCallback(async () => {
    if (localFonts) return
    if (!('queryLocalFonts' in window)) {
      console.error('queryLocalFonts is not available')
      return
    }

    try {
      const fonts = await window.queryLocalFonts()
      const uniqueFonts = Array.from(new Set(fonts.map((f) => f.family)))
      setLocalFonts(uniqueFonts)
    } catch (error) {
      console.error('Error querying local fonts:', error)
    }
  }, [localFonts])

  return (
    <PaneView {...props}>
      <div className="typescale-body-medium flex gap-2 px-5 pb-2 !text-[13px]">
        {keys(TypographyScope)
          .filter((k) => isNaN(Number(k)))
          .map((scopeName) => (
            <button
              key={scopeName}
              className={clsx(
                TypographyScope[scopeName] === scope
                  ? 'text-on-surface-variant'
                  : 'text-outline/60',
              )}
              onClick={() => setScope(TypographyScope[scopeName])}
            >
              {t(`scope.${scopeName.toLowerCase()}`)}
            </button>
          ))}
      </div>
      <Pane
        headline={t('title')}
        className="space-y-3 px-5 pt-2 pb-4"
        key={`${scope}${focusedBookTab?.id}`}
      >
        <Select
          name={t('page_view')}
          value={spread ?? RenditionSpread.Auto}
          onChange={(e) => {
            setTypography('spread', e.target.value as RenditionSpread)
          }}
        >
          <option value={RenditionSpread.None}>
            {t('page_view.single_page')}
          </option>
          <option value={RenditionSpread.Auto}>
            {t('page_view.double_page')}
          </option>
        </Select>
        <TextField
          as="input"
          name={t('font_family')}
          value={fontFamily}
          placeholder="default"
          // Tips: Datalist only appears on mouse click or keyboard input.
          // Does not show when focused via Tab/focus() or triggered by click()
          datalist={localFonts?.map((font) => (
            <option key={font} value={font}>
              {font}
            </option>
          ))}
          onFocus={queryLocalFonts}
          // Preload fonts to ensure `localFonts` is available on first mouse click.
          // Without preloading, datalist dropdown will be empty for the first mouse click.
          onMouseEnter={queryLocalFonts}
          onChange={(e) => {
            setTypography('fontFamily', e.target.value)
          }}
        />
        <NumberField
          name={t('font_size')}
          min={14}
          max={28}
          defaultValue={fontSize && parseInt(fontSize)}
          onChange={(v) => {
            setTypography('fontSize', v ? v + 'px' : undefined)
          }}
        />
        <NumberField
          name={t('font_weight')}
          min={100}
          max={900}
          step={100}
          defaultValue={fontWeight}
          onChange={(v) => {
            setTypography('fontWeight', v || undefined)
          }}
        />
        <NumberField
          name={t('line_height')}
          min={1}
          step={0.1}
          defaultValue={lineHeight}
          onChange={(v) => {
            setTypography('lineHeight', v || undefined)
          }}
        />
        <NumberField
          name={t('zoom')}
          min={1}
          step={0.1}
          defaultValue={zoom}
          onChange={(v) => {
            setTypography('zoom', v || undefined)
          }}
        />
      </Pane>
    </PaneView>
  )
}

interface NumberFieldProps extends Omit<TextFieldProps<'input'>, 'onChange'> {
  onChange: (v?: number) => void
}
const NumberField: React.FC<NumberFieldProps> = ({ onChange, ...props }) => {
  const ref = useRef<HTMLInputElement>(null)
  const t = useTranslation('action')

  return (
    <TextField
      as="input"
      type="number"
      placeholder="default"
      actions={[
        {
          title: t('step_down'),
          Icon: MdRemove,
          onClick: () => {
            if (!ref.current) return
            ref.current.stepDown()
            onChange(Number(ref.current.value))
          },
        },
        {
          title: t('step_up'),
          Icon: MdAdd,
          onClick: () => {
            if (!ref.current) return
            ref.current.stepUp()
            onChange(Number(ref.current.value))
          },
        },
      ]}
      mRef={ref}
      // lazy render
      onBlur={(e) => {
        onChange(Number(e.target.value))
      }}
      onClear={() => {
        if (ref.current) ref.current.value = ''
        onChange(undefined)
      }}
      {...props}
    />
  )
}

</code>

apps\reader\src\hooks\index.ts:
<code>
export * from './remote'
export * from './theme'
export * from './useAction'
export * from './useAsync'
export * from './useDisablePinchZooming'
export * from './useEnv'
export * from './useForceRender'
export * from './useLibrary'
export * from './useList'
export * from './useMobile'
export * from './useTextSelection'
export * from './useTranslation'
export * from './useTypography'

</code>

apps\reader\src\hooks\useAction.ts:
<code>
import { atom, useRecoilState, useSetRecoilState } from 'recoil'

export type Action =
  | 'toc'
  | 'search'
  | 'annotation'
  | 'typography'
  | 'image'
  | 'timeline'
  | 'theme'
export const actionState = atom<Action | undefined>({
  key: 'action',
  default: undefined,
})

export function useSetAction() {
  return useSetRecoilState(actionState)
}

export function useAction() {
  return useRecoilState(actionState)
}

</code>

apps\reader\src\hooks\useAsync.ts:
<code>
import { useEffect, useRef, useState } from 'react'

export function useAsync<T>(
  func: () => Promise<T> | undefined | null,
  deps = [],
) {
  const ref = useRef(func)
  ref.current = func
  const [value, setValue] = useState<T>()

  useEffect(() => {
    ref.current()?.then(setValue)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps)

  return value
}

</code>

apps\reader\src\hooks\useDisablePinchZooming.ts:
<code>
import { useEffect } from 'react'

// https://github.com/excalidraw/excalidraw/blob/7eaf47c9d41a33a6230d8c3a16b5087fc720dcfb/src/packages/excalidraw/index.tsx#L66
export function useDisablePinchZooming(win?: Window) {
  useEffect(() => {
    const _win = win ?? window
    // Block pinch-zooming on iOS outside of the content area
    const handleTouchMove = (event: TouchEvent) => {
      event.preventDefault()
    }

    _win.document.addEventListener('touchmove', handleTouchMove, {
      passive: false,
    })

    return () => {
      _win.document.removeEventListener('touchmove', handleTouchMove)
    }
  }, [win])
}

</code>

apps\reader\src\hooks\useEnv.ts:
<code>
import { useMobile } from './useMobile'

export enum Env {
  Desktop = 1,
  Mobile = 1 << 1,
}

export function useEnv() {
  const mobile = useMobile()
  return mobile ? Env.Mobile : Env.Desktop
}

</code>

apps\reader\src\hooks\useForceRender.ts:
<code>
import { useState, useCallback } from 'react'

export function useForceRender() {
  const [, render] = useState({})

  return useCallback(() => {
    render({})
  }, [])
}

</code>

apps\reader\src\hooks\useLibrary.ts:
<code>
import { useLiveQuery } from 'dexie-react-hooks'

import { db } from '../db'

export function useLibrary() {
  return useLiveQuery(() => db?.books.toArray() ?? [])
}

</code>

apps\reader\src\hooks\useList.ts:
<code>
import useVirtual from 'react-cool-virtual'

import { scale } from '../platform'

export const LIST_ITEM_SIZE = scale(24, 32)
export function useList(array: Readonly<any[]> = []) {
  return useVirtual<HTMLDivElement>({
    itemCount: array.length,
    itemSize: LIST_ITEM_SIZE,
  })
}

</code>

apps\reader\src\hooks\useMobile.ts:
<code>
import { useEffect } from 'react'
import { atom, useRecoilState } from 'recoil'

export const mobileState = atom<boolean | undefined>({
  key: 'mobile',
  default: undefined,
})

let listened = false

export function useMobile() {
  const [mobile, setMobile] = useRecoilState(mobileState)

  useEffect(() => {
    if (listened) return
    listened = true

    const mq = window.matchMedia('(max-width: 640px)')
    setMobile(mq.matches)
    mq.addEventListener('change', (e) => {
      setMobile(e.matches)
    })
  }, [setMobile])

  return mobile
}

</code>

apps\reader\src\hooks\useTextSelection.ts:
<code>
// https://github.com/juliankrispel/use-text-selection

import { useEventListener } from '@literal-ui/hooks'
import { useState } from 'react'

import { isTouchScreen } from '../platform'

import { useForceRender } from './useForceRender'

export function hasSelection(
  selection?: Selection | null,
): selection is Selection {
  return !(!selection || selection.isCollapsed)
}

// https://htmldom.dev/get-the-direction-of-the-text-selection/
export function isForwardSelection(selection: Selection) {
  if (selection.anchorNode && selection.focusNode) {
    const range = document.createRange()
    range.setStart(selection.anchorNode, selection.anchorOffset)
    range.setEnd(selection.focusNode, selection.focusOffset)

    return !range.collapsed
  }

  return true
}

export function useTextSelection(win?: Window) {
  const [selection, setSelection] = useState<Selection | undefined>()
  const render = useForceRender()

  // On touch screen device, mouse/touch/pointer events not working when selection is created.
  useEventListener(
    isTouchScreen ? win?.document : win,
    isTouchScreen ? 'selectionchange' : 'mouseup',
    () => {
      const s = win?.getSelection()

      if (hasSelection(s)) {
        // sometime `getSelection` will return the same `selection`
        // when select text by clicking empty space
        render()
        setSelection(s)
      }
    },
  )

  // https://stackoverflow.com/questions/3413683/disabling-the-context-menu-on-long-taps-on-android
  useEventListener(win, 'contextmenu', (e) => {
    if (isTouchScreen) {
      e.preventDefault()
    }
  })

  return [selection, setSelection] as const
}

</code>

apps\reader\src\hooks\useTranslation.ts:
<code>
import { useRouter } from 'next/router'
import { useCallback } from 'react'

import locales from '../../locales'

export function useTranslation(scope?: string) {
  const { locale } = useRouter()

  return useCallback(
    (key: string) => {
      // @ts-ignore
      return locales[locale][scope ? `${scope}.${key}` : key] as string
    },
    [locale, scope],
  )
}

</code>

apps\reader\src\hooks\useTypography.ts:
<code>
import { useMemo } from 'react'
import { useSnapshot } from 'valtio'

import { BookTab } from '../models'
import { useSettings } from '../state'

function removeUndefinedProperty<T extends Record<string, any>>(obj: T) {
  const newObj: Partial<T> = {}

  Object.entries(obj).forEach(([k, v]) => {
    if (v !== undefined) {
      newObj[k as keyof T] = v
    }
  })

  return newObj
}

export function useTypography(tab: BookTab) {
  const { book } = useSnapshot(tab)
  const [settings] = useSettings()

  return useMemo(
    () => ({
      ...settings,
      ...removeUndefinedProperty(book.configuration?.typography ?? {}),
    }),
    [book.configuration?.typography, settings],
  )
}

</code>

apps\reader\src\hooks\remote\index.ts:
<code>
export * from './useRemote'
export * from './useSync'

</code>

apps\reader\src\hooks\remote\useRemote.ts:
<code>
import useSWR from 'swr/immutable'

import {
  DATA_FILENAME,
  dropboxBooksFetcher,
  dropboxFilesFetcher,
} from '@flow/reader/sync'

export function useRemoteFiles() {
  return useSWR('/files', dropboxFilesFetcher, { shouldRetryOnError: false })
}

export function useRemoteBooks() {
  return useSWR(`/${DATA_FILENAME}`, dropboxBooksFetcher, {
    shouldRetryOnError: false,
  })
}

</code>

apps\reader\src\hooks\remote\useSync.ts:
<code>
import { useCallback, useEffect } from 'react'
import { useSnapshot } from 'valtio'

import { Annotation } from '@flow/reader/annotation'
import { BookRecord } from '@flow/reader/db'
import { BookTab } from '@flow/reader/models'
import { uploadData } from '@flow/reader/sync'

import { useRemoteBooks } from './useRemote'

export function useSync(tab: BookTab) {
  const { mutate } = useRemoteBooks()
  const { location, book } = useSnapshot(tab)

  const id = tab.book.id

  const sync = useCallback(
    async (changes: Partial<BookRecord>) => {
      // to remove effect dependency `remoteBooks`
      mutate(
        (remoteBooks) => {
          if (remoteBooks) {
            const i = remoteBooks.findIndex((b) => b.id === id)
            if (i < 0) return remoteBooks

            remoteBooks[i] = {
              ...remoteBooks[i]!,
              ...changes,
            }

            uploadData(remoteBooks)

            return [...remoteBooks]
          }
        },
        { revalidate: false },
      )
    },
    [id, mutate],
  )

  useEffect(() => {
    sync({
      cfi: location?.start.cfi,
      percentage: book.percentage,
    })
  }, [sync, book.percentage, location?.start.cfi])

  useEffect(() => {
    sync({
      definitions: book.definitions as string[],
    })
  }, [book.definitions, sync])

  useEffect(() => {
    sync({
      annotations: book.annotations as Annotation[],
    })
  }, [book.annotations, sync])

  useEffect(() => {
    sync({
      configuration: book.configuration,
    })
  }, [book.configuration, sync])
}

</code>

apps\reader\src\hooks\theme\index.ts:
<code>
export * from './useBackground'
export * from './useColorScheme'
export * from './useSourceColor'
export * from './useTheme'

</code>

apps\reader\src\hooks\theme\useBackground.ts:
<code>
import { useCallback, useEffect, useMemo } from 'react'

import { compositeColors } from '@flow/reader/color'
import { useSettings } from '@flow/reader/state'

import { useColorScheme } from './useColorScheme'
import { useTheme } from './useTheme'

export function useBackground() {
  const [{ theme }, setSettings] = useSettings()
  const { dark } = useColorScheme()
  const rawTheme = useTheme()

  const setBackground = useCallback(
    (background: number) => {
      setSettings((prev) => ({
        ...prev,
        theme: {
          ...prev.theme,
          background,
        },
      }))
    },
    [setSettings],
  )

  // [-1, 1, 3, 5]
  const level = theme?.background ?? -1

  const background = useMemo(() => {
    if (dark) return 'bg-default'

    if (level > 0) return `bg-surface${level}`

    return 'bg-default'
  }, [dark, level])

  useEffect(() => {
    if (dark === undefined) return
    if (rawTheme === undefined) return

    const surfaceMap: Record<number, number> = {
      1: 0.05,
      2: 0.08,
      3: 0.11,
      4: 0.12,
      5: 0.14,
    }

    const { surface, primary } = rawTheme.schemes.light

    const color = dark
      ? '#24292e'
      : level < 0
      ? '#fff'
      : compositeColors(surface, primary, surfaceMap[level]!)

    document.querySelector('#theme-color')?.setAttribute('content', color)
  }, [dark, level, rawTheme])

  return [background, setBackground] as const
}

</code>

apps\reader\src\hooks\theme\useColorScheme.ts:
<code>
import { useMediaQuery } from '@literal-ui/hooks'
import { useEffect } from 'react'
import useLocalStorageState from 'use-local-storage-state'

export type ColorScheme = 'light' | 'dark' | 'system'

export function useColorScheme() {
  const [scheme, setScheme] = useLocalStorageState<ColorScheme>(
    'literal-color-scheme',
    { defaultValue: 'system' },
  )

  const prefersDark = useMediaQuery('(prefers-color-scheme: dark)')
  const dark = scheme === 'dark' || (scheme === 'system' && prefersDark)

  useEffect(() => {
    if (dark !== undefined) {
      document.documentElement.classList.toggle('dark', dark)
    }
  }, [dark])

  return { scheme, dark, setScheme }
}

</code>

apps\reader\src\hooks\theme\useSourceColor.ts:
<code>
import { useCallback } from 'react'

import { useSettings } from '@flow/reader/state'

export function useSourceColor() {
  const [{ theme }, setSettings] = useSettings()

  const setSourceColor = useCallback(
    (source: string) => {
      setSettings((prev) => ({
        ...prev,
        theme: {
          ...prev.theme,
          source,
        },
      }))
    },
    [setSettings],
  )

  return { sourceColor: theme?.source ?? '#0ea5e9', setSourceColor }
}

</code>

apps\reader\src\hooks\theme\useTheme.ts:
<code>
import { Theme } from '@material/material-color-utilities'
import { atom, useRecoilValue, useSetRecoilState } from 'recoil'

const themeState = atom<Theme | undefined>({
  key: 'theme',
  default: undefined,
})

export function useTheme() {
  return useRecoilValue(themeState)
}

export function useSetTheme() {
  return useSetRecoilState(themeState)
}

</code>

apps\reader\src\models\index.ts:
<code>
export * from './reader'
export * from './tree'

</code>

apps\reader\src\models\reader.ts:
<code>
import { debounce } from '@github/mini-throttle/decorators'
import { IS_SERVER } from '@literal-ui/hooks'
import React from 'react'
import { v4 as uuidv4 } from 'uuid'
import { proxy, ref, snapshot, subscribe, useSnapshot } from 'valtio'

import type { Rendition, Location, Book } from '@flow/epubjs'
import Navigation, { NavItem } from '@flow/epubjs/types/navigation'
import Section from '@flow/epubjs/types/section'

import { AnnotationColor, AnnotationType } from '../annotation'
import { BookRecord, db } from '../db'
import { fileToEpub } from '../file'
import { defaultStyle } from '../styles'

import { dfs, find, INode } from './tree'

function updateIndex(array: any[], deletedItemIndex: number) {
  const last = array.length - 1
  return deletedItemIndex > last ? last : deletedItemIndex
}

export function compareHref(
  sectionHref: string | undefined,
  navitemHref: string | undefined,
) {
  if (sectionHref && navitemHref) {
    const [target] = navitemHref.split('#')

    return (
      sectionHref.endsWith(target!) ||
      // fix for relative nav path `../Text/example.html`
      target?.endsWith(sectionHref)
    )
  }
}

function compareDefinition(d1: string, d2: string) {
  return d1.toLowerCase() === d2.toLowerCase()
}

export interface INavItem extends NavItem, INode {
  subitems?: INavItem[]
}

export interface IMatch extends INode {
  excerpt: string
  description?: string
  cfi?: string
  subitems?: IMatch[]
}

export interface ISection extends Section {
  length: number
  images: string[]
  navitem?: INavItem
}

interface TimelineItem {
  location: Location
  timestamp: number
}

class BaseTab {
  constructor(public readonly id: string, public readonly title = id) {}

  get isBook(): boolean {
    return this instanceof BookTab
  }

  get isPage(): boolean {
    return this instanceof PageTab
  }
}

// https://github.com/pmndrs/valtio/blob/92f3311f7f1a9fe2a22096cd30f9174b860488ed/src/vanilla.ts#L6
type AsRef = { $$valtioRef: true }

export class BookTab extends BaseTab {
  epub?: Book
  iframe?: Window & AsRef
  rendition?: Rendition & { manager?: any }
  nav?: Navigation
  locationToReturn?: Location
  section?: ISection
  sections?: ISection[]
  results?: IMatch[]
  activeResultID?: string
  rendered = false

  get container() {
    return this?.rendition?.manager?.container as HTMLDivElement | undefined
  }

  timeline: TimelineItem[] = []
  get location() {
    return this.timeline[0]?.location
  }

  display(target?: string, returnable = true) {
    this.rendition?.display(target)
    if (returnable) this.showPrevLocation()
  }
  displayFromSelector(selector: string, section: ISection, returnable = true) {
    try {
      const el = section.document.querySelector(selector)
      if (el) this.display(section.cfiFromElement(el), returnable)
    } catch (err) {
      this.display(section.href, returnable)
    }
  }
  prev() {
    this.rendition?.prev()
    // avoid content flash
    if (this.container?.scrollLeft === 0 && !this.location?.atStart) {
      this.rendered = false
    }
  }
  next() {
    this.rendition?.next()
  }

  updateBook(changes: Partial<BookRecord>) {
    changes = {
      ...changes,
      updatedAt: Date.now(),
    }
    // don't wait promise resolve to make valtio batch updates
    this.book = { ...this.book, ...changes }
    db?.books.update(this.book.id, changes)
  }

  annotationRange?: Range
  setAnnotationRange(cfi: string) {
    const range = this.view?.contents.range(cfi)
    if (range) this.annotationRange = ref(range)
  }

  define(def: string[]) {
    this.updateBook({ definitions: [...this.book.definitions, ...def] })
  }
  undefine(def: string) {
    this.updateBook({
      definitions: this.book.definitions.filter(
        (d) => !compareDefinition(d, def),
      ),
    })
  }
  isDefined(def: string) {
    return this.book.definitions.some((d) => compareDefinition(d, def))
  }

  rangeToCfi(range: Range) {
    return this.view.contents.cfiFromRange(range)
  }
  putAnnotation(
    type: AnnotationType,
    cfi: string,
    color: AnnotationColor,
    text: string,
    notes?: string,
  ) {
    const spine = this.section
    if (!spine?.navitem) return

    const i = this.book.annotations.findIndex((a) => a.cfi === cfi)
    let annotation = this.book.annotations[i]

    const now = Date.now()
    if (!annotation) {
      annotation = {
        id: uuidv4(),
        bookId: this.book.id,
        cfi,
        spine: {
          index: spine.index,
          title: spine.navitem.label,
        },
        createAt: now,
        updatedAt: now,
        type,
        color,
        notes,
        text,
      }

      this.updateBook({
        // DataCloneError: Failed to execute 'put' on 'IDBObjectStore': #<Object> could not be cloned.
        annotations: [...snapshot(this.book.annotations), annotation],
      })
    } else {
      annotation = {
        ...this.book.annotations[i]!,
        type,
        updatedAt: now,
        color,
        notes,
        text,
      }
      this.book.annotations.splice(i, 1, annotation)
      this.updateBook({
        annotations: [...snapshot(this.book.annotations)],
      })
    }
  }
  removeAnnotation(cfi: string) {
    return this.updateBook({
      annotations: snapshot(this.book.annotations).filter((a) => a.cfi !== cfi),
    })
  }

  keyword = ''
  setKeyword(keyword: string) {
    if (this.keyword === keyword) return
    this.keyword = keyword
    this.onKeywordChange()
  }

  // only use throttle/debounce for side effects
  @debounce(1000)
  async onKeywordChange() {
    this.results = await this.search()
  }

  get totalLength() {
    return this.sections?.reduce((acc, s) => acc + s.length, 0) ?? 0
  }

  toggle(id: string) {
    const item = find(this.nav?.toc, id) as INavItem
    if (item) item.expanded = !item.expanded
  }

  toggleResult(id: string) {
    const item = find(this.results, id)
    if (item) item.expanded = !item.expanded
  }

  showPrevLocation() {
    this.locationToReturn = this.location
  }

  hidePrevLocation() {
    this.locationToReturn = undefined
  }

  mapSectionToNavItem(sectionHref: string) {
    let navItem: NavItem | undefined
    this.nav?.toc.forEach((item) =>
      dfs(item as NavItem, (i) => {
        if (compareHref(sectionHref, i.href)) navItem ??= i
      }),
    )
    return navItem
  }

  get currentHref() {
    return this.location?.start.href
  }

  get currentNavItem() {
    return this.section?.navitem
  }

  get view() {
    return this.rendition?.manager?.views._views[0]
  }

  getNavPath(navItem = this.currentNavItem) {
    const path: INavItem[] = []

    if (this.nav) {
      while (navItem) {
        path.unshift(navItem)
        const parentId = navItem.parent
        if (!parentId) {
          navItem = undefined
        } else {
          const index = this.nav.tocById[parentId]!
          navItem = this.nav.getByIndex(parentId, index, this.nav.toc)
        }
      }
    }

    return path
  }

  searchInSection(keyword = this.keyword, section = this.section) {
    if (!section) return

    const subitems = section.find(keyword) as unknown as IMatch[]
    if (!subitems.length) return

    const navItem = section.navitem
    if (navItem) {
      const path = this.getNavPath(navItem)
      path.pop()
      return {
        id: navItem.href,
        excerpt: navItem.label,
        description: path.map((i) => i.label).join(' / '),
        subitems: subitems.map((i) => ({ ...i, id: i.cfi! })),
        expanded: true,
      }
    }
  }

  search(keyword = this.keyword) {
    // avoid blocking input
    return new Promise<IMatch[] | undefined>((resolve) => {
      requestIdleCallback(() => {
        if (!keyword) {
          resolve(undefined)
          return
        }

        const results: IMatch[] = []

        this.sections?.forEach((s) => {
          const result = this.searchInSection(keyword, s)
          if (result) results.push(result)
        })

        resolve(results)
      })
    })
  }

  private _el?: HTMLDivElement
  onRender?: () => void
  async render(el: HTMLDivElement) {
    if (el === this._el) return
    this._el = ref(el)

    const file = await db?.files.get(this.book.id)
    if (!file) return

    this.epub = ref(await fileToEpub(file.file))

    this.epub.loaded.navigation.then((nav) => {
      this.nav = nav
    })
    console.log(this.epub)
    this.epub.loaded.spine.then((spine: any) => {
      const sections = spine.spineItems as ISection[]
      // https://github.com/futurepress/epub.js/issues/887#issuecomment-700736486
      const promises = sections.map((s) =>
        s.load(this.epub?.load.bind(this.epub)),
      )

      Promise.all(promises).then(() => {
        sections.forEach((s) => {
          s.length = s.document.body.textContent?.length ?? 0
          s.images = [...s.document.querySelectorAll('img')].map((el) => el.src)
          this.epub!.loaded.navigation.then(() => {
            s.navitem = this.mapSectionToNavItem(s.href)
          })
        })
        this.sections = ref(sections)
      })
    })
    this.rendition = ref(
      this.epub.renderTo(el, {
        width: '100%',
        height: '100%',
        allowScriptedContent: true,
      }),
    )
    console.log(this.rendition)
    this.rendition.display(
      this.location?.start.cfi ?? this.book.cfi ?? undefined,
    )
    this.rendition.themes.default(defaultStyle)
    this.rendition.hooks.render.register((view: any) => {
      console.log('hooks.render', view)
      this.onRender?.()
    })

    this.rendition.on('relocated', (loc: Location) => {
      console.log('relocated', loc)
      this.rendered = true
      this.timeline.unshift({
        location: loc,
        timestamp: Date.now(),
      })

      // calculate percentage
      if (this.sections) {
        const start = loc.start
        const i = this.sections.findIndex((s) => s.href === start.href)
        const previousSectionsLength = this.sections
          .slice(0, i)
          .reduce((acc, s) => acc + s.length, 0)
        const previousSectionsPercentage =
          previousSectionsLength / this.totalLength
        const currentSectionPercentage =
          this.sections[i]!.length / this.totalLength
        const displayedPercentage = start.displayed.page / start.displayed.total

        const percentage =
          previousSectionsPercentage +
          currentSectionPercentage * displayedPercentage

        this.updateBook({ cfi: start.cfi, percentage })
      }
    })

    this.rendition.on('attached', (...args: any[]) => {
      console.log('attached', args)
    })
    this.rendition.on('started', (...args: any[]) => {
      console.log('started', args)
    })
    this.rendition.on('displayed', (...args: any[]) => {
      console.log('displayed', args)
    })
    this.rendition.on('rendered', (section: ISection, view: any) => {
      console.log('rendered', [section, view])
      this.section = ref(section)
      this.iframe = ref(view.window as Window)
    })
    this.rendition.on('selected', (...args: any[]) => {
      console.log('selected', args)
    })
    this.rendition.on('removed', (...args: any[]) => {
      console.log('removed', args)
    })
  }

  constructor(public book: BookRecord) {
    super(book.id, book.name)

    // don't subscribe `db.books` in `constructor`, it will
    // 1. update the unproxied instance, which is not reactive
    // 2. update unnecessary state (e.g. percentage) of all tabs with the same book
  }
}

class PageTab extends BaseTab {
  constructor(public readonly Component: React.FC<any>) {
    super(Component.displayName ?? 'untitled')
  }
}

type Tab = BookTab | PageTab
type TabParam = ConstructorParameters<typeof BookTab | typeof PageTab>[0]

export class Group {
  id = uuidv4()
  tabs: Tab[] = []

  constructor(
    tabs: Array<Tab | TabParam> = [],
    public selectedIndex = tabs.length - 1,
  ) {
    this.tabs = tabs.map((t) => {
      if (t instanceof BookTab || t instanceof PageTab) return t
      const isPage = typeof t === 'function'
      return isPage ? new PageTab(t) : new BookTab(t)
    })
  }

  get selectedTab() {
    return this.tabs[this.selectedIndex]
  }

  get bookTabs() {
    return this.tabs.filter((t) => t instanceof BookTab) as BookTab[]
  }

  removeTab(index: number) {
    const tab = this.tabs.splice(index, 1)
    this.selectedIndex = updateIndex(this.tabs, index)
    return tab[0]
  }

  addTab(param: TabParam | Tab) {
    const isTab = param instanceof BookTab || param instanceof PageTab
    const isPage = typeof param === 'function'

    const id = isTab ? param.id : isPage ? param.displayName : param.id

    const index = this.tabs.findIndex((t) => t.id === id)
    if (index > -1) {
      this.selectTab(index)
      return this.tabs[index]
    }

    const tab = isTab ? param : isPage ? new PageTab(param) : new BookTab(param)

    this.tabs.splice(++this.selectedIndex, 0, tab)
    return tab
  }

  replaceTab(param: TabParam, index = this.selectedIndex) {
    this.addTab(param)
    this.removeTab(index)
  }

  selectTab(index: number) {
    this.selectedIndex = index
  }
}

export class Reader {
  groups: Group[] = []
  focusedIndex = -1

  get focusedGroup() {
    return this.groups[this.focusedIndex]
  }

  get focusedTab() {
    return this.focusedGroup?.selectedTab
  }

  get focusedBookTab() {
    return this.focusedTab instanceof BookTab ? this.focusedTab : undefined
  }

  addTab(param: TabParam | Tab, groupIdx = this.focusedIndex) {
    let group = this.groups[groupIdx]
    if (group) {
      this.focusedIndex = groupIdx
    } else {
      group = this.addGroup([])
    }
    return group.addTab(param)
  }

  removeTab(index: number, groupIdx = this.focusedIndex) {
    const group = this.groups[groupIdx]
    if (group?.tabs.length === 1) {
      this.removeGroup(groupIdx)
      return group.tabs[0]
    }
    return group?.removeTab(index)
  }

  replaceTab(
    param: TabParam,
    index = this.focusedIndex,
    groupIdx = this.focusedIndex,
  ) {
    const group = this.groups[groupIdx]
    group?.replaceTab(param, index)
  }

  removeGroup(index: number) {
    this.groups.splice(index, 1)
    this.focusedIndex = updateIndex(this.groups, index)
  }

  addGroup(tabs: Array<Tab | TabParam>, index = this.focusedIndex + 1) {
    const group = proxy(new Group(tabs))
    this.groups.splice(index, 0, group)
    this.focusedIndex = index
    return group
  }

  selectGroup(index: number) {
    this.focusedIndex = index
  }

  clear() {
    this.groups = []
    this.focusedIndex = -1
  }

  resize() {
    this.groups.forEach(({ bookTabs }) => {
      bookTabs.forEach(({ rendition }) => {
        try {
          rendition?.resize()
        } catch (error) {
          console.error(error)
        }
      })
    })
  }
}

export const reader = proxy(new Reader())

subscribe(reader, () => {
  console.log(snapshot(reader))
})

export function useReaderSnapshot() {
  return useSnapshot(reader)
}

declare global {
  interface Window {
    reader: Reader
  }
}

if (!IS_SERVER) {
  window.reader = reader
}

</code>

apps\reader\src\models\tree.ts:
<code>
export interface INode {
  id: string
  depth?: number
  expanded?: boolean
  subitems?: INode[]
}

export function flatTree<T extends INode>(node: T, depth = 1): T[] {
  if (!node.subitems || !node.subitems.length || !node.expanded) {
    return [{ ...node, depth }]
  }
  const children = node.subitems.flatMap((i) => flatTree(i, depth + 1)) as T[]
  return [{ ...node, depth }, ...children]
}

export function find<T extends INode>(
  nodes: T[] = [],
  id: string,
): T | undefined {
  const node = nodes.find((n) => n.id === id)
  if (node) return node
  for (const child of nodes) {
    const node = find(child.subitems, id)
    if (node) return node as T
  }
  return undefined
}

export function dfs<T extends INode>(node: T, fn: (node: T) => void) {
  fn(node)
  node.subitems?.forEach((child) => dfs(child as T, fn))
}

</code>

apps\reader\src\pages\index.tsx:
<code>
import ePub from 'epubjs'
import { useEffect, useState } from 'react'

type Book = {
  title: string
  file: string
}

export default function Reader() {
  const [books, setBooks] = useState<Book[]>([])

  useEffect(() => {
    fetch('/api/books')
      .then((res) => res.json())
      .then((data) => setBooks(data))
  }, [])

  useEffect(() => {
    books.forEach((book, index) => {
      const epub = ePub(book.file)
      const rendition = epub.renderTo(`viewer-${index}`, {
        width: '100%',
        height: '500px',
      })
      rendition.display()
    })
  }, [books])

  return (
    <div style={{ padding: '2rem' }}>
      <h1 style={{ marginBottom: '2rem' }}>📚 Available Books</h1>
      {books.map((book, index) => (
        <div key={book.file} style={{ marginBottom: '3rem' }}>
          <h2>{book.title}</h2>
          <div
            id={`viewer-${index}`}
            style={{ border: '1px solid #ccc', height: '500px' }}
          />
        </div>
      ))}
    </div>
  )
}

</code>

apps\reader\src\pages\success.tsx:
<code>
import { useState, useEffect } from 'react'

import { OAUTH_SUCCESS_MESSAGE } from '../sync'

export default function Success() {
  const [countdown, setCountdown] = useState(3)

  useEffect(() => {
    // https://developer.mozilla.org/en-US/docs/Web/API/Window/opener
    const opener: Window | null = window.opener
    opener?.postMessage(OAUTH_SUCCESS_MESSAGE)

    const id = setInterval(() => {
      setCountdown((cd) => {
        if (cd > 1) return cd - 1

        clearInterval(id)
        window.close()
        return cd
      })
    }, 1000)
  }, [])

  return (
    <div className="flex h-full items-center justify-center text-center">
      <div>
        <h1 className="typescale-headline-large text-green-600">
          Oauth success
        </h1>
        <p className="typescale-body-large text-on-surface-variant">
          This window will close in {countdown}s.
        </p>
      </div>
    </div>
  )
}

</code>

apps\reader\src\pages\_.tsx:
<code>
import Index from './index'

export default Index

</code>

apps\reader\src\pages\_app.tsx:
<code>
import '../styles.css'
import 'react-photo-view/dist/react-photo-view.css'

import { LiteralProvider } from '@literal-ui/core'
import { ErrorBoundary } from '@sentry/nextjs'
import type { AppProps } from 'next/app'
import { useRouter } from 'next/router'
import { RecoilRoot } from 'recoil'

import { Layout, Theme } from '../components'

export default function MyApp({ Component, pageProps }: AppProps) {
  const router = useRouter()

  if (router.pathname === '/success') return <Component {...pageProps} />

  return (
    <ErrorBoundary fallback={<Fallback />}>
      <LiteralProvider>
        <RecoilRoot>
          <Theme />
          <Layout>
            <Component {...pageProps} />
          </Layout>
        </RecoilRoot>
      </LiteralProvider>
    </ErrorBoundary>
  )
}

const Fallback: React.FC = () => {
  return <div>Something went wrong.</div>
}

</code>

apps\reader\src\pages\_document.tsx:
<code>
import { Html, Head, Main, NextScript } from 'next/document'

export default function Document() {
  return (
    // https://github.com/vercel/next.js/issues/10285
    // Next injects `<style data-next-hide-fouc="true">body{display:none}</style>`,
    // so we should set background on `html`
    <Html className="bg-default">
      <Head>
        <GoogleTagManager />
        <link rel="icon" href="/icons/192.png"></link>
        <PWA />
        <PreventFlash />
      </Head>
      <body>
        <GoogleTagManagerNoScript />
        <Main />
        <NextScript />
      </body>
    </Html>
  )
}

function PWA() {
  return (
    <>
      <link rel="manifest" href="/manifest.json" />
      <meta id="theme-color" name="theme-color" content={background.light} />
      <link rel="apple-touch-icon" href="/icons/192.png" />
    </>
  )
}

const GTM_ID = process.env.NEXT_PUBLIC_GTM_ID

function GoogleTagManager() {
  if (!GTM_ID) return null
  return (
    // eslint-disable-next-line @next/next/next-script-for-ga
    <script
      dangerouslySetInnerHTML={{
        __html: `
          (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer', '${GTM_ID}');
          `,
      }}
    />
  )
}

function GoogleTagManagerNoScript() {
  if (!GTM_ID) return null
  return (
    <noscript>
      <iframe
        src={`https://www.googletagmanager.com/ns.html?id=${GTM_ID}`}
        height="0"
        width="0"
        style={{ display: 'none', visibility: 'hidden' }}
      ></iframe>
    </noscript>
  )
}

const background = {
  light: 'white',
  dark: '#24292e',
}

// external import in `_document.tsx` will break fast refresh,
// so move it to `_document.tsx`
function PreventFlash() {
  const setColorScheme = () => {
    const mql = window.matchMedia('(prefers-color-scheme: dark)')
    const scheme = localStorage.getItem('literal-color-scheme') ?? 'system'

    if (scheme === '"dark"' || (scheme === '"system"' && mql.matches)) {
      document.documentElement.classList.toggle('dark', true)
      document
        .querySelector('#theme-color')
        ?.setAttribute('content', background.dark)
    }
  }

  return (
    <>
      <style>{`
        .bg-default, .hover\\:bg-default:hover {
          background: ${background.light};
        }
        .dark.bg-default, .dark .bg-default, .dark .hover\\:bg-default:hover {
          background: ${background.dark};
        }
      `}</style>
      <script
        dangerouslySetInnerHTML={{
          __html: `const background=${JSON.stringify(background)}`,
        }}
      ></script>
      <script
        dangerouslySetInnerHTML={{ __html: `(${setColorScheme})()` }}
      ></script>
    </>
  )
}

</code>

apps\reader\src\pages\_error.js:
<code>
/**
 * NOTE: This requires `@sentry/nextjs` version 7.3.0 or higher.
 *
 * NOTE: If using this with `next` version 12.2.0 or lower, uncomment the
 * penultimate line in `CustomErrorComponent`.
 *
 * This page is loaded by Nextjs:
 *  - on the server, when data-fetching methods throw or reject
 *  - on the client, when `getInitialProps` throws or rejects
 *  - on the client, when a React lifecycle method throws or rejects, and it's
 *    caught by the built-in Nextjs error boundary
 *
 * See:
 *  - https://nextjs.org/docs/basic-features/data-fetching/overview
 *  - https://nextjs.org/docs/api-reference/data-fetching/get-initial-props
 *  - https://reactjs.org/docs/error-boundaries.html
 */

import * as Sentry from '@sentry/nextjs'
import NextErrorComponent from 'next/error'

const CustomErrorComponent = (props) => {
  // If you're using a Nextjs version prior to 12.2.1, uncomment this to
  // compensate for https://github.com/vercel/next.js/issues/8592
  // Sentry.captureUnderscoreErrorException(props);

  return <NextErrorComponent statusCode={props.statusCode} />
}

CustomErrorComponent.getInitialProps = async (contextData) => {
  // In case this is running in a serverless function, await this in order to give Sentry
  // time to send the error before the lambda exits
  await Sentry.captureUnderscoreErrorException(contextData)

  // This will contain the status code of the response
  return NextErrorComponent.getInitialProps(contextData)
}

export default CustomErrorComponent

</code>

apps\reader\src\pages\api\refresh.ts:
<code>
import type { NextApiRequest, NextApiResponse } from 'next'

import { mapToToken } from '@flow/reader/sync'

import { dbx } from './utils'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  const token = req.cookies[mapToToken['dropbox']]
  if (typeof token !== 'string') {
    return res.status(401).end()
  }

  dbx.auth.setRefreshToken(token)
  await dbx.auth.refreshAccessToken()

  res.json({
    accessToken: dbx.auth.getAccessToken(),
    accessTokenExpiresAt: dbx.auth.getAccessTokenExpiresAt(),
  })
}

</code>

apps\reader\src\pages\api\utils.ts:
<code>
import { Dropbox } from 'dropbox'

export const dbx = new Dropbox({
  clientId: process.env.NEXT_PUBLIC_DROPBOX_CLIENT_ID,
  clientSecret: process.env.DROPBOX_CLIENT_SECRET,
})

</code>

apps\reader\src\pages\api\callback\[provider].ts:
<code>
import type { NextApiRequest, NextApiResponse } from 'next'
import nookies from 'nookies'

import { mapToToken } from '@flow/reader/sync'

import { dbx } from '../utils'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  if (
    typeof req.query.state !== 'string' ||
    typeof req.query.code !== 'string'
  ) {
    return res.status(400).end()
  }

  const state = JSON.parse(req.query.state)

  const response = await dbx.auth.getAccessTokenFromCode(
    state.redirectUri,
    req.query.code,
  )
  const result = response.result as any

  nookies.set({ res }, mapToToken['dropbox'], result.refresh_token, {
    maxAge: 365 * 24 * 60 * 60,
    secure: true,
    path: '/',
  })

  // https://stackoverflow.com/questions/4694089/sending-browser-cookies-during-a-302-redirect
  res.redirect(302, '/success')
}

</code>

apps\website\i18n.js:
<code>
const localeMap = {
  'en-US': 'English',
  'zh-CN': '简体中文',
  'ja-JP': '日本語',
}

const locales = Object.keys(localeMap)

module.exports = {
  localeMap,
  locales,
  defaultLocale: locales[0],
  defaultNS: 'common',
  pages: {
    '*': ['common'],
  },
  loadLocaleFrom: (lang) =>
    // You can use a dynamic import, fetch, whatever. You should
    // return a Promise with the JSON file.
    import(`./locales/${lang}.json`).then((m) => m.default),
}

</code>

apps\website\netlify.toml:
<code>
[build.environment]
NODE_VERSION = "16"
# https://github.com/netlify/build/issues/1633#issuecomment-907246600
NPM_FLAGS = "--version" # prevent Netlify npm install

[build]
# Set `base` to repo directory in Netlify UI
# base = 'website'
publish = ".next"
# https://answers.netlify.com/t/using-pnpm-and-pnpm-workspaces/2759
command = "npx pnpm i --store=node_modules/.pnpm-store && npx pnpm -F website... build"

</code>

apps\website\next-env.d.ts:
<code>
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

</code>

apps\website\next.config.js:
<code>
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
})
const nextTranslate = require('next-translate')
const withTM = require('next-transpile-modules')(['@flow/internal'])

/**
 * @type {import('rehype-pretty-code').Options}
 **/
const opts = {
  theme: {
    dark: 'github-dark',
    light: 'github-light',
  },
  onVisitLine(node) {
    // Prevent lines from collapsing in `display: grid` mode, and
    // allow empty lines to be copy/pasted
    if (node.children.length === 0) {
      node.children = [{ type: 'text', value: ' ' }]
    }
  },
  onVisitHighlightedLine(node) {
    node.properties.className.push('highlighted')
  },
  onVisitHighlightedWord(node) {
    node.properties.className = ['word', 'highlighted']
  },
}

/**
 * @type {import('next').NextConfig}
 **/
const config = {
  pageExtensions: ['ts', 'tsx', 'mdx'],
  pwa: {
    dest: 'public',
  },
  webpack: (config, options) => {
    config.module.rules.push({
      test: /.mdx?$/, // load both .md and .mdx files
      use: [
        options.defaultLoaders.babel,
        {
          loader: '@mdx-js/loader',
          options: {
            remarkPlugins: [],
            rehypePlugins: [[require('rehype-pretty-code'), opts]],
            // If you use `MDXProvider`, uncomment the following line.
            providerImportSource: '@mdx-js/react',
          },
        },
        './plugins/mdx',
      ],
    })

    return config
  },
}

module.exports = nextTranslate(withTM(withBundleAnalyzer(config)))

</code>

apps\website\package.json:
<code>
{
  "name": "@flow/website",
  "private": true,
  "scripts": {
    "dev": "next dev -p 7117",
    "build": "next build",
    "analyze": "cross-env ANALYZE=true next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@flow/internal": "workspace:*",
    "@literal-ui/core": "0.0.13",
    "@literal-ui/hooks": "0.0.8",
    "@literal-ui/next": "0.0.3",
    "@mdx-js/loader": "2.1.1",
    "@mdx-js/react": "2.1.1",
    "@next/bundle-analyzer": "12.1.6",
    "babel-loader": "8.2.5",
    "clsx": "1.1.1",
    "gray-matter": "4.0.3",
    "next": "12.1.5",
    "next-seo": "5.4.0",
    "next-translate": "1.6.0",
    "react": "18.0.0",
    "react-dom": "18.0.0",
    "react-icons": "4.3.1",
    "react-use": "17.4.0",
    "rehype-pretty-code": "0.3.0",
    "shiki": "0.10.1"
  },
  "devDependencies": {
    "@literal-ui/plugins": "0.0.3",
    "@tailwindcss/aspect-ratio": "0.4.2",
    "@tailwindcss/line-clamp": "0.4.2",
    "@types/node": "17.0.22",
    "@types/react": "17.0.43",
    "autoprefixer": "10.4.4",
    "m3-tokens": "0.0.3",
    "next-transpile-modules": "9.0.0",
    "postcss": "8.4.12",
    "tailwindcss": "3.2.0",
    "type-fest": "2.12.2"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}

</code>

apps\website\postcss.config.js:
<code>
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

</code>

apps\website\tailwind.config.js:
<code>
/**
 * @type {import('tailwindcss').Config}
 */
module.exports = {
  darkMode: 'class',
  content: ['./src/**/*.{tsx,ts}', './node_modules/@literal-ui/core/**/*.js'],
  theme: {
    extend: {},
    container: {
      center: true,
      padding: '1rem',
      screens: {
        '2xl': '1024px',
      },
    },
  },
  plugins: [
    require('m3-tokens/tailwind')({ source: '#808080' }),
    require('@literal-ui/plugins'),
    require('@tailwindcss/line-clamp'),
  ],
}

</code>

apps\website\tsconfig.json:
<code>
{
  "extends": "../../tsconfig.next.json",
  "compilerOptions": {},
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}

</code>

apps\website\locales\en-US.json:
<code>
{
  "desc": "Flow is a free online EPUB reader, support all platforms (Web, Windows, Linux, MacOS, Android, iOS). Read multiple books at the same time. Read seamlessly between different devices.",
  "page": {
    "home": {
      "title": "Flow - Online EPUB reader"
    },
    "faq": {
      "title": "Frequently asked questions"
    }
  },

  "open_app": "Open App",
  "terms": "Terms",
  "privacy": "Privacy",
  "contact": "Contact",
  "feedback": "Feedback",
  "faq": "FAQ",
  "roadmap": "Roadmap",
  "donate": "Donate",
  "donate_url": "https://ko-fi.com/pacexy",

  "redefine": "Redefine",
  "reader": "reader",
  "description": "Free. Open source. Browser-based.",
  "features": {
    "title": "Features",
    "list": {
      "0": "Search in book",
      "1": "Image preview",
      "2": "Custom typography",
      "3": "Highlight and Annotation",
      "4": "Theme",
      "5": "Share/Download book with link",
      "6": "Data export",
      "7": "Cloud storage"
    }
  },
  "feature": {
    "0": {
      "title": "Progressive web app",
      "desc": "Flow is progressive web app (PWA), which means it is cross-platform and installable."
    },
    "1": {
      "title": "Offline first",
      "desc": "Flow can be run offline (after installation), and when not offline, Flow will update automatically."
    },
    "2": {
      "title": "Grid layout",
      "desc": "Flow supports (horizontal) grid layout, which allows you to read multiple books at the same time."
    },
    "3": {
      "title": "Custom cloud storage",
      "desc": "Store your books, notes, reading progress and even other data in the cloud you specified."
    }
  },

  "frequently_asked_questions": "Frequently asked questions",
  "qa2": {
    "0": {
      "q": "How to install or uninstall Flow?",
      "a": "Google Chrome: <a target='_blank' href='https://support.google.com/chrome/answer/9658361?hl=en'>Use Progressive Web Apps</a><br/>Microsoft Edge: <a target='_blank' href='https://learn.microsoft.com/en-us/microsoft-edge/progressive-web-apps-chromium/ux'>The user experience of PWAs</a><br/>Safari: <a target='_blank' href='https://support.apple.com/en-us/104996'>Use Safari web apps on Mac</a>"
    },
    "1": {
      "q": "How to set Flow as the default ePub reader?",
      "a": "Google Chrome: <a target='_blank' href='https://pacexy.notion.site/How-to-set-Flow-as-the-default-ePub-reader-35e44bd24aef4d63a3c55f054929f064'>How to set Flow as the default ePub reader?</a><br/>"
    },
    "2": {
      "q": "Where are my data stored?",
      "a": "Your data is stored locally in your browser, using <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API'>IndexedDB</a>. If you upload a book, there will be a remote copy in the cloud."
    },
    "3": {
      "q": "How to clear my data?",
      "a": "Local data: clear the browser cache.<br/>Remote data: select and delete the book you want to clear (this will also clear the local one)."
    },
    "4": {
      "q": "What cloud storage do you support?",
      "a": "Only Dropbox for now."
    }
  }
}

</code>

apps\website\locales\ja-JP.json:
<code>
{
  "desc": "Flowは、あらゆるプラットフォーム（Web、Windows、Linux、MacOS、Android、iOS）をサポートする無料のオンラインEPUBリーダーです。複数の書籍を同時に読むことができます。異なるデバイス間でもシームレスに読書できます。",
  "page": {
    "home": {
      "title": "Flow - Online EPUB Reader"
    },
    "faq": {
      "title": "よくある質問"
    }
  },

  "open_app": "アプリを開く",
  "terms": "利用規約",
  "privacy": "プライバシー",
  "contact": "お問い合わせ",
  "feedback": "フィードバック",
  "faq": "よくある質問",
  "roadmap": "ロードマップ",
  "donate": "寄付",
  "donate_url": "https://ko-fi.com/pacexy",

  "redefine": "再定義",
  "reader": "リーダー",
  "description": "無料。オープンソース。ブラウザベース。",
  "features": {
    "title": "特徴",
    "list": {
      "0": "書籍内検索",
      "1": "画像プレビュー",
      "2": "カスタムタイポグラフィ",
      "3": "ハイライトと注釈",
      "4": "テーマ",
      "5": "リンクで書籍を共有/ダウンロード",
      "6": "データエクスポート",
      "7": "クラウドストレージ"
    }
  },
  "feature": {
    "0": {
      "title": "プログレッシブウェブアプリ",
      "desc": "Flowはプログレッシブウェブアプリ（PWA）であり、クロスプラットフォームでインストール可能です。"
    },
    "1": {
      "title": "オフラインファースト",
      "desc": "Flowは（インストール後）オフラインで実行でき、オフラインでない場合は自動的に更新されます。"
    },
    "2": {
      "title": "グリッドレイアウト",
      "desc": "Flowは（水平）グリッドレイアウトをサポートしており、複数の書籍を同時に読むことができます。"
    },
    "3": {
      "title": "カスタムクラウドストレージ",
      "desc": "指定したクラウドに書籍、メモ、読書進捗、その他のデータを保存します。"
    }
  },

  "frequently_asked_questions": "よくある質問",
  "qa2": {
    "0": {
      "q": "Flowをインストールまたはアンインストールする方法は？",
      "a": "Google Chrome: <a target='_blank' href='https://support.google.com/chrome/answer/9658361?hl=en'>プログレッシブ ウェブアプリを使用する</a><br/>Microsoft Edge: <a target='_blank' href='https://learn.microsoft.com/ja-jp/microsoft-edge/progressive-web-apps-chromium/ux'>PWA のユーザー エクスペリエンス</a><br/>Safari: <a target='_blank' href='https://support.apple.com/ja-jp/104996'>Mac で Safari Web App を使う</a>"
    },
    "1": {
      "q": "FlowをデフォルトのePubリーダーとして設定する方法は？",
      "a": "Google Chrome: <a target='_blank' href='https://pacexy.notion.site/How-to-set-Flow-as-the-default-ePub-reader-35e44bd24aef4d63a3c55f054929f064'>FlowをデフォルトのePubリーダーとして設定する方法は？</a><br/>"
    },
    "2": {
      "q": "データはどこに保存されますか？",
      "a": "データはブラウザにローカルに保存され、<a target='_blank' href='https://developer.mozilla.org/ja/docs/Web/API/IndexedDB_API'>IndexedDB</a>を使用します。書籍をアップロードすると、クラウドにリモートコピーが作成されます。"
    },
    "3": {
      "q": "データをクリアする方法は？",
      "a": "ローカルデータ：ブラウザのキャッシュをクリアします。<br/>リモートデータ：クリアする書籍を選択して削除します（これによりローカルの書籍もクリアされます）。"
    },
    "4": {
      "q": "どのクラウドストレージをサポートしていますか？",
      "a": "今のところDropboxのみです。"
    }
  }
}

</code>

apps\website\locales\zh-CN.json:
<code>
{
  "desc": "Flow 是一款免费在线 EPUB 阅读器，支持所有平台（Web, Windows, Linux, MacOS, Android, iOS）。同时阅读多本书籍。在不同设备间无缝阅读。",
  "page": {
    "home": {
      "title": "Flow - 在线 EPUB 阅读器"
    },
    "faq": {
      "title": "常见问题"
    }
  },

  "open_app": "打开 App",
  "terms": "使用条款",
  "privacy": "隐私政策",
  "contact": "联系",
  "feedback": "反馈",
  "faq": "常见问题",
  "roadmap": "开发计划",
  "donate": "捐赠",
  "donate_url": "https://afdian.com/a/pacexy",

  "redefine": "重新定义",
  "reader": "阅读器",
  "description": "免费。开源。基于浏览器。",
  "features": {
    "title": "特性",
    "list": {
      "0": "书内搜索",
      "1": "图片预览",
      "2": "自定义排版",
      "3": "高亮、笔记",
      "4": "主题",
      "5": "通过链接分享、下载书籍",
      "6": "数据导出",
      "7": "云端存储"
    }
  },
  "feature": {
    "0": {
      "title": "渐进式网页应用",
      "desc": "Flow 是渐进式网页应用（PWA），这让它拥有跨平台的能力，并且支持安装。"
    },
    "1": {
      "title": "离线优先",
      "desc": "Flow 可以离线运行（在安装后），而非离线时，Flow 会自动更新。"
    },
    "2": {
      "title": "网格布局",
      "desc": "Flow 支持（水平）网格布局，允许您同时阅读多本书。"
    },
    "3": {
      "title": "自定义云端存储",
      "desc": "存储您的书籍、笔记、阅读进度甚至其他数据在您指定的云端。"
    }
  },

  "frequently_asked_questions": "常见问题",
  "qa2": {
    "0": {
      "q": "如何安装或卸载 Flow？",
      "a": "Google Chrome: <a target='_blank' href='https://support.google.com/chrome/answer/9658361?hl=zh-Hans'>使用渐进式 Web 应用</a><br/>Microsoft Edge: <a target='_blank' href='https://learn.microsoft.com/zh-cn/microsoft-edge/progressive-web-apps-chromium/ux'>PWA 的用户体验</a><br/>Safari: <a target='_blank' href='https://support.apple.com/zh-cn/104996'>在 Mac 上使用 Safari 浏览器网页 App</a>"
    },
    "1": {
      "q": "如何将 Flow 设置为默认 ePub 阅读器?",
      "a": "Google Chrome:  <a target='_blank' href='https://www.bilibili.com/read/cv19698386'>如何将 Flow 设置为默认 ePub 阅读器?</a><br/>"
    },
    "2": {
      "q": "我的数据存储在哪里？",
      "a": "我们使用 <a target='_blank' href='https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API'>IndexedDB</a> 将你的数据存储在浏览器中。如果您上传一本书，在云端会有一个远程拷贝。"
    },
    "3": {
      "q": "如何清除我的数据？",
      "a": "本地数据：清除浏览器缓存。<br/>远程数据：选择并删除您要清除的书籍（这也会清除本地的对应书籍）。"
    },
    "4": {
      "q": "支持什么云端存储？",
      "a": "目前仅支持 Dropbox。"
    }
  }
}

</code>

apps\website\plugins\mdx.js:
<code>
const fm = require('gray-matter')

module.exports = async function (src) {
  const callback = this.async()
  const { content, data } = fm(src)

  const code =
    // based on `baseUrl` in `tsconfig.json`
    `import {withLayout} from 'apps/website/src/components';

export default withLayout(${JSON.stringify(data)})

` + content

  return callback(null, code)
}

</code>

apps\website\src\components\index.ts:
<code>
export * from './Layout'
export * from './MDX'
export * from './Seo'

</code>

apps\website\src\components\Layout.tsx:
<code>
import { Link } from '@literal-ui/next'
import clsx from 'clsx'
import useTranslation from 'next-translate/useTranslation'
import { useRouter } from 'next/router'
import { ComponentProps } from 'react'
import { RiGithubFill } from 'react-icons/ri'

import { localeMap } from '../../i18n'

export const Layout: React.FC = ({ children }) => {
  return (
    <div className="flex min-h-screen flex-col">
      <Header />
      <main className="flex-1">{children}</main>
      <Footer />
    </div>
  )
}

export const OpenApp: React.FC<ComponentProps<'a'>> = ({
  className,
  children,
}) => {
  const { t } = useTranslation()
  return (
    <Link
      href={process.env.NEXT_PUBLIC_APP_URL!}
      className={clsx(
        'typescale-title-medium select-none bg-black px-4 py-3 text-center text-white',
        className,
      )}
    >
      {children ?? t('open_app')}
    </Link>
  )
}

interface QAProps {
  q: string
  a: string
}
export const QA: React.FC<QAProps> = ({ q, a }) => {
  return (
    <div className="typescale-body-large">
      <h2 className="typescale-title-large mb-2">{q}</h2>
      <p className="text-outline" dangerouslySetInnerHTML={{ __html: a }}></p>
    </div>
  )
}

interface NavbarProps extends ComponentProps<'div'> {}
export const Navbar: React.FC<NavbarProps> = ({ className }) => {
  const { t } = useTranslation()
  return (
    <div
      className={clsx(
        'text-outline typescale-body-large items-center gap-4',
        className,
      )}
    >
      <Link href="#faq">{t('faq')}</Link>
      <Link href="https://pacexy.notion.site/283696d0071c43bfb03652e8e5f47936?v=b43f4dd7a3cb4ce785d6c32b698a8ff5">
        {t('roadmap')}
      </Link>
      <Link href={t('donate_url')}>{t('donate')}</Link>
    </div>
  )
}

const Header: React.FC = () => {
  const { asPath, locale, push } = useRouter()

  return (
    <header className="typescale-body-large text-on-surface sticky top-0 border-b bg-white py-3">
      <div className="container flex items-center">
        <Link className="mr-8 flex items-center gap-3" href="/">
          <img src="/icons/512.png" alt="Logo" className="w-7" />
          <span className="typescale-title-large">Flow</span>
        </Link>
        <Navbar className="hidden sm:flex" />

        <div className="text-on-surface-variant ml-auto flex gap-3">
          <Link href="https://github.com/pacexy/flow">
            <RiGithubFill size={22} />
          </Link>
          <select
            className="bg-transparent outline-none"
            value={locale}
            onChange={(e) => {
              push(asPath, asPath, { locale: e.target.value })
            }}
          >
            {Object.entries(localeMap).map(([k, v]) => (
              <option key={k} value={k}>
                {v}
              </option>
            ))}
          </select>
        </div>
      </div>
      <Navbar className="container mt-3 flex justify-end sm:hidden" />
    </header>
  )
}

const Footer: React.FC = () => {
  const { t } = useTranslation()

  return (
    <footer className="bg-black py-4">
      <div className="container">
        <div className="text-inverse-on-surface typescale-body-small mb-4 flex gap-6">
          <Link href="/terms">{t('terms')}</Link>
          <Link href="/privacy">{t('privacy')}</Link>
          <a href="mailto:service@flowoss.com">{t('contact')}</a>
          <Link href="https://github.com/pacexy/flow/issues/new">
            {t('feedback')}
          </Link>
        </div>

        <div className="typescale-body-small text-white">
          © {new Date().getFullYear()} Flow
        </div>
      </div>
    </footer>
  )
}

</code>

apps\website\src\components\MDX.tsx:
<code>
import clsx from 'clsx'
import React, { ComponentProps } from 'react'

import { Seo } from './Seo'

interface HeadingProps extends ComponentProps<'h1'> {
  as?: 'h1' | 'h2' | 'h3'
}
function Heading({ as, ...props }: HeadingProps) {
  const Renderer = as || 'h1'
  return <Renderer {...props} />
}

export function H1({ className, ...props }: HeadingProps) {
  return (
    <Heading
      as="h1"
      className={clsx('typescale-headline-medium mt-6', className)}
      {...props}
    />
  )
}

export function H2({ className, ...props }: HeadingProps) {
  return (
    <Heading
      as="h2"
      className={clsx('typescale-title-large mt-12', className)}
      {...props}
    />
  )
}

type Meta = { title?: string }
export function withLayout({ title }: Meta) {
  return function Layout({ children }) {
    return (
      <>
        <Seo title={title} />
        <article className="container py-16">{children}</article>
      </>
    )
  } as React.FC
}

</code>

apps\website\src\components\Seo.tsx:
<code>
import { NextSeo, NextSeoProps } from 'next-seo'
import useTranslation from 'next-translate/useTranslation'

export interface SeoProps extends Omit<NextSeoProps, 'title'> {
  scope?: string
  title?: string
}

export const Seo: React.FC<SeoProps> = ({
  scope,
  title,
  description,
  ...seoProps
}) => {
  const { t } = useTranslation()
  title = title ?? t(`page.${scope}.title`)

  if (!title) {
    throw new Error('Title is empty')
  }

  return (
    <NextSeo
      title={scope === 'home' ? title : `${title} - Flow`}
      description={description ?? t('desc')}
      {...seoProps}
    />
  )
}

</code>

apps\website\src\pages\index.tsx:
<code>
import useTranslation from 'next-translate/useTranslation'

import { range } from '@flow/internal'

import { OpenApp, QA, Seo } from '../components'

export default function Home() {
  const { t } = useTranslation()

  return (
    <>
      <Seo scope="home" />
      <div>
        <div className="container py-16">
          <div className="flex flex-col items-center">
            <h1 className="typescale-display-large text-center">
              <span className="">{t('redefine')}</span>
              <br />
              <span className="text-on-surface font-light">
                ePub {t('reader')}
              </span>
            </h1>
            <div className="mt-8 mb-4 text-center">
              <div className="text-on-surface-variant/80 typescale-title-large mb-4">
                {t('description')}
              </div>
            </div>
            <OpenApp />
          </div>
          <div className="mt-12">
            <h2 className="typescale-title-large mb-4 text-center">
              {t('features.title')}
            </h2>
            <ul className="typescale-body-large mx-auto w-fit list-disc !text-[16px] sm:columns-2">
              {range(8).map((i) => (
                <li key={i} className="py-0.5">
                  {t(`features.list.${i}`)}
                </li>
              ))}
            </ul>
          </div>
          <img
            src="/screenshots/01.webp"
            alt="Screenshot"
            className="shadow-1 mt-16"
          />
        </div>

        <div className="bg-gray-100 py-16">
          <div className="container">
            {range(4).map((i) => (
              <Feature
                key={i}
                title={t(`feature.${i}.title`)}
                description={t(`feature.${i}.desc`)}
              />
            ))}
          </div>
        </div>

        <div className="container py-16">
          <h2 className="typescale-headline-medium mb-8 text-center" id="faq">
            {t('frequently_asked_questions')}
          </h2>
          <div className="space-y-8">
            {range(5).map((i) => (
              <QA key={i} q={t(`qa2.${i}.q`)} a={t(`qa2.${i}.a`)} />
            ))}
          </div>
        </div>
      </div>
    </>
  )
}

interface FeatureProps {
  title: string
  description: string
}
export const Feature: React.FC<FeatureProps> = ({ title, description }) => {
  return (
    <div className="py-8">
      <h2 className="typescale-headline-medium mb-4">{title}</h2>
      <p className="typescale-title-large text-on-surface-variant/80">
        {description}
      </p>
    </div>
  )
}

</code>

apps\website\src\pages\styles.css:
<code>
@tailwind base;
@tailwind components;
@tailwind utilities;

main a {
  @apply text-blue-500;
}

</code>

apps\website\src\pages\_app.tsx:
<code>
import './styles.css'

import { LiteralProvider } from '@literal-ui/core'
import { MDXProvider } from '@mdx-js/react'
import type { AppProps } from 'next/app'

import { H1, H2, Layout } from '../components'

const components = {
  h1: H1,
  h2: H2,
}

export default function MyApp({ Component, pageProps }: AppProps) {
  return (
    <LiteralProvider>
      <MDXProvider components={components}>
        <Layout>
          <Component {...pageProps} />
        </Layout>
      </MDXProvider>
    </LiteralProvider>
  )
}

</code>

apps\website\src\pages\_document.tsx:
<code>
import { Html, Head, Main, NextScript } from 'next/document'

export default function Document() {
  return (
    <Html>
      <Head>
        <GoogleTagManager />
        <link rel="icon" href="/icons/192.png"></link>
      </Head>
      <body>
        <GoogleTagManagerNoScript />
        <Main />
        <NextScript />
      </body>
    </Html>
  )
}

const GTM_ID = process.env.NEXT_PUBLIC_GTM_ID

function GoogleTagManager() {
  if (!GTM_ID) return null
  return (
    // eslint-disable-next-line @next/next/next-script-for-ga
    <script
      dangerouslySetInnerHTML={{
        __html: `
          (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer', '${GTM_ID}');
          `,
      }}
    />
  )
}

function GoogleTagManagerNoScript() {
  if (!GTM_ID) return null
  return (
    <noscript>
      <iframe
        src={`https://www.googletagmanager.com/ns.html?id=${GTM_ID}`}
        height="0"
        width="0"
        style={{ display: 'none', visibility: 'hidden' }}
      ></iframe>
    </noscript>
  )
}

</code>

packages\epubjs\bower.json:
<code>
{
  "name": "epubjs",
  "version": "0.3.0",
  "authors": ["Fred Chasen <fchasen@gmail.com>"],
  "description": "Enhanced eBooks in the browser.",
  "main": "dist/epub.js",
  "moduleType": ["amd", "globals", "node"],
  "keywords": ["epub"],
  "license": "MIT",
  "homepage": "http://futurepress.org",
  "ignore": [
    "**/.*",
    "node_modules",
    "bower_components",
    "test",
    "tools",
    "books",
    "examples"
  ],
  "dependencies": {
    "event-emitter": "^0.3.5",
    "jszip": "^3.4.0",
    "localforage": "^1.7.3",
    "lodash": "^4.17.15",
    "marks-pane": "^1.0.9",
    "path-webpack": "0.0.3",
    "stream-browserify": "^3.0.0",
    "url-polyfill": "^1.1.9",
    "xmldom": "^0.3.0"
  }
}

</code>

packages\epubjs\documentation.yml:
<code>
toc:
  - ePub
  - name: ePubJS
    description: |
      main entry
  - EpubCFI

</code>

packages\epubjs\karma.conf.js:
<code>
let webpackConfig = require('./webpack.config.js')
webpackConfig.mode = 'development'
webpackConfig.externals = {}
webpackConfig.module.rules.push({
  test: /\.xhtml$/i,
  use: 'raw-loader',
})

module.exports = function (config) {
  config.set({
    // base path that will be used to resolve all patterns (eg. files, exclude)
    basePath: '',

    // frameworks to use
    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter
    frameworks: ['mocha'],

    // list of files / patterns to load in the browser
    files: [
      { pattern: 'src/*.js', watched: true, included: false, served: false },

      { pattern: 'test/*.js', watched: false },

      {
        pattern: 'test/fixtures/**/*',
        watched: false,
        included: false,
        served: true,
      },

      // {pattern: 'node_modules/jszip/dist/jszip.js', watched: false, included: true, served: true},

      // {pattern: 'node_modules/es6-promise/dist/es6-promise.auto.js', watched: false, included: true, served: true},

      // {pattern: 'libs/url/url-polyfill.js', watched: false, included: true, served: true}
    ],

    // list of files to exclude
    exclude: [],

    // preprocess matching files before serving them to the browser
    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor
    preprocessors: {
      // add webpack as preprocessor
      'test/*.js': ['webpack', 'sourcemap'],
      // 'test/**/*.js': ['webpack', 'sourcemap']
    },

    webpack: webpackConfig,

    // {
    //   mode: "development",
    //   externals: {
    //     "jszip": "JSZip"
    //     // "xmldom": "xmldom"
    //   },
    //   devtool: 'inline-source-map',
    //   resolve: {
    //     alias: {
    //       path: "path-webpack"
    //     }
    //   },
    //   module: {
    //     rules: [
    //       {
    //         test: /\.js$/,
    //         exclude: /node_modules/,
    //         loader: "babel-loader",
    //         query: {
    //           presets: [["@babel/preset-env", {
    //             targets: "defaults",
    //           }]],
    //         }
    //       },
    //       {
    //         test: /\.xhtml$/i,
    //         use: 'raw-loader',
    //       }
    //     ]
    //   }
    // },

    webpackMiddleware: {
      stats: 'errors-only',
    },

    // test results reporter to use
    // possible values: 'dots', 'progress'
    // available reporters: https://npmjs.org/browse/keyword/karma-reporter
    reporters: ['mocha'],

    // web server port
    port: 9876,

    // enable / disable colors in the output (reporters and logs)
    colors: true,

    // level of logging
    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG
    logLevel: config.LOG_INFO,

    // enable / disable watching file and executing tests whenever any file changes
    autoWatch: true,

    // start these browsers
    // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher
    browsers: ['ChromeHeadless', 'ChromeHeadlessNoSandbox'],

    // Continuous Integration mode
    // if true, Karma captures browsers, runs the tests and exits
    singleRun: false,

    // Concurrency level
    // how many browser should be started simultaneous
    concurrency: Infinity,

    proxies: {
      '/fixtures/': '/base/test/fixtures/',
    },

    client: {
      config: {
        browserConsoleLogOptions: true,
      },
      captureConsole: true,
      mocha: {
        reporter: 'html',
        // bail: true
      },
    },

    customLaunchers: {
      ChromeHeadlessNoSandbox: {
        base: 'ChromeHeadless',
        flags: ['--no-sandbox'],
      },
    },
  })
}

</code>

packages\epubjs\package.json:
<code>
{
  "name": "@flow/epubjs",
  "version": "0.3.93",
  "description": "Parse and Render Epubs",
  "main": "src/index.js",
  "module": "src/index.js",
  "types": "types/index.d.ts",
  "repository": "https://github.com/futurepress/epub.js",
  "directories": {
    "test": "test"
  },
  "scripts": {
    "test": "karma start --single-run --browsers ChromeHeadlessNoSandbox",
    "docs": "documentation build src/epub.js -f html -o documentation/html/",
    "docs:html": "documentation build src/epub.js -f html -o documentation/html/",
    "docs:md": "documentation build src/epub.js -f md -o documentation/md/API.md",
    "lint": "eslint -c .eslintrc.js src; exit 0",
    "start": "webpack-dev-server --inline --d",
    "build": "NODE_ENV=production webpack --progress",
    "minify": "NODE_ENV=production MINIMIZE=true webpack --progress",
    "legacy": "NODE_ENV=production LEGACY=true webpack --progress",
    "productionLegacy": "NODE_ENV=production MINIMIZE=true LEGACY=true webpack --progress",
    "compile": "babel -d lib/ src/",
    "watch": "babel --watch -d lib/ src/"
  },
  "author": "fchasen@gmail.com",
  "license": "BSD-2-Clause",
  "devDependencies": {
    "@babel/cli": "^7.15.7",
    "@babel/core": "^7.15.8",
    "@babel/plugin-proposal-export-default-from": "^7.14.5",
    "@babel/plugin-proposal-export-namespace-from": "^7.14.5",
    "@babel/preset-env": "^7.15.8",
    "@babel/runtime": "^7.15.4",
    "babel-loader": "^8.2.3",
    "documentation": "^13.2.5",
    "eslint": "^8.0.1",
    "jsdoc": "^3.6.7",
    "karma": "^5.0.9",
    "karma-chrome-launcher": "^3.1.0",
    "karma-mocha": "^2.0.1",
    "karma-mocha-reporter": "^2.2.5",
    "karma-phantomjs-launcher": "^1.0.4",
    "karma-sourcemap-loader": "^0.3.7",
    "karma-webpack": "^4.0.2",
    "mocha": "^7.2.0",
    "mocha-loader": "^5.0.0",
    "raw-loader": "^4.0.2",
    "terser-webpack-plugin": "^3.0.3",
    "tsd-jsdoc": "^2.5.0",
    "webpack": "^4.43.0",
    "webpack-cli": "^3.3.11",
    "webpack-dev-middleware": "^3.7.2",
    "webpack-dev-server": "^3.11.0"
  },
  "dependencies": {
    "@types/localforage": "0.0.34",
    "@xmldom/xmldom": "^0.7.5",
    "core-js": "^3.18.3",
    "event-emitter": "^0.3.5",
    "jszip": "^3.7.1",
    "localforage": "^1.10.0",
    "lodash": "^4.17.21",
    "marks-pane": "^1.0.9",
    "path-webpack": "0.0.3"
  }
}

</code>

packages\epubjs\README.md:
<code>
# Epub.js v0.3

![FuturePress Views](http://fchasen.com/futurepress/fp.png)

Epub.js is a JavaScript library for rendering ePub documents in the browser, across many devices.

Epub.js provides an interface for common ebook functions (such as rendering, persistence and pagination) without the need to develop a dedicated application or plugin. Importantly, it has an incredibly permissive [Free BSD](http://en.wikipedia.org/wiki/BSD_licenses) license.

[Try it while reading Moby Dick](https://futurepress.github.io/epubjs-reader/)

## Why EPUB

![Why EPUB](http://fchasen.com/futurepress/whyepub.png)

The [EPUB standard](http://www.idpf.org/epub/30/spec/epub30-overview.html) is a widely used and easily convertible format. Many books are currently in this format, and it is convertible to many other formats (such as PDF, Mobi and iBooks).

An unzipped EPUB3 is a collection of HTML5 files, CSS, images and other media – just like any other website. However, it enforces a schema of book components, which allows us to render a book and its parts based on a controlled vocabulary.

More specifically, the EPUB schema standardizes the table of contents, provides a manifest that enables the caching of the entire book, and separates the storage of the content from how it’s displayed.

## Getting Started

Get the minified code from the build folder:

```html
<script src="../dist/epub.min.js"></script>
```

If using archived `.epub` files include JSZip:

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
```

Set up a element to render to:

```html
<div id="area"></div>
```

Create the new ePub, and then render it to that element:

```html
<script>
  var book = ePub('url/to/book/package.opf')
  var rendition = book.renderTo('area', { width: 600, height: 400 })
  var displayed = rendition.display()
</script>
```

## Render Methods

### Default

```js
book.renderTo('area', { method: 'default', width: '100%', height: '100%' })
```

[View example](http://futurepress.github.io/epub.js/examples/spreads.html)

The default manager only displays a single section at a time.

### Continuous

```js
book.renderTo('area', { method: 'continuous', width: '100%', height: '100%' })
```

[View example](http://futurepress.github.io/epub.js/examples/continuous-scrolled.html)

The continuous manager will display as many sections as need to fill the screen, and preload the next section offscreen. This enables seamless swiping / scrolling between pages on mobile and desktop, but is less performant than the default method.

## Flow Overrides

### Auto (Default)

`book.renderTo("area", { flow: "auto", width: "900", height: "600" });`

Flow will be based on the settings in the OPF, defaults to `paginated`.

### Paginated

```js
book.renderTo('area', { flow: 'paginated', width: '900', height: '600' })
```

[View example](http://futurepress.github.io/epub.js/examples/spreads.html)

Scrolled: `book.renderTo("area", { flow: "scrolled-doc" });`

[View example](http://futurepress.github.io/epub.js/examples/scrolled.html)

## Scripted Content

[Scripted content](https://www.w3.org/TR/epub-33/#sec-scripted-content), JavasScript the ePub HTML content, is disabled by default due to the potential for executing malicious content.

This is done by sandboxing the iframe the content is rendered into, though it is still recommended to sanitize the ePub content server-side as well.

If a trusted ePub contains interactivity, it can be enabled by passing `allowScriptedContent: true` to the `Rendition` settings.

```html
<script>
  var rendition = book.renderTo('area', {
    width: 600,
    height: 400,
    allowScriptedContent: true,
  })
</script>
```

This will allow the sandboxed content to run scripts, but currently makes the sandbox insecure.

## Documentation

API documentation is available at [epubjs.org/documentation/0.3/](http://epubjs.org/documentation/0.3/)

A Markdown version is included in the repo at [documentation/API.md](https://github.com/futurepress/epub.js/blob/master/documentation/md/API.md)

## Running Locally

install [node.js](http://nodejs.org/)

Then install the project dependences with npm

```javascript
npm install
```

You can run the reader locally with the command

```javascript
npm start
```

## Examples

- [Spreads](http://futurepress.github.io/epub.js/examples/spreads.html)
- [Scrolled](http://futurepress.github.io/epub.js/examples/scrolled.html)
- [Swipe](http://futurepress.github.io/epub.js/examples/swipe.html)
- [Input](http://futurepress.github.io/epub.js/examples/input.html)
- [Highlights](http://futurepress.github.io/epub.js/examples/highlights.html)

[View All Examples](http://futurepress.github.io/epub.js/examples/)

## Testing

Test can be run by Karma from NPM

```js
npm test
```

## Building for Distribution

Builds are concatenated and minified using [webpack](https://webpack.js.org/) and [babel](https://babeljs.io/)

To generate a new build run

```javascript
npm run prepare
```

or to continuously build run

```javascript
npm run watch
```

## Hooks

Similar to a plugins, Epub.js implements events that can be "hooked" into. Thus you can interact with and manipulate the contents of the book.

Examples of this functionality is loading videos from YouTube links before displaying a chapter's contents or implementing annotation.

Hooks require an event to register to and a can return a promise to block until they are finished.

Example hook:

```javascript
rendition.hooks.content.register(function (contents, view) {
  var elements = contents.document.querySelectorAll('[video]')
  var items = Array.prototype.slice.call(elements)

  items.forEach(function (item) {
    // do something with the video item
  })
})
```

The parts of the rendering process that can be hooked into are below.

```js
book.spine.hooks.serialize // Section is being converted to text
book.spine.hooks.content // Section has been loaded and parsed
rendition.hooks.render // Section is rendered to the screen
rendition.hooks.content // Section contents have been loaded
rendition.hooks.unloaded // Section contents are being unloaded
```

## Reader

The reader has moved to its own repo at: https://github.com/futurepress/epubjs-reader/

## Additional Resources

[![Gitter Chat](https://badges.gitter.im/futurepress/epub.js.png)](https://gitter.im/futurepress/epub.js 'Gitter Chat')

[Epub.js Developer Mailing List](https://groups.google.com/forum/#!forum/epubjs)

IRC Server: freenode.net Channel: #epub.js

Follow us on twitter: @Epubjs

- http://twitter.com/#!/Epubjs

## Other

EPUB is a registered trademark of the [IDPF](http://idpf.org/).

</code>

packages\epubjs\tsconfig.json:
<code>
{
  "extends": "../../tsconfig.ts.json"
}

</code>

packages\epubjs\webpack.config.js:
<code>
var path = require('path')

var webpack = require('webpack')
var PROD = process.env.NODE_ENV === 'production'
var LEGACY = process.env.LEGACY
var MINIMIZE = process.env.MINIMIZE === 'true'
var hostname = 'localhost'
var port = 8080

var filename = '[name]'
var sourceMapFilename = '[name]'
if (LEGACY) {
  filename += '.legacy'
}
if (MINIMIZE) {
  filename += '.min.js'
  sourceMapFilename += '.min.js.map'
} else {
  filename += '.js'
  sourceMapFilename += '.js.map'
}

module.exports = {
  mode: process.env.NODE_ENV,
  entry: {
    epub: './src/epub.js',
  },
  devtool: MINIMIZE ? false : 'source-map',
  output: {
    path: path.resolve('./dist'),
    filename: filename,
    sourceMapFilename: sourceMapFilename,
    library: 'ePub',
    libraryTarget: 'umd',
    libraryExport: 'default',
    publicPath: '/dist/',
  },
  optimization: {
    minimize: MINIMIZE,
  },
  externals: {
    'jszip/dist/jszip': 'JSZip',
    xmldom: 'xmldom',
  },
  plugins: [],
  resolve: {
    alias: {
      path: 'path-webpack',
    },
  },
  devServer: {
    host: hostname,
    port: port,
    inline: true,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET,PUT,POST,DELETE',
      'Access-Control-Allow-Headers': 'Content-Type',
    },
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              [
                '@babel/preset-env',
                {
                  targets: LEGACY
                    ? 'defaults'
                    : 'last 2 Chrome versions, last 2 Safari versions, last 2 ChromeAndroid versions, last 2 iOS versions, last 2 Firefox versions, last 2 Edge versions',
                  corejs: 3,
                  useBuiltIns: 'usage',
                  bugfixes: true,
                  modules: false,
                },
              ],
            ],
          },
        },
      },
    ],
  },
  performance: {
    hints: false,
  },
}

</code>

packages\epubjs\documentation\md\API.md:
<code>
<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

## ePub

Creates a new Book

**Parameters**

- `url` **([string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) \| [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer))** URL, Path or ArrayBuffer
- `options` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** to pass to the book

**Examples**

```javascript
ePub('/path/to/book.epub', {})
```

Returns **[Book](#book)** a new Book object

## Book

An Epub representation with methods for the loading, parsing and manipulation
of its contents.

**Parameters**

- `url` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**
- `options` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)?**
  - `options.requestMethod` **method?** a request function to use instead of the default
  - `options.requestCredentials` **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** send the xhr request withCredentials (optional, default `undefined`)
  - `options.requestHeaders` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** send the xhr request headers (optional, default `undefined`)
  - `options.encoding` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** optional to pass 'binary' or base64' for archived Epubs (optional, default `binary`)
  - `options.replacements` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** use base64, blobUrl, or none for replacing assets in archived Epubs (optional, default `none`)
  - `options.canonical` **method?** optional function to determine canonical urls for a path
  - `options.openAs` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?** optional string to determine the input type

**Examples**

```javascript
new Book('/path/to/book.epub', {})
```

```javascript
new Book({ replacements: 'blobUrl' })
```

Returns **[Book](#book)**

### open

Open a epub or url

**Parameters**

- `input` **([string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) \| [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer))** Url, Path or ArrayBuffer
- `what` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** force opening as a certain type (optional, default `"binary","base64","epub","opf","json","directory"`)

**Examples**

```javascript
book.open('/path/to/book.epub')
```

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)** of when the book has been loaded

### load

Load a resource from the Book

**Parameters**

- `path` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** path to the resource to load

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)** returns a promise with the requested resource

### resolve

Resolve a path to it's absolute position in the Book

**Parameters**

- `path` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
- `absolute` **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)?** force resolving the full URL

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** the resolved path string

### canonical

Get a canonical link to a path

**Parameters**

- `path` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** the canonical path string

### section

Gets a Section of the Book from the Spine
Alias for `book.spine.get`

**Parameters**

- `target` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[Section](#section)**

### renderTo

Sugar to render a book to an element

**Parameters**

- `element` **([element](https://developer.mozilla.org/en-US/docs/Web/API/Element) \| [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String))** element or string to add a rendition to
- `options` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)?**

Returns **[Rendition](#rendition)**

### setRequestCredentials

Set if request should use withCredentials

**Parameters**

- `credentials` **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)**

### setRequestHeaders

Set headers request should use

**Parameters**

- `headers` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**

### coverUrl

Get the cover url if there is a cover

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)&lt;[?string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)&gt;** Promise resolves with maybe a url string

### getRange

Find a DOM Range for a given CFI Range

**Parameters**

- `cfiRange` **[EpubCFI](#epubcfi)** a epub cfi range

Returns **[Range](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input)**

### key

Generates the Book Key using the identifier in the manifest or other string provided

**Parameters**

- `identifier` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?** to use instead of metadata identifier

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** key

### destroy

Destroy the Book and all associated objects

### opened

### spine

Type: [Spine](#spine)

### locations

Type: [Locations](#locations)

### navigation

Type: [Navigation](#navigation)

### pagelist

Type: [PageList](#pagelist)

## Url

creates a Url object for parsing and manipulation of a url string

**Parameters**

- `urlString` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** a url string (relative or absolute)
- `baseString` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?** optional base for the url,
  default to window.location.href

### path

Returns **[Path](#path)**

### resolve

Resolves a relative path to a absolute url

**Parameters**

- `what` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** url

### relative

Resolve a path relative to the url

**Parameters**

- `what` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** path

### toString

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

## Path

Creates a Path object for parsing and manipulation of a path strings

Uses a polyfill for Nodejs path: <https://nodejs.org/api/path.html>

**Parameters**

- `pathString` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** a url string (relative or absolute)

### parse

Parse the path: <https://nodejs.org/api/path.html#path_path_parse_path>

**Parameters**

- `what` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**

### isAbsolute

**Parameters**

- `what` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)**

### isDirectory

Check if path ends with a directory

**Parameters**

- `what` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)**

### resolve

Resolve a path against the directory of the Path

<https://nodejs.org/api/path.html#path_path_resolve_paths>

**Parameters**

- `what` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** resolved

### relative

Resolve a path relative to the directory of the Path

<https://nodejs.org/api/path.html#path_path_relative_from_to>

**Parameters**

- `what` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** relative

### toString

Return the path string

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** path

## Spine

A collection of Spine Items

### unpack

Unpack items from a opf into spine items

**Parameters**

- `_package` **[Packaging](#packaging)**
- `resolver` **method** URL resolver
- `canonical` **method** Resolve canonical url

### get

Get an item from the spine

**Parameters**

- `target` **([string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) \| [number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number))?**

**Examples**

```javascript
spine.get()
```

```javascript
spine.get(1)
```

```javascript
spine.get('chap1.html')
```

```javascript
spine.get('#id1234')
```

Returns **[Section](#section)** section

### each

Loop over the Sections in the Spine

Returns **method** forEach

### first

Find the first Section in the Spine

Returns **[Section](#section)** first section

### last

Find the last Section in the Spine

Returns **[Section](#section)** last section

## Section

Represents a Section of the Book

In most books this is equivalent to a Chapter

**Parameters**

- `item` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** The spine item representing the section
- `hooks` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** hooks for serialize and content

### load

Load the section from its url

**Parameters**

- `_request` **method?** a request method to use for loading

Returns **[document](https://developer.mozilla.org/en-US/docs/Web/JavaScript)** a promise with the xml document

### render

Render the contents of a section

**Parameters**

- `_request` **method?** a request method to use for loading

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** output a serialized XML Document

### find

Find a string in a section

**Parameters**

- `_query` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** The query string to find

Returns **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)>** A list of matches, with form {cfi, excerpt}

### reconcileLayoutSettings

Reconciles the current chapters layout properties with
the global layout properties.

**Parameters**

- `globalLayout` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** The global layout settings object, chapter properties string

Returns **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** layoutProperties Object with layout properties

### cfiFromRange

Get a CFI from a Range in the Section

**Parameters**

- `_range` **[range](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input)**

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** cfi an EpubCFI string

### cfiFromElement

Get a CFI from an Element in the Section

**Parameters**

- `el` **[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)**

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** cfi an EpubCFI string

### unload

Unload the section document

## Locations

Find Locations for a Book

**Parameters**

- `spine` **[Spine](#spine)**
- `request` **[request](https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/request)**
- `pause` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** (optional, default `100`)

### generate

Load all of sections in the book to generate locations

**Parameters**

- `chars` **int** how many chars to split on

Returns **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** locations

### locationFromCfi

Get a location from an EpubCFI

**Parameters**

- `cfi` **[EpubCFI](#epubcfi)**

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**

### percentageFromCfi

Get a percentage position in locations from an EpubCFI

**Parameters**

- `cfi` **[EpubCFI](#epubcfi)**

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**

### percentageFromLocation

Get a percentage position from a location index

**Parameters**

- `loc`
- `location` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**

### cfiFromLocation

Get an EpubCFI from location index

**Parameters**

- `loc` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**

Returns **[EpubCFI](#epubcfi)** cfi

### cfiFromPercentage

Get an EpubCFI from location percentage

**Parameters**

- `percentage` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**

Returns **[EpubCFI](#epubcfi)** cfi

### load

Load locations from JSON

**Parameters**

- `locations` **[json](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON)**

### save

Save locations to JSON

Returns **[json](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON)**

### currentLocation

Get the current location

### currentLocation

Set the current location

**Parameters**

- `curr`

### length

Locations length

## Container

Handles Parsing and Accessing an Epub Container

**Parameters**

- `containerDocument` **[document](https://developer.mozilla.org/en-US/docs/Web/JavaScript)?** xml document

### parse

Parse the Container XML

**Parameters**

- `containerDocument` **[document](https://developer.mozilla.org/en-US/docs/Web/JavaScript)**

## Packaging

Open Packaging Format Parser

**Parameters**

- `packageDocument` **[document](https://developer.mozilla.org/en-US/docs/Web/JavaScript)** OPF XML

### parse

Parse OPF XML

**Parameters**

- `packageDocument` **[document](https://developer.mozilla.org/en-US/docs/Web/JavaScript)** OPF XML

Returns **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** parsed package parts

### load

Load JSON Manifest

**Parameters**

- `json`
- `packageDocument` **[document](https://developer.mozilla.org/en-US/docs/Web/JavaScript)** OPF XML

Returns **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** parsed package parts

## Navigation

Navigation Parser

**Parameters**

- `xml` **[document](https://developer.mozilla.org/en-US/docs/Web/JavaScript)** navigation html / xhtml / ncx

### parse

Parse out the navigation items

**Parameters**

- `xml` **[document](https://developer.mozilla.org/en-US/docs/Web/JavaScript)** navigation html / xhtml / ncx

### get

Get an item from the navigation

**Parameters**

- `target` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** navItem

### landmark

Get a landmark by type
List of types: <https://idpf.github.io/epub-vocabs/structure/>

**Parameters**

- `type` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** landmarkItem

### load

Load Spine Items

**Parameters**

- `json` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** the items to be loaded

Returns **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)** navItems

### forEach

forEach pass through

**Parameters**

- `fn` **[Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** function to run on each item

Returns **method** forEach loop

## Resources

Handle Package Resources

**Parameters**

- `manifest` **Manifest**
- `options` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)?**
  - `options.replacements` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** (optional, default `"base64"`)
  - `options.archive` **[Archive](#archive)?**
  - `options.resolver` **method?**

### createUrl

Create a url to a resource

**Parameters**

- `url` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)&lt;[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)>** Promise resolves with url string

### replacements

Create blob urls for all the assets

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)** returns replacement urls

### relativeTo

Resolve all resources URLs relative to an absolute URL

**Parameters**

- `absolute` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** to be resolved to
- `resolver` **resolver?**

Returns **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)>** array with relative Urls

### get

Get a URL for a resource

**Parameters**

- `path` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** url

### substitute

Substitute urls in content, with replacements,
relative to a url if provided

**Parameters**

- `content` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
- `url` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?** url to resolve to

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** content with urls substituted

## PageList

Page List Parser

**Parameters**

- `xml` **[document](https://developer.mozilla.org/en-US/docs/Web/JavaScript)?**

### parse

Parse PageList Xml

**Parameters**

- `xml` **[document](https://developer.mozilla.org/en-US/docs/Web/JavaScript)**

### pageFromCfi

Get a PageList result from a EpubCFI

**Parameters**

- `cfi` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** EpubCFI String

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** page

### cfiFromPage

Get an EpubCFI from a Page List Item

**Parameters**

- `pg` **([string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) \| [number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number))**

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** cfi

### pageFromPercentage

Get a Page from Book percentage

**Parameters**

- `percent` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** page

### percentageFromPage

Returns a value between 0 - 1 corresponding to the location of a page

**Parameters**

- `pg` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** the page

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** percentage

### percentageFromCfi

Returns a value between 0 - 1 corresponding to the location of a cfi

**Parameters**

- `cfi` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** EpubCFI String

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** percentage

### destroy

Destroy

## Archive

Handles Unzipping a requesting files from an Epub Archive

### open

Open an archive

**Parameters**

- `input` **binary**
- `isBase64` **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)?** tells JSZip if the input data is base64 encoded

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)** zipfile

### openUrl

Load and Open an archive

**Parameters**

- `zipUrl` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
- `isBase64` **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)?** tells JSZip if the input data is base64 encoded

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)** zipfile

### request

Request a url from the archive

**Parameters**

- `url` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** a url to request from the archive
- `type` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?** specify the type of the returned result

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)&lt;([Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob) \| [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) \| [JSON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON) \| [Document](https://developer.mozilla.org/en-US/docs/Web/JavaScript) | XMLDocument)>**

### getBlob

Get a Blob from Archive by Url

**Parameters**

- `url` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
- `mimeType` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**

Returns **[Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob)**

### getText

Get Text from Archive by Url

**Parameters**

- `url` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
- `encoding` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

### getBase64

Get a base64 encoded result from Archive by Url

**Parameters**

- `url` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
- `mimeType` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** base64 encoded

### createUrl

Create a Url from an unarchived item

**Parameters**

- `url` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
- `options`

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)** url promise with Url string

### revokeUrl

Revoke Temp Url for a archive item

**Parameters**

- `url` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** url of the item in the archive

## Rendition

Displays an Epub as a series of Views for each Section.
Requires Manager and View class to handle specifics of rendering
the section content.

**Parameters**

- `book` **[Book](#book)**
- `options` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)?**
  - `options.width` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)?**
  - `options.height` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)?**
  - `options.ignoreClass` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?** class for the cfi parser to ignore
  - `options.manager` **([string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) \| [function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function) \| [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object))** (optional, default `'default'`)
  - `options.view` **([string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) \| [function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function))** (optional, default `'iframe'`)
  - `options.layout` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?** layout to force
  - `options.spread` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?** force spread value
  - `options.minSpreadWidth` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)?** overridden by spread: none (never) / both (always)
  - `options.stylesheet` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?** url of stylesheet to be injected
  - `options.resizeOnOrientationChange` **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)?** false to disable orientation events
  - `options.script` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?** url of script to be injected

### setManager

Set the manager function

**Parameters**

- `manager` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)**

### requireManager

Require the manager from passed string, or as a class function

**Parameters**

- `manager` **([string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) \| [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object))** [description]

Returns **method**

### requireView

Require the view from passed string, or as a class function

**Parameters**

- `view` **([string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) \| [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object))**

Returns **view**

### start

Start the rendering

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)** rendering has started

### attachTo

Call to attach the container to an element in the dom
Container must be attached before rendering can begin

**Parameters**

- `element` **[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)** to attach to

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)**

### display

Display a point in the book
The request will be added to the rendering Queue,
so it will wait until book is opened, rendering started
and all other rendering tasks have finished to be called.

**Parameters**

- `target` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** Url or EpubCFI

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)**

### moveTo

Move the Rendition to a specific offset
Usually you would be better off calling display()

**Parameters**

- `offset` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**

### resize

Trigger a resize of the views

**Parameters**

- `width` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)?**
- `height` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)?**

### clear

Clear all rendered views

### next

Go to the next "page" in the rendition

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)**

### prev

Go to the previous "page" in the rendition

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)**

### flow

Adjust the flow of the rendition to paginated or scrolled
(scrolled-continuous vs scrolled-doc are handled by different view managers)

**Parameters**

- `flow` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

### layout

Adjust the layout of the rendition to reflowable or pre-paginated

**Parameters**

- `settings` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**

### spread

Adjust if the rendition uses spreads

**Parameters**

- `spread` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** none | auto (TODO: implement landscape, portrait, both)
- `min` **int** min width to use spreads at

### direction

Adjust the direction of the rendition

**Parameters**

- `dir` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

### reportLocation

Report the current location

### currentLocation

Get the Current Location object

Returns **(displayedLocation | [promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise))** location (may be a promise)

### destroy

Remove and Clean Up the Rendition

### getRange

Get a Range from a Visible CFI

**Parameters**

- `cfi` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** EpubCfi String
- `ignoreClass` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[range](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input)**

### getContents

Get the Contents object of each rendered view

Returns **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;[Contents](#contents)>**

### views

Get the views member from the manager

Returns **Views**

### hooks

Adds Hook methods to the Rendition prototype

Type: [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

### themes

Type: [Themes](#themes)

### annotations

Type: [Annotations](#annotations)

### location

A Rendered Location Range

**Properties**

- `start` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**
  - `start.index` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
  - `start.href` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
  - `start.displayed` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**
    - `start.displayed.page` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**
    - `start.displayed.total` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**
  - `start.cfi` **[EpubCFI](#epubcfi)**
  - `start.location` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**
  - `start.percentage` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**
- `end` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**
  - `end.index` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
  - `end.href` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
  - `end.displayed` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**
    - `end.displayed.page` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**
    - `end.displayed.total` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**
  - `end.cfi` **[EpubCFI](#epubcfi)**
  - `end.location` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**
  - `end.percentage` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**
- `atStart` **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)**
- `atEnd` **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)**

### started

## Hook

Hooks allow for injecting functions that must all complete in order before finishing
They will execute in parallel but all must finish before continuing
Functions may return a promise if they are async.

**Parameters**

- `context` **any** scope of this

**Examples**

```javascript
this.content = new EPUBJS.Hook(this)
```

### register

Adds a function to be run before a hook completes

**Examples**

```javascript
this.content.register(function(){...});
```

### trigger

Triggers a hook to run all functions

**Examples**

```javascript
this.content.trigger(args).then(function(){...});
```

## Queue

Queue for handling tasks one at a time

**Parameters**

- `context` **scope** what this will resolve to in the tasks

### enqueue

Add an item to the queue

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)**

### dequeue

Run one item

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)**

### run

Run all tasks sequentially, at convince

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)**

### flush

Flush all, as quickly as possible

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)**

### clear

Clear all items in wait

### length

Get the number of tasks in the queue

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** tasks

### pause

Pause a running queue

### stop

End the queue

## Layout

Figures out the CSS values to apply for a layout

**Parameters**

- `settings` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**
  - `settings.layout` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** (optional, default `'reflowable'`)
  - `settings.spread` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**
  - `settings.minSpreadWidth` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** (optional, default `800`)
  - `settings.evenSpreads` **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** (optional, default `false`)

### flow

Switch the flow between paginated and scrolled

**Parameters**

- `flow` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** paginated | scrolled

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** simplified flow

### spread

Switch between using spreads or not, and set the
width at which they switch to single.

**Parameters**

- `spread` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** "none" | "always" | "auto"
- `min` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** integer in pixels

Returns **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** spread true | false

### calculate

Calculate the dimensions of the pagination

**Parameters**

- `_width` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** width of the rendering
- `_height` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** height of the rendering
- `_gap` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** width of the gap between columns

### format

Apply Css to a Document

**Parameters**

- `contents` **[Contents](#contents)**

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)**

### count

Count number of pages

**Parameters**

- `totalLength` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**
- `pageLength` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**

Returns **{spreads: [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number), pages: [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)}**

## Themes

Themes to apply to displayed content

**Parameters**

- `rendition` **[Rendition](#rendition)**

### register

Add themes to be used by a rendition

**Examples**

```javascript
themes.register('light', 'http://example.com/light.css')
```

```javascript
themes.register('light', { body: { color: 'purple' } })
```

```javascript
themes.register({ "light" : {...}, "dark" : {...}})
```

### default

Add a default theme to be used by a rendition

**Parameters**

- `theme` **([object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) \| [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String))**

**Examples**

```javascript
themes.register('http://example.com/default.css')
```

```javascript
themes.register({ body: { color: 'purple' } })
```

### registerThemes

Register themes object

**Parameters**

- `themes` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**

### registerUrl

Register a url

**Parameters**

- `name` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
- `input` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

### registerRules

Register rule

**Parameters**

- `name` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
- `rules` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**

### select

Select a theme

**Parameters**

- `name` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

### update

Update a theme

**Parameters**

- `name` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

### inject

Inject all themes into contents

**Parameters**

- `contents` **[Contents](#contents)**

### add

Add Theme to contents

**Parameters**

- `name` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
- `contents` **[Contents](#contents)**

### override

Add override

**Parameters**

- `name` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
- `value` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
- `priority` **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)**

### overrides

Add all overrides

**Parameters**

- `contents`
- `content` **Content**

### fontSize

Adjust the font size of a rendition

**Parameters**

- `size` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**

### font

Adjust the font-family of a rendition

**Parameters**

- `f` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

## Annotations

Handles managing adding & removing Annotations

**Parameters**

- `rendition` **[Rendition](#rendition)**

### add

Add an annotation to store

**Parameters**

- `type` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** Type of annotation to add: "highlight", "underline", "mark"
- `cfiRange` **[EpubCFI](#epubcfi)** EpubCFI range to attach annotation to
- `data` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** Data to assign to annotation
- `cb` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)?** Callback after annotation is added
- `className` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** CSS class to assign to annotation
- `styles` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** CSS styles to assign to annotation

Returns **[Annotation](#annotation)** annotation

### remove

Remove an annotation from store

**Parameters**

- `cfiRange` **[EpubCFI](#epubcfi)** EpubCFI range the annotation is attached to
- `type` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** Type of annotation to add: "highlight", "underline", "mark"

### highlight

Add a highlight to the store

**Parameters**

- `cfiRange` **[EpubCFI](#epubcfi)** EpubCFI range to attach annotation to
- `data` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** Data to assign to annotation
- `cb` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** Callback after annotation is added
- `className` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** CSS class to assign to annotation
- `styles` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** CSS styles to assign to annotation

### underline

Add a underline to the store

**Parameters**

- `cfiRange` **[EpubCFI](#epubcfi)** EpubCFI range to attach annotation to
- `data` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** Data to assign to annotation
- `cb` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** Callback after annotation is added
- `className` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** CSS class to assign to annotation
- `styles` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** CSS styles to assign to annotation

### mark

Add a mark to the store

**Parameters**

- `cfiRange` **[EpubCFI](#epubcfi)** EpubCFI range to attach annotation to
- `data` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** Data to assign to annotation
- `cb` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** Callback after annotation is added

### each

iterate over annotations in the store

### show

[Not Implemented] Show annotations

### hide

[Not Implemented] Hide annotations

## Annotation

Annotation object

**Parameters**

- `$0` **[Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**
  - `$0.type`
  - `$0.cfiRange`
  - `$0.data`
  - `$0.sectionIndex`
  - `$0.cb`
  - `$0.className`
  - `$0.styles`
- `options` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**
  - `options.type` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** Type of annotation to add: "highlight", "underline", "mark"
  - `options.cfiRange` **[EpubCFI](#epubcfi)** EpubCFI range to attach annotation to
  - `options.data` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** Data to assign to annotation
  - `options.sectionIndex` **int** Index in the Spine of the Section annotation belongs to
  - `options.cb` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)?** Callback after annotation is added
- `className` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** CSS class to assign to annotation
- `styles` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** CSS styles to assign to annotation

Returns **[Annotation](#annotation)** annotation

### update

Update stored data

**Parameters**

- `data` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**

### attach

Add to a view

**Parameters**

- `view` **View**

### detach

Remove from a view

**Parameters**

- `view` **View**

### text

[Not Implemented] Get text of an annotation

## EpubCFI

Parsing and creation of EpubCFIs: <http://www.idpf.org/epub/linking/cfi/epub-cfi.html>

Implements:

- Character Offset: epubcfi(/6/4[chap01ref]!/4[body01]/10[para05]/2/1:3)
- Simple Ranges : epubcfi(/6/4[chap01ref]!/4[body01]/10[para05],/2/1:1,/3:4)

Does Not Implement:

- Temporal Offset (~)
- Spatial Offset (@)
- Temporal-Spatial Offset (~ + @)
- Text Location Assertion (\[)

**Parameters**

- `cfiFrom` **([string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) \| [Range](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input) \| [Node](https://developer.mozilla.org/en-US/docs/Web/API/Node/nextSibling))?**
- `base` **([string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) \| [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object))?**
- `ignoreClass` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?** class to ignore when parsing DOM

### parse

Parse a cfi string to a CFI object representation

**Parameters**

- `cfiStr` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** cfi

### toString

Convert CFI to a epubcfi(...) string

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** epubcfi

### compare

Compare which of two CFIs is earlier in the text

**Parameters**

- `cfiOne`
- `cfiTwo`

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** First is earlier = -1, Second is earlier = 1, They are equal = 0

### fromRange

Create a CFI object from a Range

**Parameters**

- `range` **[Range](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input)**
- `base` **([string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) \| [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object))**
- `ignoreClass` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**

Returns **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** cfi

### fromNode

Create a CFI object from a Node

**Parameters**

- `anchor` **[Node](https://developer.mozilla.org/en-US/docs/Web/API/Node/nextSibling)**
- `base` **([string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) \| [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object))**
- `ignoreClass` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**

Returns **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** cfi

### toRange

Creates a DOM range representing a CFI

**Parameters**

- `_doc` **[document](https://developer.mozilla.org/en-US/docs/Web/JavaScript)** document referenced in the base
- `ignoreClass` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**

Returns **[Range](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input)**

### isCfiString

Check if a string is wrapped with "epubcfi()"

**Parameters**

- `str` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)**

### collapse

Collapse a CFI Range to a single CFI Position

**Parameters**

- `toStart` **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** (optional, default `false`)

## Contents

Handles DOM manipulation, queries and events for View contents

**Parameters**

- `doc` **[document](https://developer.mozilla.org/en-US/docs/Web/JavaScript)** Document
- `content` **[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)** Parent Element (typically Body)
- `cfiBase` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** Section component of CFIs
- `sectionIndex` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** Index in Spine of Conntent's Section

### width

Get or Set width

**Parameters**

- `w` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)?**

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** width

### height

Get or Set height

**Parameters**

- `h` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)?**

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** height

### contentWidth

Get or Set width of the contents

**Parameters**

- `w` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)?**

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** width

### contentHeight

Get or Set height of the contents

**Parameters**

- `h` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)?**

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** height

### textWidth

Get the width of the text using Range

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** width

### textHeight

Get the height of the text using Range

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** height

### scrollWidth

Get documentElement scrollWidth

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** width

### scrollHeight

Get documentElement scrollHeight

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** height

### overflow

Set overflow css style of the contents

**Parameters**

- `overflow` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**

### overflowX

Set overflowX css style of the documentElement

**Parameters**

- `overflow` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**

### overflowY

Set overflowY css style of the documentElement

**Parameters**

- `overflow` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**

### css

Set Css styles on the contents element (typically Body)

**Parameters**

- `property` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
- `value` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
- `priority` **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)?** set as "important"

### viewport

Get or Set the viewport element

**Parameters**

- `options` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)?**
  - `options.width` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**
  - `options.height` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**
  - `options.scale` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**
  - `options.minimum` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**
  - `options.maximum` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**
  - `options.scalable` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**

### root

Get the documentElement

Returns **[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)** documentElement

### locationOf

Get the location offset of a EpubCFI or an #id

**Parameters**

- `target` **([string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) \| [EpubCFI](#epubcfi))**
- `ignoreClass` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?** for the cfi

### addStylesheet

Append a stylesheet link to the document head

**Parameters**

- `src` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** url

### addStylesheetRules

Append stylesheet rules to a generate stylesheet
Array: <https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule>
Object: <https://github.com/desirable-objects/json-to-css>

**Parameters**

- `rules` **([array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) \| [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object))**

### addScript

Append a script tag to the document head

**Parameters**

- `src` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** url

Returns **[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)** loaded

### addClass

Add a class to the contents container

**Parameters**

- `className` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

### removeClass

Remove a class from the contents container

**Parameters**

- `className`
- `removeClass` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

### range

Get a Dom Range from EpubCFI

**Parameters**

- `_cfi` **[EpubCFI](#epubcfi)**
- `ignoreClass` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**

Returns **[Range](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input)** range

### cfiFromRange

Get an EpubCFI from a Dom Range

**Parameters**

- `range` **[Range](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input)**
- `ignoreClass` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**

Returns **[EpubCFI](#epubcfi)** cfi

### cfiFromNode

Get an EpubCFI from a Dom node

**Parameters**

- `node` **[node](https://developer.mozilla.org/en-US/docs/Web/API/Node/nextSibling)**
- `ignoreClass` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)?**

Returns **[EpubCFI](#epubcfi)** cfi

### size

Size the contents to a given width and height

**Parameters**

- `width` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)?**
- `height` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)?**

### columns

Apply columns to the contents for pagination

**Parameters**

- `width` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**
- `height` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**
- `columnWidth` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**
- `gap` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**

### scaler

Scale contents from center

**Parameters**

- `scale` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**
- `offsetX` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**
- `offsetY` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**

### fit

Fit contents into a fixed width and height

**Parameters**

- `width` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**
- `height` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)**

### direction

Set the direction of the text

**Parameters**

- `dir` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** "rtl" | "ltr" (optional, default `"ltr"`)

### writingMode

Set the writingMode of the text

**Parameters**

- `mode` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** "horizontal-tb" | "vertical-rl" | "vertical-lr" (optional, default `"horizontal-tb"`)

### listenedEvents

Get DOM events that are listened for and passed along

## Mapping

Map text locations to CFI ranges

**Parameters**

- `layout` **[Layout](#layout)** Layout to apply
- `direction` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** Text direction (optional, default `"ltr"`)
- `axis` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** vertical or horizontal axis (optional, default `"horizontal"`)
- `dev` **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)?** toggle developer highlighting

### section

Find CFI pairs for entire section at once

**Parameters**

- `view`

### page

Find CFI pairs for a page

**Parameters**

- `contents` **[Contents](#contents)** Contents from view
- `cfiBase` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** string of the base for a cfi
- `start` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** position to start at
- `end` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** position to end at

### axis

Set the axis for mapping

**Parameters**

- `axis` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** horizontal | vertical

Returns **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** is it horizontal?

## Core

Core Utilities and Helpers

### requestAnimationFrame

Vendor prefixed requestAnimationFrame

Returns **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** requestAnimationFrame

### uuid

Generates a UUID
based on: <http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript>

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** uuid

### documentHeight

Gets the height of a document

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** height

### isElement

Checks if a node is an element

**Parameters**

- `obj` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**

Returns **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)**

### isNumber

**Parameters**

- `n` **any**

Returns **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)**

### isFloat

**Parameters**

- `n` **any**

Returns **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)**

### prefixed

Get a prefixed css property

**Parameters**

- `unprefixed` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

### defaults

Apply defaults to an object

**Parameters**

- `obj` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**

Returns **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**

### extend

Extend properties of an object

**Parameters**

- `target` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**

Returns **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**

### insert

Fast quicksort insert for sorted array -- based on:
<http://stackoverflow.com/questions/1344500/efficient-way-to-insert-a-number-into-a-sorted-array-of-numbers>

**Parameters**

- `item` **any**
- `array` **[array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)**
- `compareFunction` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)?**

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** location (in array)

### locationOf

Finds where something would fit into a sorted array

**Parameters**

- `item` **any**
- `array` **[array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)**
- `compareFunction` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)?**
- `_start` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)?**
- `_end` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)?**

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** location (in array)

### indexOfSorted

Finds index of something in a sorted array
Returns -1 if not found

**Parameters**

- `item` **any**
- `array` **[array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)**
- `compareFunction` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)?**
- `_start` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)?**
- `_end` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)?**

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** index (in array) or -1

### bounds

Find the bounds of an element
taking padding and margin into account

**Parameters**

- `el` **[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)**

Returns **{width: [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number), height: [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)}**

### borders

Find the bounds of an element
taking padding, margin and borders into account

**Parameters**

- `el` **[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)**

Returns **{width: [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number), height: [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)}**

### nodeBounds

Find the bounds of any node
allows for getting bounds of text nodes by wrapping them in a range

**Parameters**

- `node` **[node](https://developer.mozilla.org/en-US/docs/Web/API/Node/nextSibling)**

Returns **BoundingClientRect**

### windowBounds

Find the equivalent of getBoundingClientRect of a browser window

Returns **{width: [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number), height: [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number), top: [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number), left: [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number), right: [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number), bottom: [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)}**

### indexOfNode

Gets the index of a node in its parent

**Parameters**

- `node` **[Node](https://developer.mozilla.org/en-US/docs/Web/API/Node/nextSibling)**
- `typeId` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** index

### indexOfTextNode

Gets the index of a text node in its parent

**Parameters**

- `textNode` **[node](https://developer.mozilla.org/en-US/docs/Web/API/Node/nextSibling)**

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** index

### indexOfElementNode

Gets the index of an element node in its parent

**Parameters**

- `elementNode` **[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)**

Returns **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** index

### isXml

Check if extension is xml

**Parameters**

- `ext` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)**

### createBlob

Create a new blob

**Parameters**

- `content` **any**
- `mime` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob)**

### createBlobUrl

Create a new blob url

**Parameters**

- `content` **any**
- `mime` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** url

### revokeBlobUrl

Remove a blob url

**Parameters**

- `url` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

### createBase64Url

Create a new base64 encoded url

**Parameters**

- `content` **any**
- `mime` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** url

### type

Get type of an object

**Parameters**

- `obj` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** type

### parse

Parse xml (or html) markup

**Parameters**

- `markup` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
- `mime` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
- `forceXMLDom` **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** force using xmlDom to parse instead of native parser

Returns **[document](https://developer.mozilla.org/en-US/docs/Web/JavaScript)** document

### qs

querySelector polyfill

**Parameters**

- `el` **[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)**
- `sel` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** selector string

Returns **[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)** element

### qsa

querySelectorAll polyfill

**Parameters**

- `el` **[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)**
- `sel` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** selector string

Returns **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)>** elements

### qsp

querySelector by property

**Parameters**

- `el` **[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)**
- `sel` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** selector string
- `props` **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)>**

Returns **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)>** elements

### sprint

Sprint through all text nodes in a document

**Parameters**

- `root` **[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)** element to start with
- `func` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** function to run on each element

### treeWalker

Create a treeWalker

**Parameters**

- `root` **[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)** element to start with
- `func` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** function to run on each element
- `filter` **([function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function) \| [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object))** function or object to filter with

### walk

**Parameters**

- `node` **[node](https://developer.mozilla.org/en-US/docs/Web/API/Node/nextSibling)**
- `callback`
- `return` **callback** false for continue,true for break inside callback

### blob2base64

Convert a blob to a base64 encoded string

**Parameters**

- `blob` **Blog**

Returns **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

### defer

Creates a new pending promise and provides methods to resolve or reject it.
From: <https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible>

### querySelectorByType

querySelector with filter by epub type

**Parameters**

- `html` **[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)**
- `element` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** element type to find
- `type` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** epub type to find

Returns **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)>** elements

### findChildren

Find direct descendents of an element

**Parameters**

- `el` **[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)**

Returns **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)>** children

### parents

Find all parents (ancestors) of an element

**Parameters**

- `node` **[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)**

Returns **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)>** parents

### filterChildren

Find all direct descendents of a specific type

**Parameters**

- `el` **[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)**
- `nodeName` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**
- `single` **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)?**

Returns **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)>** children

### getParentByTagName

Filter all parents (ancestors) with tag name

**Parameters**

- `node` **[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)**
- `tagname` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)**

Returns **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;[element](https://developer.mozilla.org/en-US/docs/Web/API/Element)>** parents

### RangeObject

Lightweight Polyfill for DOM Range

</code>

packages\epubjs\examples\annotator.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Annotator Example</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
  <script src="../dist/epub.js"></script>

  <!-- <script type="text/javascript" src="https://cdn.jsdelivr.net/annotator/1.2.9/annotator.min.js"></script> -->

  <link rel="stylesheet" type="text/css" href="examples.css">

</head>
<body>
  <div id="viewer" class="spreads"></div>
  <div id="prev" class="arrow">‹</div>
  <div id="next" class="arrow">›</div>
  <script>
    // Load the opf
    var book = ePub("https://s3.amazonaws.com/moby-dick/OPS/package.opf");
    var rendition = book.renderTo("viewer", {
      width: "100%",
      height: 600,
      ignoreClass: 'annotator-hl'
    });

    var displayed = rendition.display(3);

    // Navigation loaded
    book.loaded.navigation.then(function(toc){
      // console.log(toc);
    });

    var next = document.getElementById("next");
    next.addEventListener("click", function(){
      rendition.next();
    }, false);

    var prev = document.getElementById("prev");
    prev.addEventListener("click", function(){
      rendition.prev();
    }, false);

    var keyListener = function(e){

      // Left Key
      if ((e.keyCode || e.which) == 37) {
        rendition.prev();
      }

      // Right Key
      if ((e.keyCode || e.which) == 39) {
        rendition.next();
      }

    };

    rendition.on("keyup", keyListener);
    document.addEventListener("keyup", keyListener, false);

    rendition.on("relocated", function(location){
      // console.log(location);
    });

    rendition.hooks.render.register(function (view) {

      var adder = [
        ['.annotator-adder, .annotator-outer', ['position', 'fixed']]
      ];

      view.addScript('https://cdn.jsdelivr.net/jquery/3.0.0-beta1/jquery.min.js').
        then(function () {
          return view.addScript('https://cdn.jsdelivr.net/annotator/1.2.9/annotator-full.min.js');
        }).
        then(function () {
          return view.addCss('https://cdn.jsdelivr.net/annotator/1.2.9/annotator.min.css');
        }).
        then(function () {

          view.addStylesheetRules(adder);

          view.window.Annotator.Util.mousePosition = function(event) {
              var body = view.document.body;
              // var offset = view.position();

              return {
                  top: event.pageY,
                  left: event.pageX
              };
          };
          var ann = new view.window.Annotator(view.document.body);
        });


    })


  </script>

</body>
</html>

</code>

packages\epubjs\examples\archived.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Archived Example</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
  <script src="../dist/epub.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">

</head>
<body>
  <div id="viewer" class="spreads"></div>
  <div id="prev" class="arrow">‹</div>
  <div id="next" class="arrow">›</div>
  <script>
    var book = ePub("https://s3.amazonaws.com/moby-dick/moby-dick.epub");
    var rendition = book.renderTo("viewer", {
      width: "100%",
      height: 600
    });

    var displayed = rendition.display();


    displayed.then(function(renderer){
      // -- do stuff
    });

    // Navigation loaded
    book.loaded.navigation.then(function(toc){
      // console.log(toc);
    });

    var next = document.getElementById("next");
    next.addEventListener("click", function(){
      rendition.next();
    }, false);

    var prev = document.getElementById("prev");
    prev.addEventListener("click", function(){
      rendition.prev();
    }, false);

    var keyListener = function(e){

      // Left Key
      if ((e.keyCode || e.which) == 37) {
        rendition.prev();
      }

      // Right Key
      if ((e.keyCode || e.which) == 39) {
        rendition.next();
      }

    };

    rendition.on("keyup", keyListener);
    document.addEventListener("keyup", keyListener, false);


  </script>

</body>
</html>

</code>

packages\epubjs\examples\contents.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>EPUB.js Basic Example</title>

  <script src="../dist/epub.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">

</head>
<body>
  <div id="viewer" class="scrolled"></div>

  <script>
    var $viewer = document.getElementById("viewer");

    var book = ePub("https://s3.amazonaws.com/epubjs/books/moby-dick/OPS/package.opf");
    book.ready.then(function(){
      book.getRange("epubcfi(/6/14[xchapter_001]!/4/2,/2/2/2[c001s0000]/1:0,/8/2[c001p0003]/1:663)").then(function(range) {
        let text = range.toString()
        console.log(text);
        $viewer.textContent = text;
      });
    });
  </script>

</body>
</html>

</code>

packages\epubjs\examples\continuous-scrolled.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Continuous Example</title>

  <script src="../dist/epub.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">

  <style type="text/css">

    .epub-container {
      /* min-width: 320px; */
      /* margin: 0 auto; */
      /* position: relative; */
    }

    .epub-container .epub-view > iframe {
        background: white;
        box-shadow: 0 0 4px #ccc;
        /*margin: 10px;
        padding: 20px;*/
    }

    #viewer {
      width: 600px;
      height: 100vh;
      /* overflow: auto; */
      margin: 0 auto;
    }

  </style>
</head>
<body>
  <div id="viewer"></div>

  <script>
    var params = URLSearchParams && new URLSearchParams(document.location.search.substring(1));
    var url = params && params.get("url") && decodeURIComponent(params.get("url"));
    var currentSectionIndex = (params && params.get("loc")) ? params.get("loc") : undefined;

    // Load the opf
    var book = ePub(url || "https://s3.amazonaws.com/epubjs/books/moby-dick/OPS/package.opf");
    var rendition = book.renderTo("viewer", {
        manager: "continuous",
        flow: "scrolled",
        width: "100%",
        height: "100%"
      });
    var displayed = rendition.display(currentSectionIndex);


    displayed.then(function(renderer){
      // -- do stuff
    });

    // Navigation loaded
    book.loaded.navigation.then(function(toc){
      // console.log(toc);
    });


  </script>

</body>
</html>

</code>

packages\epubjs\examples\continuous-spreads.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Continuous Spreads Example</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
  <script src="../dist/epub.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">


</head>
<body>
  <select id="toc"></select>
  <div id="viewer" class="spreads"></div>
  <div id="prev" class="arrow">‹</div>
  <div id="next" class="arrow">›</div>
  <script>
    var params = URLSearchParams && new URLSearchParams(document.location.search.substring(1));
    var url = params && params.get("url") && decodeURIComponent(params.get("url"));
    var currentSectionIndex = (params && params.get("loc")) ? params.get("loc") : undefined;

    // Load the opf
    window.book = ePub(url || "https://s3.amazonaws.com/moby-dick/moby-dick.epub");
    var rendition = book.renderTo("viewer", {
      manager: "continuous",
      flow: "paginated",
      width: "100%",
      height: 600
    });

    var displayed = rendition.display(currentSectionIndex);


    displayed.then(function(renderer){
      // -- do stuff
    });

    // Navigation loaded
    book.loaded.navigation.then(function(toc){
      // console.log(toc);
    });

    book.ready.then(() => {

      var next = document.getElementById("next");

      next.addEventListener("click", function(e){
        book.package.metadata.direction === "rtl" ? rendition.prev() : rendition.next();
        e.preventDefault();
      }, false);

      var prev = document.getElementById("prev");
      prev.addEventListener("click", function(e){
        book.package.metadata.direction === "rtl" ? rendition.next() : rendition.prev();
        e.preventDefault();
      }, false);

      var keyListener = function(e){

        // Left Key
        if ((e.keyCode || e.which) == 37) {
          book.package.metadata.direction === "rtl" ? rendition.next() : rendition.prev();
        }

        // Right Key
        if ((e.keyCode || e.which) == 39) {
          book.package.metadata.direction === "rtl" ? rendition.prev() : rendition.next();
        }

      };

      rendition.on("keyup", keyListener);
      document.addEventListener("keyup", keyListener, false);

    });

    rendition.on("selected", function(range) {
      console.log("selected", range);
    });

    rendition.on("layout", function(layout) {
      let viewer = document.getElementById("viewer");

      if (layout.spread) {
        viewer.classList.remove('single');
      } else {
        viewer.classList.add('single');
      }
    });

    rendition.on("relocated", function(location){
      console.log(location);

      var next = book.package.metadata.direction === "rtl" ?  document.getElementById("prev") : document.getElementById("next");
      var prev = book.package.metadata.direction === "rtl" ?  document.getElementById("next") : document.getElementById("prev");

      if (location.atEnd) {
        next.style.visibility = "hidden";
      } else {
        next.style.visibility = "visible";
      }

      if (location.atStart) {
        prev.style.visibility = "hidden";
      } else {
        prev.style.visibility = "visible";
      }

    });

    book.loaded.navigation.then(function(toc){
			var $select = document.getElementById("toc"),
					docfrag = document.createDocumentFragment();

			toc.forEach(function(chapter) {
				var option = document.createElement("option");
				option.textContent = chapter.label;
				option.ref = chapter.href;

				docfrag.appendChild(option);
			});

			$select.appendChild(docfrag);

			$select.onchange = function(){
					var index = $select.selectedIndex,
							url = $select.options[index].ref;
					rendition.display(url);
					return false;
			};

		});

  </script>

</body>
</html>

</code>

packages\epubjs\examples\embedded.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title></title>

  <script src="../dist/epub.js"></script>

  <style>

    body {
      margin: 0;
    }

  </style>
</head>
<body>

  <script>
    var params = URLSearchParams && new URLSearchParams(document.location.search.substring(1));
    var url = params && params.get("url") && decodeURIComponent(params.get("url"));
    var currentCfi = (params && params.get("cfi")) ? params.get("cfi") : undefined;
    var currentSectionIndex = (params && params.get("loc")) ? parseInt(params.get("loc")) : undefined;

    // Load the opf
    var book = ePub(url || "https://s3.amazonaws.com/moby-dick/");
    var rendition = book.renderTo(document.body, {
      manager: "continuous",
      snap: true
    });

    rendition.display(currentCfi || currentSectionIndex);


    rendition.on("rendered", function(section){
      // console.log("rendered", section);
      var nextSection = section.next();
      var prevSection = section.prev();

      var current = book.navigation && book.navigation.get(section.href);

      if (current) {
        document.title = current.label;
      }
    });

    rendition.on("relocated", function(location){
      // console.log("locationChanged", location)
      console.log("locationChanged start", location.start.cfi)
      // console.log("locationChanged end", location.end.cfi)
    });

    window.addEventListener("unload", function () {
      console.log("unloading");
      this.book.destroy();
    });

  </script>
</body>
</html>

</code>

packages\epubjs\examples\examples.css:
<code>
body {
  margin: 0;
  background: #fafafa;
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  color: #333;

  position: absolute;
  height: 100%;
  width: 100%;
  min-height: 800px;
}

#title {
  width: 900px;
  min-height: 18px;
  margin: 10px auto;
  text-align: center;
  font-size: 16px;
  color: #e2e2e2;
  font-weight: 400;
}

#title:hover {
  color: #777;
}

#viewer.spreads {
  width: 900px;
  height: 600px;
  box-shadow: 0 0 4px #ccc;
  border-radius: 5px;
  padding: 0;
  position: relative;
  margin: 10px auto;
  background: white url('ajax-loader.gif') center center no-repeat;
  top: calc(50vh - 400px);
}

#viewer.spreads .epub-view > iframe {
  background: white;
}

#viewer.scrolled {
  overflow: hidden;
  width: 800px;
  margin: 0 auto;
  position: relative;
  background: url('ajax-loader.gif') center center no-repeat;
  box-shadow: 0 0 4px #ccc;
  padding: 20px;
  background: white;
}

#viewer.scrolled .epub-view > iframe {
  background: white;
}

#prev {
  left: 0;
}

#next {
  right: 0;
}

#toc {
  display: block;
  margin: 10px auto;
}

@media (min-width: 1000px) {
  #viewer.spreads:after {
    position: absolute;
    width: 1px;
    border-right: 1px #000 solid;
    height: 90%;
    z-index: 1;
    left: 50%;
    margin-left: -1px;
    top: 5%;
    opacity: 0.15;
    box-shadow: -2px 0 15px rgba(0, 0, 0, 1);
    content: '';
  }

  #viewer.spreads.single:after {
    display: none;
  }

  #prev {
    left: 40px;
  }

  #next {
    right: 40px;
  }
}

.arrow {
  position: fixed;
  top: 50%;
  margin-top: -32px;
  font-size: 64px;
  color: #e2e2e2;
  font-family: arial, sans-serif;
  font-weight: bold;
  cursor: pointer;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
  text-decoration: none;
}

.navlink {
  margin: 14px;
  display: block;
  text-align: center;
  text-decoration: none;
  color: #ccc;
}

.arrow:hover,
.navlink:hover {
  color: #777;
}

.arrow:active,
.navlink:hover {
  color: #000;
}

#book-wrapper {
  width: 480px;
  height: 640px;
  overflow: hidden;
  border: 1px solid #ccc;
  margin: 28px auto;
  background: #fff;
  border-radius: 0 5px 5px 0;
  position: absolute;
}

#book-viewer {
  width: 480px;
  height: 660px;
  margin: -30px auto;
  -moz-box-shadow: inset 10px 0 20px rgba(0, 0, 0, 0.1);
  -webkit-box-shadow: inset 10px 0 20px rgba(0, 0, 0, 0.1);
  box-shadow: inset 10px 0 20px rgba(0, 0, 0, 0.1);
}

#book-viewer iframe {
  padding: 40px 40px;
}

#controls {
  position: absolute;
  bottom: 16px;
  left: 50%;
  width: 400px;
  margin-left: -200px;
  text-align: center;
  display: none;
}

#controls > input[type='range'] {
  width: 400px;
}

#navigation {
  width: 400px;
  height: 100vh;
  position: absolute;
  overflow: auto;
  top: 0;
  left: 0;
  background: #777;
  -webkit-transition: -webkit-transform 0.25s ease-out;
  -moz-transition: -moz-transform 0.25s ease-out;
  -ms-transition: -moz-transform 0.25s ease-out;
  transition: transform 0.25s ease-out;
}

#navigation.fixed {
  position: fixed;
}

#navigation h1 {
  width: 200px;
  font-size: 16px;
  font-weight: normal;
  color: #fff;
  margin-bottom: 10px;
}

#navigation h2 {
  font-size: 14px;
  font-weight: normal;
  color: #b0b0b0;
  margin-bottom: 20px;
}

#navigation ul {
  padding-left: 36px;
  margin-left: 0;
  margin-top: 12px;
  margin-bottom: 12px;
  width: 340px;
}

#navigation ul li {
  list-style: decimal;
  margin-bottom: 10px;
  color: #cccddd;
  font-size: 12px;
  padding-left: 0;
  margin-left: 0;
}

#navigation ul li a {
  color: #ccc;
  text-decoration: none;
}

#navigation ul li a:hover {
  color: #fff;
  text-decoration: underline;
}

#navigation ul li a.active {
  color: #fff;
}

#navigation #cover {
  display: block;
  margin: 24px auto;
}

#navigation #closer {
  position: absolute;
  top: 0;
  right: 0;
  padding: 12px;
  color: #cccddd;
  width: 24px;
}

#navigation.closed {
  -webkit-transform: translate(-400px, 0);
  -moz-transform: translate(-400px, 0);
  -ms-transform: translate(-400px, 0);
  transform: translate(-400px, 0);
}

svg {
  display: block;
}

.close-x {
  stroke: #cccddd;
  fill: transparent;
  stroke-linecap: round;
  stroke-width: 5;
}

.close-x:hover {
  stroke: #fff;
}

#opener {
  position: absolute;
  top: 0;
  left: 0;
  padding: 10px;
  stroke: #e2e2e2;
  fill: #e2e2e2;
}

#opener:hover {
  stroke: #777;
  fill: #777;
}

</code>

packages\epubjs\examples\highlights.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Highlights Example</title>

  <script src="../dist/epub.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">

  <style type="text/css">
    ::selection {
      background: yellow;
    }

    #extras {
      width: 600px;
      margin: 40px auto;
    }

    #highlights {
      list-style: none;
      margin-left: 0;
      padding: 0;
    }

    #highlights li {
      list-style: none;
      margin-bottom: 20px;
      border-top: 1px solid #E2E2E2;
      padding: 10px;
    }

    #highlights a {
      display: block;
    }

    #viewer.spreads {
      top: 0;
      margin-top: 50px;
    }

    [ref="epubjs-mk"] {
      background: url("data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPScxLjEnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgeG1sbnM6eGxpbms9J2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnIHg9JzBweCcgeT0nMHB4JyB2aWV3Qm94PScwIDAgNzUgNzUnPjxnIGZpbGw9JyNCREJEQkQnIGlkPSdidWJibGUnPjxwYXRoIGNsYXNzPSdzdDAnIGQ9J00zNy41LDkuNEMxOS42LDkuNCw1LDIwLjUsNSwzNC4zYzAsNS45LDIuNywxMS4zLDcuMSwxNS42TDkuNiw2NS42bDE5LTcuM2MyLjgsMC42LDUuOCwwLjksOC45LDAuOSBDNTUuNSw1OS4yLDcwLDQ4LjEsNzAsMzQuM0M3MCwyMC41LDU1LjQsOS40LDM3LjUsOS40eicvPjwvZz48L3N2Zz4=") no-repeat;
      width: 20px;
      height: 20px;
      cursor: pointer;
      margin-left: 0;
    }

  </style>
</head>
<body>
  <div id="frame">
    <div id="viewer" class="spreads"></div>
    <a id="prev" href="#prev" class="arrow">‹</a>
    <a id="next" href="#next" class="arrow">›</a>
  </div>
  <div id="extras">
    <ul id="highlights"></ul>
  </div>

  <script>
    // Load the opf
    var book = ePub("https://s3.amazonaws.com/moby-dick/OPS/package.opf");

    var rendition = book.renderTo("viewer", {
      width: "100%",
      height: 600,
      ignoreClass: 'annotator-hl',
      manager: "continuous"
    });

    var displayed = rendition.display(6);

    // Navigation loaded
    book.loaded.navigation.then(function(toc){
      // console.log(toc);
    });

    var next = document.getElementById("next");
    next.addEventListener("click", function(){
      rendition.next();
    }, false);

    var prev = document.getElementById("prev");
    prev.addEventListener("click", function(){
      rendition.prev();
    }, false);

    var keyListener = function(e){

      // Left Key
      if ((e.keyCode || e.which) == 37) {
        rendition.prev();
      }

      // Right Key
      if ((e.keyCode || e.which) == 39) {
        rendition.next();
      }

    };

    rendition.on("keyup", keyListener);
    document.addEventListener("keyup", keyListener, false);

    rendition.on("relocated", function(location){
      // console.log(location);
    });


    // Apply a class to selected text
    rendition.on("selected", function(cfiRange, contents) {
      rendition.annotations.highlight(cfiRange, {}, (e) => {
        console.log("highlight clicked", e.target);
      });
      contents.window.getSelection().removeAllRanges();

    });

    this.rendition.themes.default({
      '::selection': {
        'background': 'rgba(255,255,0, 0.3)'
      },
      '.epubjs-hl' : {
        'fill': 'yellow', 'fill-opacity': '0.3', 'mix-blend-mode': 'multiply'
      }
    });

    // Illustration of how to get text from a saved cfiRange
    var highlights = document.getElementById('highlights');

    rendition.on("selected", function(cfiRange) {

      book.getRange(cfiRange).then(function (range) {
        var text;
        var li = document.createElement('li');
        var a = document.createElement('a');
        var remove = document.createElement('a');
        var textNode;

        if (range) {
          text = range.toString();
          textNode = document.createTextNode(text);

          a.textContent = cfiRange;
          a.href = "#" + cfiRange;
          a.onclick = function () {
            rendition.display(cfiRange);
          };

          remove.textContent = "remove";
          remove.href = "#" + cfiRange;
          remove.onclick = function () {
            rendition.annotations.remove(cfiRange);
            return false;
          };

          li.appendChild(a);
          li.appendChild(textNode);
          li.appendChild(remove);
          highlights.appendChild(li);
        }

      })

    });

  </script>

</body>
</html>

</code>

packages\epubjs\examples\hooks.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Single Example</title>

  <script src="../dist/epub.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">

</head>
<body>
  <a id="prev" href="#prev" class="navlink">...</a>
  <div id="viewer" class="scrolled"></div>
  <a id="next" href="#next" class="navlink">...</a>

  <script>
    var currentSectionIndex = 8;
    // Load the opf
    var book = ePub("https://s3.amazonaws.com/epubjs/books/moby-dick/OPS/package.opf");
    var rendition = book.renderTo("viewer", { flow: "scrolled-doc" });

    rendition.display("chapter_001.xhtml");


    var next = document.getElementById("next");
    next.addEventListener("click", function(e){
      rendition.next();
      e.preventDefault();
    }, false);

    var prev = document.getElementById("prev");
    prev.addEventListener("click", function(e){
      rendition.prev();
      e.preventDefault();
    }, false);



    rendition.on("rendered", function(section){
      var nextSection = section.next();
      var prevSection = section.prev();

      if(nextSection) {
        nextNav = book.navigation.get(nextSection.href);

        if(nextNav) {
          nextLabel = nextNav.label;
        } else {
          nextLabel = "next";
        }

        next.textContent = nextLabel + " »";
      } else {
        next.textContent = "";
      }

      if(prevSection) {
        prevNav = book.navigation.get(prevSection.href);

        if(prevNav) {
          prevLabel = prevNav.label;
        } else {
          prevLabel = "previous";
        }

        prev.textContent = "« " + prevLabel;
      } else {
        prev.textContent = "";
      }

    });

    // Hooks

    // Add a single script
    rendition.hooks.content.register(function(contents){
     return contents.addScript("https://code.jquery.com/jquery-2.1.4.min.js")
       .then(function(){
            // init code
       });
    });

    // Add several scripts / css
    rendition.hooks.content.register(function(contents){

        var loaded = Promise.all([
            contents.addScript("https://code.jquery.com/jquery-2.1.4.min.js"),
            contents.addStylesheet("http://code.jquery.com/mobile/1.4.5/jquery.mobile-1.4.5.css")
        ]);

        // return loaded promise
        return loaded;
    });

  </script>

</body>
</html>

</code>

packages\epubjs\examples\hypothesis-continuous.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Continuous Example</title>

  <script src="../dist/epub.js"></script>
  <!-- <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script> -->
  <script src="//hypothes.is/embed.js"></script>

  <style type="text/css">
    body {
      margin: 0 auto;
      background: #fafafa;
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      color: #333;
      height: 100%;
      width: 100%;
      max-width: 1200px;
    }

    .epub-container {
      min-width: 320px;
      margin: 0 auto;
    }

      /*.epub-container > div {
        padding: 0 20% 0 20%;
      }*/

    .epub-container .epub-view > iframe {
        background: white;
        box-shadow: 0 0 4px #ccc;
        margin: 10px;
        padding: 20px;
    }


    #prev {
      left: 40px;
    }

    #next {
      right: 40px;
    }

    .arrow {
      position: fixed;
      top: 50%;
      margin-top: -32px;
      font-size: 64px;
      color: #E2E2E2;
      font-family: arial, sans-serif;
      font-weight: bold;
      cursor: pointer;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
    }

    .arrow:hover {
      color: #777;
    }

    .arrow:active {
      color: #000;
    }

    #toc {
      display: block;
      margin: 10px auto;
    }

  </style>
</head>
<body>
  <div id="viewer"></div>

  <script>
    // var currentSectionIndex = 8;
    // Load the opf
    var book = ePub("https://s3.amazonaws.com/epubjs/books/alice/OPS/package.opf");
    var rendition = book.renderTo(document.body, { method: "continuous", flow: "scrolled-continuous", width: "60%" });
    var displayed = rendition.display();


    displayed.then(function(renderer){
      // -- do stuff
    });

    // Navigation loaded
    book.loaded.navigation.then(function(toc){
      // console.log(toc);
    });

    book.rendition.hooks.content.register(function(view) {
      return view.addScript("//hypothes.is/embed.js").then(function() {
        view.window.hypothesisConfig = function () {

      		return {
      			constructor: this.Annotator.Guest,
              	app: 'https://hypothes.is/app.html'
      		};
      	};

        // view.window.hypothesisInstall();
      });
    });

    book.rendition.hooks.render.register(function(view) {
    	var getVisibleAnnotations = function ($) {
    		var height = document.documentElement.clientHeight;
    		return $('.annotator-hl').map(function() {
    			var $this = $(this),
              pos = view.position().top,
              top = pos + this.getBoundingClientRect().top;
    			if (top >= 0 && top <= height) {
    				return $this.data('annotation');
    			}
    		}).get();
    	};
      book.rendition.on("scroll", function() {
        var annotator = view.window.annotator;
        var annotations;
        if(annotator && annotator.constructor.$) {
          annotations = getVisibleAnnotations(annotator.constructor.$);
          annotator.showAnnotations(annotations);
        }
      });
    });

  </script>

</body>
</html>

</code>

packages\epubjs\examples\hypothesis-spreads.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js + Hypothes.is Example</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
  <script src="../dist/epub.js"></script>

  <script type="text/javascript">
    window.hypothesisConfig = function () {
      return {
        openSidebar: false,
        enableMultiFrameSupport: true,
        onLayoutChange: function(state) {
          var nav = document.getElementById("navigation");
          if (state.expanded === true) {
            nav.classList.remove("open");
          }
        }
      };
    };
  </script>
  <script src="https://cdn.hypothes.is/hypothesis"></script>

  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="hypothesis.css">

  <script src="hypothesis.js"></script>

</head>
<body>
  <div id="main">
    <a id="opener">
      <i class="material-icons">menu</i>
    </a>
    <div id="viewer" class="spreads"></div>
    <span id="hiddenTitle"></span>
    <a id="prev" href="#prev" class="arrow">
      <i class="material-icons">chevron_left</i>
    </a>
    <a id="next" href="#next" class="arrow">
      <i class="material-icons">chevron_right</i>
    </a>
  </div>
  <div id="navigation">
    <a id="closer">
      <i class="material-icons">close</i>
    </a>
    <h1 id="title">...</h1>
    <image id="cover" width="150px"/>
    <h2 id="author">...</h2>
    <ul id="toc"></ul>
  </div>

</body>
</html>

</code>

packages\epubjs\examples\hypothesis.css:
<code>
body {
  margin: 0;
  background: #fafafa;
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  color: #333;
}

svg {
  display: block;
}

.close-x {
  stroke: #cccddd;
  fill: transparent;
  stroke-linecap: round;
  stroke-width: 5;
}

.close-x:hover {
  stroke: #fff;
}

#opener {
  position: absolute;
  top: 0;
  left: 0;
  padding: 10px;
  stroke: #e2e2e2;
  fill: #e2e2e2;
}

#opener:hover {
  stroke: #777;
  fill: #777;
}

#navigation {
  width: 400px;
  position: fixed;
  overflow: auto;
  top: 0;
  left: -425px;

  background: #ececec;
  min-height: 100%;
  height: 100%;
  height: 100vh;

  overflow: scroll;
  -webkit-overflow-scrolling: touch;
  padding: 9px;
  padding-top: 10px;

  transition: left 0.2s ease-out;
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba(0, 0, 0, 0.23);
}

#navigation.open {
  left: 0;
}

#navigation.fixed {
  position: fixed;
}

#navigation h1 {
  width: 200px;
  font-size: 16px;
  font-weight: normal;
  color: #777;
  margin-bottom: 10px;
}

#navigation h2 {
  font-size: 14px;
  font-weight: normal;
  color: #b0b0b0;
  margin-bottom: 20px;
}

#navigation ul {
  padding-left: 28px;
  margin-left: 0;
}

#navigation ul li {
  list-style: decimal;
  margin-bottom: 10px;
  color: #585858;
  font-size: 12px;
  padding-left: 0;
  margin-left: 0;
}

#navigation ul li a {
  color: #585858;
  text-decoration: none;
}

#navigation ul li a:hover {
  color: #585858;
  text-decoration: underline;
}

#navigation ul li a.active {
  color: #000;
  font-weight: 400;
}

#navigation #author {
  text-align: center;
}

#cover {
  display: inline;
}

#main {
  margin-top: 60px;
}

#pagination {
  text-align: center;
  margin: 20px;
  /*padding: 0 50px;*/
}

.arrow:hover {
  color: #777;
}

.arrow:active {
  color: #000;
}

.arrow .material-icons {
  font-size: 64px;
}

#prev {
  float: left;
}

#next {
  float: right;
}

#toc {
  display: block;
  margin: 10px auto;
}

#hypothesis-custom {
  overflow: hidden;
  /*position: absolute;*/
  right: 0;
  /*top: 0;*/
  height: 100%;
  width: 200px;
  /*z-index: -2;*/
}

#hypothesis-custom iframe {
  position: absolute;
  width: 100%;
  height: 100%;
}

#navigation #cover {
  display: block;
  margin: 24px auto;
}

#closer {
  position: absolute;
  padding: 12px;
  left: 0;
  top: 0;
  color: #333;
  cursor: pointer;
}

#closer .material-icons {
  color: #333;
}

#opener {
  position: absolute;
  left: 0;
  top: 0;
  cursor: pointer;
}

#hiddenTitle {
  display: none;
}

#title {
  width: 900px;
  min-height: 18px;
  margin: 10px auto;
  text-align: center;
  font-size: 16px;
  color: #e2e2e2;
  font-weight: 400;
}

#title:hover {
  color: #777;
}

#prev {
  left: 0;
}

#next {
  right: 0;
}

#toc {
  display: block;
  margin: 10px auto;
}

@media (min-width: 1000px) {
  #viewer.spreads:after {
    position: absolute;
    width: 1px;
    border-right: 1px #000 solid;
    height: 90%;
    z-index: 1;
    left: 50%;
    margin-left: -1px;
    top: 5%;
    opacity: 0.15;
    box-shadow: -2px 0 15px rgba(0, 0, 0, 1);
    content: '';
  }

  #prev {
    left: 40px;
  }

  #next {
    right: 40px;
  }
}

#viewer.spreads {
  width: 84vw;
  height: 80vh;
  box-shadow: 0 0 4px #ccc;
  border-radius: 5px;
  padding: 0;
  position: relative;
  margin: 10vh auto;
  background: white;
  top: 0;
}

.arrow {
  position: fixed;
  top: 50%;
  margin-top: -32px;
  font-size: 64px;
  color: #e2e2e2;
  font-family: arial, sans-serif;
  font-weight: bold;
  cursor: pointer;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
  text-decoration: none;
}

.navlink {
  margin: 14px;
  display: block;
  text-align: center;
  text-decoration: none;
  color: #ccc;
}

.arrow:hover,
.navlink:hover {
  color: #777;
}

.arrow:active,
.navlink:hover {
  color: #000;
}

#book-wrapper {
  width: 480px;
  height: 640px;
  overflow: hidden;
  border: 1px solid #ccc;
  margin: 28px auto;
  background: #fff;
  border-radius: 0 5px 5px 0;
  position: absolute;
}

#book-viewer {
  width: 480px;
  height: 660px;
  margin: -30px auto;
  -moz-box-shadow: inset 10px 0 20px rgba(0, 0, 0, 0.1);
  -webkit-box-shadow: inset 10px 0 20px rgba(0, 0, 0, 0.1);
  box-shadow: inset 10px 0 20px rgba(0, 0, 0, 0.1);
}

#book-viewer iframe {
  padding: 40px 40px;
}

#controls {
  position: absolute;
  bottom: 16px;
  left: 50%;
  width: 400px;
  margin-left: -200px;
  text-align: center;
  display: none;
}

#controls > input[type='range'] {
  width: 400px;
}

</code>

packages\epubjs\examples\hypothesis.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js + Hypothes.is Example</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
  <script src="../dist/epub.js"></script>

  <!-- <script>
  window.hypothesisConfig = function () {
    return {
      // constructor: this.Annotator.Sidebar,
      app: 'https://hypothes.is/app.html',
    };
  };
  </script> -->

  <script type="text/javascript">
    window.hypothesisConfig = function () {
      return {
        openSidebar: false,
        enableMultiFrameSupport: true,
        onLayoutChange: function(state) {
          var main = document.querySelector('#main');
          if (state.expanded === true) {
            main.classList.add("open");
          } else {
            main.classList.remove("open");
          }
        }
      };
    };
  </script>
  <script src="https://cdn.hypothes.is/hypothesis"></script>

  <style type="text/css">
    body {
      margin: 0;
      background: #fafafa;
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      color: #333;
    }

    #navigation {
      width: 300px;
      position: absolute;
      overflow: auto;
      top: 60px;
      left: 1000px
    }

    #navigation.fixed {
      position: fixed;
    }

    #navigation h1 {
      width: 200px;
      font-size: 16px;
      font-weight: normal;
      color: #777;
      margin-bottom: 10px;
    }

    #navigation h2 {
      font-size: 14px;
      font-weight: normal;
      color: #B0B0B0;
      margin-bottom: 20px;
    }

    #navigation ul {
      padding-left: 18px;
      margin-left: 0;
    }

    #navigation ul li {
      list-style: decimal;
      margin-bottom: 10px;
      color: #cccddd;
      font-size: 12px;
      padding-left: 0;
      margin-left: 0;
    }

    #navigation ul li a {
      color: #ccc;
      text-decoration: none;
    }

    #navigation ul li a:hover {
      color: #777;
      text-decoration: underline;
    }

    #navigation ul li a.active {
      color: #000;
    }

    #viewer {
      overflow: hidden;
      width: 620px;
      margin: 0 50px;
      /*background: url('ajax-loader.gif') center center no-repeat;*/
      background-color: white;
      box-shadow: 0 0 4px #ccc;
      margin: 20px;
      padding: 40px 80px;
    }

    #main {
      position: absolute;
      top: 50px;
      left: 100px;
      width: 800px;
      z-index: 2;
      transition: left .15s cubic-bezier(.55, 0, .2, .8) .08s;
    }

    #main.open {
      left: 0;
    }

    #pagination {
      text-align: center;
      margin: 20px;
      /*padding: 0 50px;*/
    }

    .arrow {
      margin: 14px;
      display: inline-block;
      text-align: center;
      text-decoration: none;
      color: #ccc;
    }

    .arrow:hover {
      color: #777;
    }

    .arrow:active {
      color: #000;
    }

    #prev {
      float: left;
    }

    #next {
      float: right;
    }

    #toc {
      display: block;
      margin: 10px auto;
    }

    #hypothesis-custom {
      overflow: hidden;
      /*position: absolute;*/
      right: 0;
      /*top: 0;*/
      height: 100%;
      width: 200px;
      /*z-index: -2;*/
    }

    #hypothesis-custom iframe {
      position: absolute;
      width: 100%;
      height: 100%;
    }

  </style>
</head>
<body>
  <div id="navigation">
    <h1 id="title">...</h1>
    <image id="cover" width="150px"/>
    <h2 id="author">...</h2>
    <ul id="toc"></ul>
  </div>
  <div id="main">
    <div id="viewer"></div>
    <div id="pagination">
      <a id="prev" href="#prev" class="arrow">...</a>
      <a id="next" href="#next" class="arrow">...</a>
    </div>
  </div>

  <script>
    // Load the opf
    var params = URLSearchParams && new URLSearchParams(document.location.search.substring(1));
    var url = params && params.get("url") && decodeURIComponent(params.get("url"));

    // Load the opf
    var book = ePub(url || window.location.protocol + "//s3.amazonaws.com/epubjs.org/books/moby-dick-hypothesis-demo.epub");
    var rendition = book.renderTo("viewer", {
      flow: "scrolled-doc",
      ignoreClass: "annotator-hl"
    });

    // var hash = window.location.hash.slice(2);
    var loc = window.location.href.indexOf("?loc=");
    if (loc > -1) {
      var href =  window.location.href.slice(loc + 5);
      var hash = decodeURIComponent(href);
    }
    rendition.display(hash || undefined);


    var next = document.getElementById("next");
    next.addEventListener("click", function(e){
      window.scrollTo(0,0);
      rendition.next();
      e.preventDefault();
    }, false);

    var prev = document.getElementById("prev");
    prev.addEventListener("click", function(e){
      window.scrollTo(0,0);
      rendition.prev();
      e.preventDefault();
    }, false);

    rendition.on("rendered", function(section){
      var nextSection = section.next();
      var prevSection = section.prev();

      if(nextSection) {
        nextNav = book.navigation.get(nextSection.href);

        if(nextNav) {
          nextLabel = nextNav.label;
        } else {
          nextLabel = "next";
        }

        next.textContent = nextLabel + " »";
      } else {
        next.textContent = "";
      }

      if(prevSection) {
        prevNav = book.navigation.get(prevSection.href);

        if(prevNav) {
          prevLabel = prevNav.label;
        } else {
          prevLabel = "previous";
        }

        prev.textContent = "« " + prevLabel;
      } else {
        prev.textContent = "";
      }

      var old = document.querySelectorAll('.active');
      Array.prototype.slice.call(old, 0).forEach(function (link) {
        link.classList.remove("active");
      })

      var active = document.querySelector('a[href="'+section.href+'"]');
      if (active) {
        active.classList.add("active");
      }
      // Add CFI fragment to the history
      history.pushState({}, '', "?loc=" + encodeURIComponent(section.href));
      // window.location.hash = "#/"+section.href
    });

    book.loaded.navigation.then(function(toc){
      var $nav = document.getElementById("toc"),
          docfrag = document.createDocumentFragment();

      toc.forEach(function(chapter, index) {
        var item = document.createElement("li");
        var link = document.createElement("a");
        link.id = "chap-" + chapter.id;
        link.textContent = chapter.label;
        link.href = chapter.href;
        item.appendChild(link);
        docfrag.appendChild(item);

        link.onclick = function(){
          var url = link.getAttribute("href");
          console.log(url)
          rendition.display(url);
          return false;
        };

      });

      $nav.appendChild(docfrag);


    });

    book.loaded.metadata.then(function(meta){
      var $title = document.getElementById("title");
      var $author = document.getElementById("author");
      var $cover = document.getElementById("cover");
      var $nav = document.getElementById('navigation');

      $title.textContent = meta.title;
      $author.textContent = meta.creator;
      if (book.archive) {
        book.archive.createUrl(book.cover)
          .then(function (url) {
            $cover.src = url;
          })
      } else {
        $cover.src = book.cover;
      }

      if ($nav.offsetHeight + 60 < window.innerHeight) {
        $nav.classList.add("fixed");
      }

    });

    function checkForAnnotator(cb, w) {
     if (!w) {
       w = window;
     }
     setTimeout(function () {
        if (w && w.annotator) {
          cb();
        } else {
          checkForAnnotator(cb, w);
        }
      }, 100);
    }

    book.rendition.hooks.content.register(function(contents, view) {

        checkForAnnotator(function () {

          var annotator = contents.window.annotator;

          contents.window.addEventListener('scrolltorange', function (e) {
            var range = e.detail;
            var cfi = new ePub.CFI(range, contents.cfiBase).toString();
            if (cfi) {
              book.rendition.display(cfi);
            }
            e.preventDefault();
          });


          annotator.on("highlightClick", function (annotation) {
            console.log(annotation);
            window.annotator.show();
          })

          annotator.on("beforeAnnotationCreated", function (annotation) {
            console.log(annotation);
            window.annotator.show();
          })

        }, contents.window);

    });
  </script>

</body>
</html>

</code>

packages\epubjs\examples\hypothesis.js:
<code>
(function () {
  function start() {
    var params =
      URLSearchParams &&
      new URLSearchParams(document.location.search.substring(1))
    var url =
      params && params.get('url') && decodeURIComponent(params.get('url'))
    var defaultUrl =
      window.location.protocol +
      '//s3.amazonaws.com/epubjs.org/books/moby-dick-hypothesis-demo.epub'
    // Load the opf
    var book = ePub(url || defaultUrl, {
      canonical: function (path) {
        var url = window.location.href.replace(/loc=([^&]*)/, 'loc=' + path)
        return url
      },
    })
    var rendition = book.renderTo('viewer', {
      ignoreClass: 'annotator-hl',
      width: '100%',
      height: '100%',
    })

    // var hash = window.location.hash.slice(2);
    var loc = window.location.href.indexOf('?loc=')
    if (loc > -1) {
      var href = window.location.href.slice(loc + 5)
      var hash = decodeURIComponent(href)
    }

    rendition.display(hash || undefined)

    var next = document.getElementById('next')
    next.addEventListener(
      'click',
      function (e) {
        rendition.next()
        e.preventDefault()
      },
      false,
    )

    var prev = document.getElementById('prev')
    prev.addEventListener(
      'click',
      function (e) {
        rendition.prev()
        e.preventDefault()
      },
      false,
    )

    var nav = document.getElementById('navigation')
    var opener = document.getElementById('opener')
    opener.addEventListener(
      'click',
      function (e) {
        nav.classList.add('open')
      },
      false,
    )

    var closer = document.getElementById('closer')
    closer.addEventListener(
      'click',
      function (e) {
        nav.classList.remove('open')
      },
      false,
    )

    // Hidden
    var hiddenTitle = document.getElementById('hiddenTitle')

    rendition.on('rendered', function (section) {
      var current = book.navigation && book.navigation.get(section.href)

      if (current) {
        document.title = current.label
      }

      // TODO: this is needed to trigger the hypothesis client
      // to inject into the iframe
      requestAnimationFrame(function () {
        hiddenTitle.textContent = section.href
      })

      var old = document.querySelectorAll('.active')
      Array.prototype.slice.call(old, 0).forEach(function (link) {
        link.classList.remove('active')
      })

      var active = document.querySelector('a[href="' + section.href + '"]')
      if (active) {
        active.classList.add('active')
      }

      let urlParam = params && params.get('url')
      let url = ''
      if (urlParam) {
        url = 'url=' + urlParam + '&'
      }
      // Add CFI fragment to the history
      history.pushState(
        {},
        '',
        '?' + url + 'loc=' + encodeURIComponent(section.href),
      )
      // window.location.hash = "#/"+section.href
    })

    var keyListener = function (e) {
      // Left Key
      if ((e.keyCode || e.which) == 37) {
        rendition.prev()
      }

      // Right Key
      if ((e.keyCode || e.which) == 39) {
        rendition.next()
      }
    }

    rendition.on('keyup', keyListener)
    document.addEventListener('keyup', keyListener, false)

    book.loaded.navigation.then(function (toc) {
      var $nav = document.getElementById('toc'),
        docfrag = document.createDocumentFragment()

      var processTocItem = function (chapter, parent) {
        var item = document.createElement('li')
        var link = document.createElement('a')
        link.id = 'chap-' + chapter.id
        link.textContent = chapter.label
        link.href = chapter.href
        item.appendChild(link)
        parent.appendChild(item)

        if (chapter.subitems.length) {
          var ul = document.createElement('ul')
          item.appendChild(ul)
          chapter.subitems.forEach(function (subchapter) {
            processTocItem(subchapter, ul)
          })
        }

        link.onclick = function () {
          var url = link.getAttribute('href')
          console.log(url)
          rendition.display(url)
          return false
        }
      }

      toc.forEach(function (chapter) {
        processTocItem(chapter, docfrag)
      })

      $nav.appendChild(docfrag)
    })

    book.loaded.metadata.then(function (meta) {
      var $title = document.getElementById('title')
      var $author = document.getElementById('author')
      var $cover = document.getElementById('cover')
      var $nav = document.getElementById('navigation')

      $title.textContent = meta.title
      $author.textContent = meta.creator
      if (book.archive) {
        book.archive.createUrl(book.cover).then(function (url) {
          $cover.src = url
        })
      } else {
        $cover.src = book.cover
      }

      // if ($nav.offsetHeight + 60 < window.innerHeight) {
      //   $nav.classList.add("fixed");
      // }
    })

    var tm
    function checkForAnnotator(cb, w) {
      if (!w) {
        w = window
      }
      tm = setTimeout(function () {
        if (w && w.annotator) {
          clearTimeout(tm)
          cb()
        } else {
          checkForAnnotator(cb, w)
        }
      }, 100)
    }

    book.rendition.hooks.content.register(function (contents, view) {
      checkForAnnotator(function () {
        var annotator = contents.window.annotator

        contents.window.addEventListener('scrolltorange', function (e) {
          var range = e.detail
          var cfi = new ePub.CFI(range, contents.cfiBase).toString()
          if (cfi) {
            book.rendition.display(cfi)
          }
          e.preventDefault()
        })

        annotator.on('highlightClick', function (annotation) {
          console.log(annotation)
          window.annotator.show()
        })

        annotator.on('beforeAnnotationCreated', function (annotation) {
          console.log(annotation)
          window.annotator.show()
        })
      }, contents.window)
    })
  }

  document.addEventListener('DOMContentLoaded', start, false)
})()

</code>

packages\epubjs\examples\index.html:
<code>
<!DOCTYPE html>
<html class="no-js">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>ePubJS Examples</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <style type="text/css">

          body {
            margin: 0;
			background: #fafafa;
			font-family: serif;
			color: #333;
			position: absolute;
			height: 100%;
			width: 100%;
			min-height: 800px;
          }

          h1 {
            text-align: center;
            font-size: 1.5em;
            line-height: 1.33em;
            text-align: center;
            padding-bottom: 0em;
            text-align: center;
            text-transform: uppercase;
            font-weight: normal;
            letter-spacing: 4px;
            padding-top: 60px;
          }

          ol {
            margin: 28px auto;
          }

          a {
            font-size: 1.2em;
            line-height: 1.33em;
            color: #000;
          }

          #main {
			width: 100%
		  }
		  
		  #example-wrapper {
            width: 695px;
			overflow: hidden;
            border: 1px solid #ccc;
            margin: 28px auto;
            background: #fff;
            border-radius: 5px;
          }
              
          #example-viewer {
            width: 680px;
			height: 100%;
            margin: -30px 10px 0 0;
            -moz-box-shadow:      inset 10px 0 20px rgba(0,0,0,.1);
            -webkit-box-shadow:   inset 10px 0 20px rgba(0,0,0,.1);
            box-shadow:           inset 10px 0 20px rgba(0,0,0,.1);
          }
        </style>


    </head>
    <body>
        <div id="main">  
		  <div id="example-wrapper">
            <div id="example-viewer">

              <h1>Examples</h1>
              <ol>
                <li><a href="spreads.html">Spreads</a><p>
				Display an ebook two pages at a time. Also includes code to provide table-of-contents in a select object above the rendered ebook.  Sections of the ebook are displayed separately so if a section has a single page or an odd number of pages it will display with a blank page on the right.</p></li>
                <li><a href="archived.html">Archived</a><p>
				Display ebook from an XXXX.epub file rather than an unzipped folder. This may be substantially slower for large ebooks.</p></li>
                <li><a href="scrolled.html">Scrolled Doc</a><p>
				Displays each "section" or "chapter" of the ebook in its entirety as a single page of variable height that you can scroll up and down. Includes code to provide navigation links above and below the rendered section to go to the previous or next section.</p></li>
                <li><a href="continuous-spreads.html">Spreads Continuous</a><p>
				The view is the same as 1) above except that the entire document is rendered at once without breaks so if a section has one page, the next section is shown beginning on the right-hand-page rather than a blank page. </p></li>
                <li><a href="continuous-scrolled.html">Scrolled Continuous</a><p>
				The view is the same as 3) except the entire ebook is rendered in the browser at once so there are no navigation links above and below each chapter. This version may take longer to render and uses more memory since the whole ebook is loaded into memory. This version has no links to navigate or jump between chapters.</p></li>
                <li><a href="swipe.html">Swipe</a><p>
				This example includes a function in the script to link "swipe" events on touchscreens, particularly mobile devices, to navigate forward and back. Note that swipes do not work in Chrome Desktop even if you turn on device emulation in the "inspect" toolbar. </p></li>
                <li><a href="input.html">Open from File</a><p>
				Allows you to select an epub file from your local computer that gets rendered in the browser.</p></li>
                <li><a href="renderless.html">Renderless</a><p>
				The name for this example is misleading since the book certainly does render. What's unique in this example is that the book's table of contents is read in and a list of sections in developed, then each section is rendered as it is called for by a section.render() call, but there's no master book.renderTo() call.  Functionlly this seems exactly the same as 1) and 3).</p></li>
                <li><a href="hooks.html">Hooks</a><p>
				This example shows how to insert external javascript and external css files into a book after the book has been loaded into memory.  This might, for example, allow you to override internal css from the ebook to change fonts and text-size by either replacing a css file from the ebook or calling a javascript that gets added to the inside of the ebook such as adding jQuery inside the ebook.  For example: this could be used to have + and - buttons that increase or decrease the font-size in the ebook. When the + or - button is pressed it could call to insert and execute a script to replace the font-size of paragraph elements with one slightly larger or smaller.  This example doesn't actually implement any such thing, it just shows how to insert the code, or insert a css file.</p><p>
				You can't just run a script on the outer page to change things inside the rendered ebook because the ebook is rendered inside an iframe. This mechanism lets you inject things into the iframe and run them after the book is rendered.</p></li>
                <li><a href="highlights.html">Highlights</a><p>
				Adds the ability to highlight text in the ebook. This version provides no mechanism for saving highlights after the browser is closed. It is an example of capability rather than a working implementation. It works as follows: When a section of text is selected a rendition.on("selected"...) function notes the location of the beginning and ending of the selected text.  Two things happen. The code adds a new element to the outer page in a list at the bottom describing the selection and providing a "remove" link. The code also paints a yellow block in an SVG overlay to highlight the selected text. Unfortunately as of 5/14/2019 the remove link does remove the yellow overlay from the highlighted text but, does not remove the annotation from the list at the bottom of the page.</p></li>
                <li><a href="hypothesis.html">Hypothes.is</a><p>
				Visit their site for an explanation at <a href="https://web.hypothes.is/demos/epubjs/">https://web.hypothes.is/demos/epubjs/</a>.</p></li>
              </ol>

            </div>
          </div>
		</div>
    </body>
</html>

</code>

packages\epubjs\examples\input.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Input Example</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
  <script src="../dist/epub.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">

</head>
<body>
  <div id="title"><input type="file" id="input"></div>
  <div id="viewer" class="spreads"></div>
  <a id="prev" href="#prev" class="arrow">‹</a>
  <a id="next" href="#next" class="arrow">›</a>

  <script>

  var book = ePub();
  var rendition;

  var inputElement = document.getElementById("input");

  inputElement.addEventListener('change', function (e) {
        var file = e.target.files[0];
        if (window.FileReader) {
            var reader = new FileReader();
            reader.onload = openBook;
            reader.readAsArrayBuffer(file);
        }
    });

  function openBook(e){
    var bookData = e.target.result;
    var title = document.getElementById("title");
    var next = document.getElementById("next");
    var prev = document.getElementById("prev");

    book.open(bookData, "binary");

    rendition = book.renderTo("viewer", {
      width: "100%",
      height: 600
    });

    rendition.display();
	
	var keyListener = function(e){

      // Left Key
      if ((e.keyCode || e.which) == 37) {
        rendition.prev();
      }

      // Right Key
      if ((e.keyCode || e.which) == 39) {
        rendition.next();
      }

    };

    rendition.on("keyup", keyListener);
    rendition.on("relocated", function(location){
      console.log(location);
    });

    next.addEventListener("click", function(e){
      rendition.next();
      e.preventDefault();
    }, false);

    prev.addEventListener("click", function(e){
      rendition.prev();
      e.preventDefault();
    }, false);

    


    document.addEventListener("keyup", keyListener, false);
  }



  </script>

</body>
</html>

</code>

packages\epubjs\examples\legacy.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Spreads Example</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
  <script src="../dist/epub.legacy.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">

</head>
<body>
  <!-- <div id="title"></div> -->
  <select id="toc"></select>
  <div id="viewer" class="spreads"></div>
  <a id="prev" href="#prev" class="arrow">‹</a>
  <a id="next" href="#next" class="arrow">›</a>

  <script>
    var params = URLSearchParams && new URLSearchParams(document.location.search.substring(1));
    var url = params && params.get("url") && decodeURIComponent(params.get("url"));
    var currentSectionIndex = (params && params.get("loc")) ? params.get("loc") : undefined;

    // Load the opf
    var book = ePub(url || "https://s3.amazonaws.com/moby-dick/moby-dick.epub");
    var rendition = book.renderTo("viewer", {
      width: "100%",
      height: 600,
      spread: "always"
    });

    rendition.display(currentSectionIndex);

    book.ready.then(function() {

      var next = document.getElementById("next");

      next.addEventListener("click", function(e){
        book.package.metadata.direction === "rtl" ? rendition.prev() : rendition.next();
        e.preventDefault();
      }, false);

      var prev = document.getElementById("prev");
      prev.addEventListener("click", function(e){
        book.package.metadata.direction === "rtl" ? rendition.next() : rendition.prev();
        e.preventDefault();
      }, false);

      var keyListener = function(e){

        // Left Key
        if ((e.keyCode || e.which) == 37) {
          book.package.metadata.direction === "rtl" ? rendition.next() : rendition.prev();
        }

        // Right Key
        if ((e.keyCode || e.which) == 39) {
          book.package.metadata.direction === "rtl" ? rendition.prev() : rendition.next();
        }

      };

      rendition.on("keyup", keyListener);
      document.addEventListener("keyup", keyListener, false);

    })

    var title = document.getElementById("title");

    rendition.on("rendered", function(section){
      var current = book.navigation && book.navigation.get(section.href);

      if (current) {
        var $select = document.getElementById("toc");
        var $selected = $select.querySelector("option[selected]");
        if ($selected) {
          $selected.removeAttribute("selected");
        }

        var $options = $select.querySelectorAll("option");
        for (var i = 0; i < $options.length; ++i) {
          let selected = $options[i].getAttribute("ref") === current.href;
          if (selected) {
            $options[i].setAttribute("selected", "");
          }
        }
      }

    });

    rendition.on("relocated", function(location){
      console.log(location);

      var next = book.package.metadata.direction === "rtl" ?  document.getElementById("prev") : document.getElementById("next");
      var prev = book.package.metadata.direction === "rtl" ?  document.getElementById("next") : document.getElementById("prev");

      if (location.atEnd) {
        next.style.visibility = "hidden";
      } else {
        next.style.visibility = "visible";
      }

      if (location.atStart) {
        prev.style.visibility = "hidden";
      } else {
        prev.style.visibility = "visible";
      }

    });

    rendition.on("layout", function(layout) {
      let viewer = document.getElementById("viewer");

      if (layout.spread) {
        viewer.classList.remove('single');
      } else {
        viewer.classList.add('single');
      }
    });

    window.addEventListener("unload", function () {
      console.log("unloading");
      this.book.destroy();
    });

    book.loaded.navigation.then(function(toc){
			var $select = document.getElementById("toc"),
					docfrag = document.createDocumentFragment();

			toc.forEach(function(chapter) {
				var option = document.createElement("option");
				option.textContent = chapter.label;
				option.setAttribute("ref", chapter.href);

				docfrag.appendChild(option);
			});

			$select.appendChild(docfrag);

			$select.onchange = function(){
					var index = $select.selectedIndex,
							url = $select.options[index].getAttribute("ref");
					rendition.display(url);
					return false;
			};

		});




  </script>

</body>
</html>

</code>

packages\epubjs\examples\locations.html:
<code>
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>EPUB.js Spreads Example</title>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
	<script src="../dist/epub.js"></script>

	<link rel="stylesheet" type="text/css" href="examples.css">

</head>
<body>
	<div id="title"></div>
	<div id="viewer" class="spreads"></div>
	<a id="prev" href="#prev" class="arrow">‹</a>
	<a id="next" href="#next" class="arrow">›</a>
	<div id="controls">
			<input id="current-percent" size="3" value="0" /> %
	</div>
	<script>

		var controls = document.getElementById("controls");
		var currentPage = document.getElementById("current-percent");
		var slider = document.createElement("input");
		var slide = function(){
				var cfi = book.locations.cfiFromPercentage(slider.value / 100);
				rendition.display(cfi);
		};
		var mouseDown = false;

		// Load the opf
		var book = ePub("https://s3.amazonaws.com/moby-dick/moby-dick.epub");
		var rendition = book.renderTo("viewer", {
			width: "100%",
			height: 600
		});

		var displayed = rendition.display();

		var title = document.getElementById("title");

		var next = document.getElementById("next");
		next.addEventListener("click", function(e){
			rendition.next();
			e.preventDefault();
		}, false);

		var prev = document.getElementById("prev");
		prev.addEventListener("click", function(e){
			rendition.prev();
			e.preventDefault();
		}, false);

		var keyListener = function(e){

			// Left Key
			if ((e.keyCode || e.which) == 37) {
				rendition.prev();
			}

			// Right Key
			if ((e.keyCode || e.which) == 39) {
				rendition.next();
			}

		};

		rendition.on("keyup", keyListener);
		document.addEventListener("keyup", keyListener, false);

		book.ready.then(function(){
			// Load in stored locations from json or local storage
			var key = book.key()+'-locations';
			var stored = localStorage.getItem(key);
			if (stored) {
				 return book.locations.load(stored);
			} else {
				// Or generate the locations on the fly
				// Can pass an option number of chars to break sections by
				// default is 150 chars
				return book.locations.generate(1600);
			}
		})
		.then(function(locations){
				controls.style.display = "block";
				slider.setAttribute("type", "range");
				slider.setAttribute("min", 0);
				slider.setAttribute("max", 100);
				// slider.setAttribute("max", book.locations.total+1);
				slider.setAttribute("step", 1);
				slider.setAttribute("value", 0);

				slider.addEventListener("change", slide, false);
				slider.addEventListener("mousedown", function(){
						mouseDown = true;
				}, false);
				slider.addEventListener("mouseup", function(){
						mouseDown = false;
				}, false);

				// Wait for book to be rendered to get current page
				displayed.then(function(){
						// Get the current CFI
						var currentLocation = rendition.currentLocation();
						// Get the Percentage (or location) from that CFI
						var currentPage = book.locations.percentageFromCfi(currentLocation.start.cfi);
						slider.value = currentPage;
						currentPage.value = currentPage;
				});

				controls.appendChild(slider);

				currentPage.addEventListener("change", function(){
					var cfi = book.locations.cfiFromPercentage(currentPage.value/100);
					rendition.display(cfi);
				}, false);

				// Listen for location changed event, get percentage from CFI
				rendition.on('relocated', function(location){
						var percent = book.locations.percentageFromCfi(location.start.cfi);
						var percentage = Math.floor(percent * 100);
						if(!mouseDown) {
								slider.value = percentage;
						}
						currentPage.value = percentage;
						console.log(location);
				});

				// Save out the generated locations to JSON
				localStorage.setItem(book.key()+'-locations', book.locations.save());

		});

	</script>

</body>
</html>

</code>

packages\epubjs\examples\manifest.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Spreads Example</title>

  <script src="../dist/epub.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">

</head>
<body>
  <h1 id="title">...</h1>
  <div id="opener">
    <svg height="24px" id="hamburger" style="enable-background:new 0 0 32 32;" version="1.1" viewBox="0 0 32 32" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
      <path d="M4,10h24c1.104,0,2-0.896,2-2s-0.896-2-2-2H4C2.896,6,2,6.896,2,8S2.896,10,4,10z M28,14H4c-1.104,0-2,0.896-2,2  s0.896,2,2,2h24c1.104,0,2-0.896,2-2S29.104,14,28,14z M28,22H4c-1.104,0-2,0.896-2,2s0.896,2,2,2h24c1.104,0,2-0.896,2-2  S29.104,22,28,22z"/>
    </svg>
  </div>
  <div id="viewer" class="spreads"></div>
  <a id="prev" href="#prev" class="arrow">‹</a>
  <a id="next" href="#next" class="arrow">›</a>
  <div id="navigation" class="closed">
    <div id="closer">
      <svg viewbox="0 0 40 40">
          <path class="close-x" d="M 10,10 L 30,30 M 30,10 L 10,30" />
        </svg>
    </div>
    <image id="cover" width="150px"/>
    <h2 id="author">...</h2>
    <div id="toc"></div>
  </div>

  <script>
    var src = window.location.search ?
        window.location.search.replace("?href=", '') :
        "https://readium2.now.sh/pub/L2hvbWUvbm93dXNlci9zcmMvbWlzYy9lcHVicy9jaGlsZHJlbnMtbGl0ZXJhdHVyZS5lcHVi/manifest.json" ;
    var book = ePub(src);
    var rendition = book.renderTo("viewer", {
      width: "100%",
      height: 600
    });

    rendition.display();

    var title = document.getElementById("title");

    var next = document.getElementById("next");
    next.addEventListener("click", function(e){
      rendition.next();
      e.preventDefault();
    }, false);

    var prev = document.getElementById("prev");
    prev.addEventListener("click", function(e){
      rendition.prev();
      e.preventDefault();
    }, false);

    var keyListener = function(e){

      // Left Key
      if ((e.keyCode || e.which) == 37) {
        rendition.prev();
      }

      // Right Key
      if ((e.keyCode || e.which) == 39) {
        rendition.next();
      }

    };

    rendition.on("keyup", keyListener);
    document.addEventListener("keyup", keyListener, false);

    var navigation = document.getElementById("navigation");
    var opener = document.getElementById("opener");
    opener.addEventListener("click", function(e){
      navigation.classList.remove("closed");
      e.preventDefault();
    }, false);

    var closer = document.getElementById("closer");
    closer.addEventListener("click", function(e){
      navigation.classList.add("closed");
      e.preventDefault();
    }, false);

    book.loaded.navigation.then(function(toc){
      var $nav = document.getElementById("toc"),
          docfrag = document.createDocumentFragment();
      var addTocItems = function (parent, tocItems) {
        var $ul = document.createElement("ul");
        tocItems.forEach(function(chapter) {
          var item = document.createElement("li");
          var link = document.createElement("a");
          link.textContent = chapter.label;
          link.href = chapter.href;
          item.appendChild(link);

          if (chapter.subitems) {
            addTocItems(item, chapter.subitems)
          }

          link.onclick = function(){
            var url = link.getAttribute("href");
            rendition.display(url);
            navigation.classList.add("closed");
            return false;
          };

          $ul.appendChild(item);
        });
        parent.appendChild($ul);
      };

      addTocItems(docfrag, toc);

      $nav.appendChild(docfrag);

      if ($nav.offsetHeight + 60 < window.innerHeight) {
        $nav.classList.add("fixed");
      }

    });

    book.loaded.metadata.then(function(meta){
      var $title = document.getElementById("title");
      var $author = document.getElementById("author");
      var $cover = document.getElementById("cover");

      $title.textContent = meta.title;
      $author.textContent = meta.creator;
      if (book.archive) {
        book.archive.createUrl(book.cover)
          .then(function (url) {
            $cover.src = url;
          })
      } else {
        $cover.src = book.cover;
      }
    });

    rendition.on("rendered", function(section){
      var nextSection = section.next();
      var prevSection = section.prev();

      if(nextSection) {
        next.textContent = "›";
      } else {
        next.textContent = "";
      }

      if(prevSection) {
        prev.textContent = "‹";
      } else {
        prev.textContent = "";
      }

    });

    rendition.on("relocated", function(location){
      var current = book.navigation.get(location.href);

      if (current) {
        title.textContent = current.label;
      }

      console.log(location);
    });

    window.addEventListener("unload", function () {
      this.book.destroy();
    });

  </script>

</body>
</html>

</code>

packages\epubjs\examples\marks.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Pagination Example</title>

  <script src="../dist/epub.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">

</head>
<body>
  <div id="title"></div>
  <div id="viewer" class="spreads"></div>
  <a id="prev" href="#prev" class="arrow">‹</a>
  <a id="next" href="#next" class="arrow">›</a>

  <script>
    // Load the opf
    var book = ePub("https://s3.amazonaws.com/moby-dick/OPS/package.opf");

    var rendition = book.renderTo("viewer", {
      width: "100%",
      height: 600
    });

    var displayed = rendition.display(6);

    // Navigation loaded
    book.loaded.navigation.then(function(toc){
      // console.log(toc);
    });

    var next = document.getElementById("next");
    next.addEventListener("click", function(){
      rendition.next();
    }, false);

    var prev = document.getElementById("prev");
    prev.addEventListener("click", function(){
      rendition.prev();
    }, false);

    var keyListener = function(e){

      // Left Key
      if ((e.keyCode || e.which) == 37) {
        rendition.prev();
      }

      // Right Key
      if ((e.keyCode || e.which) == 39) {
        rendition.next();
      }

    };

    rendition.on("keyup", keyListener);
    document.addEventListener("keyup", keyListener, false);

    rendition.on("relocated", function(location){
      // console.log(location);
    });


    // Apply a class to selected text
    rendition.on("selected", function(cfiRange, contents) {

      rendition.annotations.mark(cfiRange, {'something' : true}, (e) => {
        var bounds = e.target.getBoundingClientRect();
        var clientX = e.clientX;

        if (clientX > bounds.right) {
          console.log("mark clicked", e.target);
        }
      });

      contents.window.getSelection().removeAllRanges();

    });

    this.rendition.themes.default({
      'p': {
        'padding': '0 20px 0 0',
        'text-align': 'left',
        'position': 'relative'
      },
      '[ref="epubjs-mk"]::before' : {
        'content': '""',
        'background': 'url("data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPScxLjEnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgeG1sbnM6eGxpbms9J2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnIHg9JzBweCcgeT0nMHB4JyB2aWV3Qm94PScwIDAgNzUgNzUnPjxnIGZpbGw9JyNCREJEQkQnIGlkPSdidWJibGUnPjxwYXRoIGNsYXNzPSdzdDAnIGQ9J00zNy41LDkuNEMxOS42LDkuNCw1LDIwLjUsNSwzNC4zYzAsNS45LDIuNywxMS4zLDcuMSwxNS42TDkuNiw2NS42bDE5LTcuM2MyLjgsMC42LDUuOCwwLjksOC45LDAuOSBDNTUuNSw1OS4yLDcwLDQ4LjEsNzAsMzQuM0M3MCwyMC41LDU1LjQsOS40LDM3LjUsOS40eicvPjwvZz48L3N2Zz4=") no-repeat',
        'display': 'block',
        'right' : '0',
        'position' : 'absolute',
        'width': '20px',
        'height': '20px',
        'margin': '0',
        'cursor': 'pointer'
      }
    });


  </script>

</body>
</html>

</code>

packages\epubjs\examples\mathml.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Spreads Example</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
  <script src="../dist/epub.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">

</head>
<body>
  <!-- <div id="title"></div> -->
  <select id="toc"></select>
  <div id="viewer" class="spreads"></div>
  <a id="prev" href="#prev" class="arrow">‹</a>
  <a id="next" href="#next" class="arrow">›</a>

  <script>
    var params = URLSearchParams && new URLSearchParams(document.location.search.substring(1));
    var url = params && params.get("url") && decodeURIComponent(params.get("url"));
    var currentSectionIndex = (params && params.get("loc")) ? params.get("loc") : undefined;

    // Load the opf
    var book = ePub(url || "http://epubjs.org/books/linear-algebra.epub");
    var rendition = book.renderTo("viewer", {
      width: "100%",
      height: 600,
      spread: "always"
    });

    rendition.display(currentSectionIndex);

    book.ready.then(() => {

      var next = document.getElementById("next");

      next.addEventListener("click", function(e){
        book.package.metadata.direction === "rtl" ? rendition.prev() : rendition.next();
        e.preventDefault();
      }, false);

      var prev = document.getElementById("prev");
      prev.addEventListener("click", function(e){
        book.package.metadata.direction === "rtl" ? rendition.next() : rendition.prev();
        e.preventDefault();
      }, false);

      var keyListener = function(e){

        // Left Key
        if ((e.keyCode || e.which) == 37) {
          book.package.metadata.direction === "rtl" ? rendition.next() : rendition.prev();
        }

        // Right Key
        if ((e.keyCode || e.which) == 39) {
          book.package.metadata.direction === "rtl" ? rendition.prev() : rendition.next();
        }

      };

      rendition.on("keyup", keyListener);
      document.addEventListener("keyup", keyListener, false);

    })

    var title = document.getElementById("title");

    rendition.on("rendered", function(section){
      var current = book.navigation && book.navigation.get(section.href);

      if (current) {
        var $select = document.getElementById("toc");
        var $selected = $select.querySelector("option[selected]");
        if ($selected) {
          $selected.removeAttribute("selected");
        }

        var $options = $select.querySelectorAll("option");
        for (var i = 0; i < $options.length; ++i) {
          let selected = $options[i].getAttribute("ref") === current.href;
          if (selected) {
            $options[i].setAttribute("selected", "");
          }
        }
      }

    });

    rendition.on("relocated", function(location){
      console.log(location);

      var next = book.package.metadata.direction === "rtl" ?  document.getElementById("prev") : document.getElementById("next");
      var prev = book.package.metadata.direction === "rtl" ?  document.getElementById("next") : document.getElementById("prev");

      if (location.atEnd) {
        next.style.visibility = "hidden";
      } else {
        next.style.visibility = "visible";
      }

      if (location.atStart) {
        prev.style.visibility = "hidden";
      } else {
        prev.style.visibility = "visible";
      }

    });

    rendition.on("layout", function(layout) {
      let viewer = document.getElementById("viewer");

      if (layout.spread) {
        viewer.classList.remove('single');
      } else {
        viewer.classList.add('single');
      }
    });

    window.addEventListener("unload", function () {
      console.log("unloading");
      this.book.destroy();
    });

    book.loaded.navigation.then(function(toc){
			var $select = document.getElementById("toc"),
					docfrag = document.createDocumentFragment();

			toc.forEach(function(chapter) {
				var option = document.createElement("option");
				option.textContent = chapter.label;
				option.setAttribute("ref", chapter.href);

				docfrag.appendChild(option);
			});

			$select.appendChild(docfrag);

			$select.onchange = function(){
					var index = $select.selectedIndex,
							url = $select.options[index].getAttribute("ref");
					rendition.display(url);
					return false;
			};

		});

    rendition.hooks.content.register(function (content) {
      let section = book.section(content.sectionIndex);
      let mathml = section.properties.includes("mathml");

      if (mathml) {
        return content.addScript('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML');
      }
    });

  </script>

</body>
</html>

</code>

packages\epubjs\examples\offline.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Storage Example</title>

  <script src="../node_modules/jszip/dist/jszip.min.js"></script>
  <script src="../node_modules/localforage/dist/localforage.min.js"></script>
  <script src="../dist/epub.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">

  <style type="text/css">

    #offline {
      position: fixed;
      top: -40px;
      left: 0;
      background-color: yellow;
      width: 100%;
      text-align: center;
      padding: 10px 0;
      transition: top .5s;
      z-index: 99;
    }
  </style>

</head>
<body>
  <div id="offline">You are offline. Loading from Storage.</div>
  <div id="viewer" class="spreads"></div>
  <div id="prev" class="arrow">‹</div>
  <div id="next" class="arrow">›</div>
  <script>
    var book = ePub("https://s3.amazonaws.com/moby-dick/", {
      store: "epubjs-test"
    });

    var rendition = book.renderTo("viewer", {
      width: "100%",
      height: 600
    });

    var displayed = rendition.display();

    displayed.then(function(renderer){
      // Add all resources to the store
      // Add `true` to force re-saving resources
      book.storage.add(book.resources, true).then(() => {
        console.log("stored");
      })
    });

    var next = document.getElementById("next");
    next.addEventListener("click", function(){
      rendition.next();
    }, false);

    var prev = document.getElementById("prev");
    prev.addEventListener("click", function(){
      rendition.prev();
    }, false);

    var keyListener = function(e){

      // Left Key
      if ((e.keyCode || e.which) == 37) {
        rendition.prev();
      }

      // Right Key
      if ((e.keyCode || e.which) == 39) {
        rendition.next();
      }

    };

    rendition.on("keyup", keyListener);
    document.addEventListener("keyup", keyListener, false);

    var msg = document.getElementById('offline');
    book.storage.on("online", function () {
			console.log("online");
			msg.style.top = "-40px";
		});

		book.storage.on("offline", function () {
			console.log("offline");
			msg.style.top = "0px";
		});


  </script>

</body>
</html>

</code>

packages\epubjs\examples\renderless.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>EPUB.js Basic Example</title>

  <script src="../dist/epub.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">

</head>
<body>
  <select id="toc"></select>
  <div id="viewer" class="scrolled"></div>
  <div id="prev" class="arrow">‹</div>
  <div id="next" class="arrow">›</div>

  <script>
    var $viewer = document.getElementById("viewer");
    var $next = document.getElementById("next");
    var $prev = document.getElementById("prev");
    var currentSection;
    var currentSectionIndex = 6;

    var book = ePub("https://s3.amazonaws.com/epubjs/books/moby-dick/OPS/package.opf");
    book.loaded.navigation.then(function(toc){
      var $select = document.getElementById("toc"),
          docfrag = document.createDocumentFragment();

      toc.forEach(function(chapter) {
        var option = document.createElement("option");
        option.textContent = chapter.label;
        option.ref = chapter.href;

        docfrag.appendChild(option);
      });

      $select.appendChild(docfrag);

      $select.onchange = function(){
          var index = $select.selectedIndex,
              url = $select.options[index].ref;
          display(url);
          return false;
      };

      book.opened.then(function(){
        display(currentSectionIndex);
      });

      $next.addEventListener("click", function(){
        var displayed = display(currentSectionIndex+1);
        if(displayed) currentSectionIndex++;
      }, false);

      $prev.addEventListener("click", function(){
        var displayed = display(currentSectionIndex-1);
        if(displayed) currentSectionIndex--;
      }, false);

      function display(item){
        var section = book.spine.get(item);
        if(section) {
          currentSection = section;
          section.render().then(function(html){
            // $viewer.srcdoc = html;
            $viewer.innerHTML = html;
          });
        }
        return section;
      }

    });
  </script>

</body>
</html>

</code>

packages\epubjs\examples\scrolled.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Scrolled Example</title>

  <script src="../dist/epub.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">

</head>
<body>
  <a id="prev" href="#prev" class="navlink">...</a>
  <div id="viewer" class="scrolled"></div>
  <a id="next" href="#next" class="navlink">...</a>

  <script>
    // Load the opf
    var params = URLSearchParams && new URLSearchParams(document.location.search.substring(1));
    var url = params && params.get("url") && decodeURIComponent(params.get("url"));
    var currentSectionIndex = (params && params.get("loc")) ? params.get("loc") : undefined;

    var book = ePub(url || "https://s3.amazonaws.com/epubjs/books/alice/OPS/package.opf");
    var rendition = book.renderTo("viewer", {
      flow: "scrolled-doc",
      width: "100%",
      fullsize: true
    });

    rendition.display(currentSectionIndex);


    var next = document.getElementById("next");
    next.addEventListener("click", function(e){
      rendition.next();
      e.preventDefault();
    }, false);

    var prev = document.getElementById("prev");
    prev.addEventListener("click", function(e){
      rendition.prev();
      e.preventDefault();
    }, false);

    rendition.on("relocated", function(location){
      console.log(location);
    });

    rendition.on("rendered", function(section){
      var nextSection = section.next();
      var prevSection = section.prev();

      if(nextSection) {
        nextNav = book.navigation.get(nextSection.href);

        if(nextNav) {
          nextLabel = nextNav.label;
        } else {
          nextLabel = "next";
        }

        next.textContent = nextLabel + " »";
      } else {
        next.textContent = "";
      }

      if(prevSection) {
        prevNav = book.navigation.get(prevSection.href);

        if(prevNav) {
          prevLabel = prevNav.label;
        } else {
          prevLabel = "previous";
        }

        prev.textContent = "« " + prevLabel;
      } else {
        prev.textContent = "";
      }

    });

  </script>

</body>
</html>

</code>

packages\epubjs\examples\single-full.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Scrolled Full Example</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
  <script src="../dist/epub.js"></script>


  <style type="text/css">
    body {
      margin: 0;
      background: #fafafa;
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      color: #333;
    }

    #navigation {
      width: 300px;
      position: absolute;
      overflow: auto;
      top: 60px;
      left: 1000px
    }

    #navigation.fixed {
      position: fixed;
    }

    #navigation h1 {
      width: 200px;
      font-size: 16px;
      font-weight: normal;
      color: #777;
      margin-bottom: 10px;
    }

    #navigation h2 {
      font-size: 14px;
      font-weight: normal;
      color: #B0B0B0;
      margin-bottom: 20px;
    }

    #navigation ul {
      padding-left: 18px;
      margin-left: 0;
      margin-top: 12px;
      margin-bottom: 12px;
    }

    #navigation ul li {
      list-style: decimal;
      margin-bottom: 10px;
      color: #cccddd;
      font-size: 12px;
      padding-left: 0;
      margin-left: 0;
    }

    #navigation ul li a {
      color: #ccc;
      text-decoration: none;
    }

    #navigation ul li a:hover {
      color: #777;
      text-decoration: underline;
    }

    #navigation ul li a.active {
      color: #000;
    }

    #viewer {

      overflow: hidden;
      width: 800px;
      margin: 0 50px;
      background: url('ajax-loader.gif') center center no-repeat;

    }

    #viewer .epub-view {
        background: white;
        box-shadow: 0 0 4px #ccc;
        /*margin: 10px;*/
        /*padding: 40px 80px;*/
    }

    #main {
      position: absolute;
      top: 50px;
      left: 50px;
      width: 800px;
      z-index: 2;
      transition: left .15s cubic-bezier(.55, 0, .2, .8) .08s;
    }

    #main.open {
      left: 0;
    }

    #pagination {
      text-align: center;
      margin-left: 80px;
      /*padding: 0 50px;*/
    }

    .arrow {
      margin: 14px;
      display: inline-block;
      text-align: center;
      text-decoration: none;
      color: #ccc;
    }

    .arrow:hover {
      color: #777;
    }

    .arrow:active {
      color: #000;
    }

    #prev {
      float: left;
    }

    #next {
      float: right;
    }

    #toc {
      display: block;
      margin: 10px auto;
    }
  </style>
</head>
<body>
  <div id="navigation">
    <h1 id="title">...</h1>
    <image id="cover" width="150px"/>
    <h2 id="author">...</h2>
    <div id="toc"></div>
  </div>
  <div id="main">
    <div id="viewer"></div>
    <div id="pagination">
      <a id="prev" href="#prev" class="arrow">...</a>
      <a id="next" href="#next" class="arrow">...</a>
    </div>
  </div>

  <script>
    // Load the opf
    var book = ePub("https://s3.amazonaws.com/moby-dick/moby-dick.epub");
    var rendition = book.renderTo("viewer", {
      flow: "scrolled-doc"
    });
    var hash = window.location.hash.slice(2);
    console.log(hash);
    rendition.display(hash || undefined);


    var next = document.getElementById("next");
    next.addEventListener("click", function(e){
      rendition.next();
      e.preventDefault();
    }, false);

    var prev = document.getElementById("prev");
    prev.addEventListener("click", function(e){
      rendition.prev();
      e.preventDefault();
    }, false);



    rendition.on("rendered", function(section){
      var nextSection = section.next();
      var prevSection = section.prev();

      if(nextSection) {
        nextNav = book.navigation.get(nextSection.href);

        if(nextNav) {
          nextLabel = nextNav.label;
        } else {
          nextLabel = "next";
        }

        next.textContent = nextLabel + " »";
      } else {
        next.textContent = "";
      }

      if(prevSection) {
        prevNav = book.navigation.get(prevSection.href);

        if(prevNav) {
          prevLabel = prevNav.label;
        } else {
          prevLabel = "previous";
        }

        prev.textContent = "« " + prevLabel;
      } else {
        prev.textContent = "";
      }

      // Add CFI fragment to the history
      //history.pushState({}, '', section.href);
      window.location.hash = "#/"+section.href
    });

    rendition.on("relocated", function(location){
      console.log(location);
    });

    book.loaded.navigation.then(function(toc){
      var $nav = document.getElementById("toc"),
          docfrag = document.createDocumentFragment();
      var addTocItems = function (parent, tocItems) {
        var $ul = document.createElement("ul");
        tocItems.forEach(function(chapter) {
          var item = document.createElement("li");
          var link = document.createElement("a");
          link.textContent = chapter.label;
          link.href = chapter.href;
          item.appendChild(link);

          if (chapter.subitems) {
            addTocItems(item, chapter.subitems)
          }

          link.onclick = function(){
            var url = link.getAttribute("href");
            rendition.display(url);
            return false;
          };

          $ul.appendChild(item);
        });
        parent.appendChild($ul);
      };

      addTocItems(docfrag, toc);

      $nav.appendChild(docfrag);

      if ($nav.offsetHeight + 60 < window.innerHeight) {
        $nav.classList.add("fixed");
      }

    });

    book.loaded.metadata.then(function(meta){
      var $title = document.getElementById("title");
      var $author = document.getElementById("author");
      var $cover = document.getElementById("cover");

      $title.textContent = meta.title;
      $author.textContent = meta.creator;
      if (book.archive) {
        book.archive.createUrl(book.cover)
          .then(function (url) {
            $cover.src = url;
          })
      } else {
        $cover.src = book.cover;
      }

    });
  </script>

</body>
</html>

</code>

packages\epubjs\examples\spreads.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Spreads Example</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
  <script src="../dist/epub.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">

</head>
<body>
  <!-- <div id="title"></div> -->
  <select id="toc"></select>
  <div id="viewer" class="spreads"></div>
  <a id="prev" href="#prev" class="arrow">‹</a>
  <a id="next" href="#next" class="arrow">›</a>

  <script>
    var params = URLSearchParams && new URLSearchParams(document.location.search.substring(1));
    var url = params && params.get("url") && decodeURIComponent(params.get("url"));
    var currentSectionIndex = (params && params.get("loc")) ? params.get("loc") : undefined;

    // Load the opf
    var book = ePub(url || "https://s3.amazonaws.com/moby-dick/moby-dick.epub");
    var rendition = book.renderTo("viewer", {
      width: "100%",
      height: 600,
      spread: "always"
    });

    rendition.display(currentSectionIndex);

    book.ready.then(function() {

      var next = document.getElementById("next");

      next.addEventListener("click", function(e){
        book.package.metadata.direction === "rtl" ? rendition.prev() : rendition.next();
        e.preventDefault();
      }, false);

      var prev = document.getElementById("prev");
      prev.addEventListener("click", function(e){
        book.package.metadata.direction === "rtl" ? rendition.next() : rendition.prev();
        e.preventDefault();
      }, false);

      var keyListener = function(e){

        // Left Key
        if ((e.keyCode || e.which) == 37) {
          book.package.metadata.direction === "rtl" ? rendition.next() : rendition.prev();
        }

        // Right Key
        if ((e.keyCode || e.which) == 39) {
          book.package.metadata.direction === "rtl" ? rendition.prev() : rendition.next();
        }

      };

      rendition.on("keyup", keyListener);
      document.addEventListener("keyup", keyListener, false);

    })

    var title = document.getElementById("title");

    rendition.on("rendered", function(section){
      var current = book.navigation && book.navigation.get(section.href);

      if (current) {
        var $select = document.getElementById("toc");
        var $selected = $select.querySelector("option[selected]");
        if ($selected) {
          $selected.removeAttribute("selected");
        }

        var $options = $select.querySelectorAll("option");
        for (var i = 0; i < $options.length; ++i) {
          let selected = $options[i].getAttribute("ref") === current.href;
          if (selected) {
            $options[i].setAttribute("selected", "");
          }
        }
      }

    });

    rendition.on("relocated", function(location){
      console.log(location);

      var next = book.package.metadata.direction === "rtl" ?  document.getElementById("prev") : document.getElementById("next");
      var prev = book.package.metadata.direction === "rtl" ?  document.getElementById("next") : document.getElementById("prev");

      if (location.atEnd) {
        next.style.visibility = "hidden";
      } else {
        next.style.visibility = "visible";
      }

      if (location.atStart) {
        prev.style.visibility = "hidden";
      } else {
        prev.style.visibility = "visible";
      }

    });

    rendition.on("layout", function(layout) {
      let viewer = document.getElementById("viewer");

      if (layout.spread) {
        viewer.classList.remove('single');
      } else {
        viewer.classList.add('single');
      }
    });

    window.addEventListener("unload", function () {
      console.log("unloading");
      this.book.destroy();
    });

    book.loaded.navigation.then(function(toc){
			var $select = document.getElementById("toc"),
					docfrag = document.createDocumentFragment();

			toc.forEach(function(chapter) {
				var option = document.createElement("option");
				option.textContent = chapter.label;
				option.setAttribute("ref", chapter.href);

				docfrag.appendChild(option);
			});

			$select.appendChild(docfrag);

			$select.onchange = function(){
					var index = $select.selectedIndex,
							url = $select.options[index].getAttribute("ref");
					rendition.display(url);
					return false;
			};

		});




  </script>

</body>
</html>

</code>

packages\epubjs\examples\swipe.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Pagination Example</title>
  <!-- <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script> -->
  <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/detect_swipe/2.1.1/jquery.detect_swipe.min.js"></script> -->
  <script src="../dist/epub.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">

  <style type="text/css">
    body {
      display: flex;
      -webkit-align-items: center;
      -webkit-justify-content: center;
    }

    #viewer {
      width: 290px;
      height: 580px;
      box-shadow: 0 0 4px #ccc;
      padding: 10px 10px 0px 10px;
      margin: 5px auto;
      background: white;
    }


    @media only screen
      and (min-device-width : 320px)
      and (max-device-width : 667px) {
        #viewer {
          height: 96.5%;
        }
        #viewer iframe {
          /* pointer-events: none; */
        }
        .arrow {
          position: inherit;
          display: none;
        }
    }

  </style>
</head>
<body>
  <div id="viewer"></div>
  <div id="prev" class="arrow">‹</div>
  <div id="next" class="arrow">›</div>
  <script>
    // Load the opf
    var book = ePub("https://s3.amazonaws.com/epubjs/books/moby-dick/OPS/package.opf");
    var rendition = book.renderTo("viewer", {
      manager: "continuous",
      flow: "paginated",
      width: "100%",
      height: "100%",
      snap: true
    });

    var displayed = rendition.display("chapter_001.xhtml");

    displayed.then(function(renderer){
      // -- do stuff
    });

    // Navigation loaded
    book.loaded.navigation.then(function(toc){
      // console.log(toc);
    });

    var next = document.getElementById("next");
    next.addEventListener("click", function(){
      rendition.next();
    }, false);

    var prev = document.getElementById("prev");
    prev.addEventListener("click", function(){
      rendition.prev();
    }, false);

    document.addEventListener("keyup", function(e){

      // Left Key
      if ((e.keyCode || e.which) == 37) {
        rendition.prev();
      }

      // Right Key
      if ((e.keyCode || e.which) == 39) {
        rendition.next();
      }

    }, false);

    // $(window).on( "swipeleft", function( event ) {
    //   rendition.next();
    // });
    //
    // $(window).on( "swiperight", function( event ) {
    //   rendition.prev();
    // });


  </script>

</body>
</html>

</code>

packages\epubjs\examples\themes.css:
<code>
.dark {
  background: #000;
  color: #fff;
}

.light {
  background: #fff;
  color: #000;
}

.tan {
  background: tan;
  color: #ccc;
}

</code>

packages\epubjs\examples\themes.html:
<code>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Spreads Example</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
  <script src="../dist/epub.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">

</head>
<body>
  <div id="title"></div>
  <div id="viewer" class="spreads"></div>
  <a id="prev" href="#prev" class="arrow">‹</a>
  <a id="next" href="#next" class="arrow">›</a>

  <script>
    var currentSectionIndex = 8;
    // Load the opf
    var book = ePub("https://s3.amazonaws.com/epubjs/books/alice/OPS/package.opf");
    var rendition = book.renderTo("viewer", {
      width: "100%",
      height: 600,
      manager: "continuous"
    });

    rendition.display("chapter_007.xhtml");

    var title = document.getElementById("title");

    var next = document.getElementById("next");
    next.addEventListener("click", function(e){
      rendition.next();
      e.preventDefault();
    }, false);

    var prev = document.getElementById("prev");
    prev.addEventListener("click", function(e){
      rendition.prev();
      e.preventDefault();
    }, false);

    var keyListener = function(e){

      // Left Key
      if ((e.keyCode || e.which) == 37) {
        rendition.prev();
      }

      // Right Key
      if ((e.keyCode || e.which) == 39) {
        rendition.next();
      }

    };

    rendition.on("keyup", keyListener);
    document.addEventListener("keyup", keyListener, false);



    rendition.on("rendered", function(section){
      var nextSection = section.next();
      var prevSection = section.prev();
      var current = book.navigation.get(section.href);

      if (current) {
        title.textContent = current.label;
      }

      if(nextSection) {
        next.textContent = "›";
      } else {
        next.textContent = "";
      }

      if(prevSection) {
        prev.textContent = "‹";
      } else {
        prev.textContent = "";
      }



    });

    rendition.on("relocated", function(location){
      console.log(location);
    });


    rendition.themes.register("dark", "themes.css");
    rendition.themes.register("light", "themes.css");
    rendition.themes.register("tan", "themes.css");



    rendition.themes.default({
      h2: {
        'font-size': '32px',
        color: 'purple'
      },
      p: {
        "margin": '10px'
      }
    });

    rendition.themes.select("tan");
    rendition.themes.fontSize("140%");

  </script>

</body>
</html>

</code>

packages\epubjs\examples\toc.html:
<code>
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>EPUB.js Basic Example</title>

	<script src="../dist/epub.js"></script>

	<link rel="stylesheet" type="text/css" href="examples.css">

</head>
<body>
	<select id="toc"></select>
	<div id="viewer" class="scrolled"></div>

	<script>
		var $viewer = document.getElementById("viewer");
		var $next = document.getElementById("next");
		var $prev = document.getElementById("prev");
		var currentSectionIndex = 9;
		// Load the opf
		var book = ePub("https://s3.amazonaws.com/moby-dick/OPS/package.opf");
		var rendition = book.renderTo("viewer", { flow: "scrolled-doc", width: 600, height: 400});
		var displayed = rendition.display(currentSectionIndex);

		book.loaded.navigation.then(function(toc){
			var $select = document.getElementById("toc"),
					docfrag = document.createDocumentFragment();

			toc.forEach(function(chapter) {
				var option = document.createElement("option");
				option.textContent = chapter.label;
				option.ref = chapter.href;

				docfrag.appendChild(option);
			});

			$select.appendChild(docfrag);

			$select.onchange = function(){
					var index = $select.selectedIndex,
							url = $select.options[index].ref;
					rendition.display(url);
					return false;
			};


		});
	</script>

</body>
</html>

</code>

packages\epubjs\src\annotations.js:
<code>
import EventEmitter from 'event-emitter'

import EpubCFI from './epubcfi'
import { EVENTS } from './utils/constants'

/**
 * Handles managing adding & removing Annotations
 * @param {Rendition} rendition
 * @class
 */
class Annotations {
  constructor(rendition) {
    this.rendition = rendition
    this.highlights = []
    this.underlines = []
    this.marks = []
    this._annotations = {}
    this._annotationsBySectionIndex = {}

    this.rendition.hooks.render.register(this.inject.bind(this))
    this.rendition.hooks.unloaded.register(this.clear.bind(this))
  }

  /**
   * Add an annotation to store
   * @param {string} type Type of annotation to add: "highlight", "underline", "mark"
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} [cb] Callback after annotation is added
   * @param {string} className CSS class to assign to annotation
   * @param {object} styles CSS styles to assign to annotation
   * @returns {Annotation} annotation
   */
  add(type, cfiRange, data, cb, className, styles) {
    let hash = encodeURI(cfiRange + type)
    let cfi = new EpubCFI(cfiRange)
    let sectionIndex = cfi.spinePos
    let annotation = new Annotation({
      type,
      cfiRange,
      data,
      sectionIndex,
      cb,
      className,
      styles,
    })

    this._annotations[hash] = annotation

    if (sectionIndex in this._annotationsBySectionIndex) {
      this._annotationsBySectionIndex[sectionIndex].push(hash)
    } else {
      this._annotationsBySectionIndex[sectionIndex] = [hash]
    }

    let views = this.rendition.views()

    views.forEach((view) => {
      if (annotation.sectionIndex === view.index) {
        annotation.attach(view)
      }
    })

    return annotation
  }

  /**
   * Remove an annotation from store
   * @param {EpubCFI} cfiRange EpubCFI range the annotation is attached to
   * @param {string} type Type of annotation to add: "highlight", "underline", "mark"
   */
  remove(cfiRange, type) {
    let hash = encodeURI(cfiRange + type)

    if (hash in this._annotations) {
      let annotation = this._annotations[hash]

      if (type && annotation.type !== type) {
        return
      }

      let views = this.rendition.views()
      views.forEach((view) => {
        this._removeFromAnnotationBySectionIndex(annotation.sectionIndex, hash)
        if (annotation.sectionIndex === view.index) {
          annotation.detach(view)
        }
      })

      delete this._annotations[hash]
    }
  }

  /**
   * Remove an annotations by Section Index
   * @private
   */
  _removeFromAnnotationBySectionIndex(sectionIndex, hash) {
    this._annotationsBySectionIndex[sectionIndex] = this._annotationsAt(
      sectionIndex,
    ).filter((h) => h !== hash)
  }

  /**
   * Get annotations by Section Index
   * @private
   */
  _annotationsAt(index) {
    return this._annotationsBySectionIndex[index]
  }

  /**
   * Add a highlight to the store
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} cb Callback after annotation is clicked
   * @param {string} className CSS class to assign to annotation
   * @param {object} styles CSS styles to assign to annotation
   */
  highlight(cfiRange, data, cb, className, styles) {
    return this.add('highlight', cfiRange, data, cb, className, styles)
  }

  /**
   * Add a underline to the store
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} cb Callback after annotation is clicked
   * @param {string} className CSS class to assign to annotation
   * @param {object} styles CSS styles to assign to annotation
   */
  underline(cfiRange, data, cb, className, styles) {
    return this.add('underline', cfiRange, data, cb, className, styles)
  }

  /**
   * Add a mark to the store
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} cb Callback after annotation is clicked
   */
  mark(cfiRange, data, cb) {
    return this.add('mark', cfiRange, data, cb)
  }

  /**
   * iterate over annotations in the store
   */
  each() {
    return this._annotations.forEach.apply(this._annotations, arguments)
  }

  /**
   * Hook for injecting annotation into a view
   * @param {View} view
   * @private
   */
  inject(view) {
    let sectionIndex = view.index
    if (sectionIndex in this._annotationsBySectionIndex) {
      let annotations = this._annotationsBySectionIndex[sectionIndex]
      annotations.forEach((hash) => {
        let annotation = this._annotations[hash]
        annotation.attach(view)
      })
    }
  }

  /**
   * Hook for removing annotation from a view
   * @param {View} view
   * @private
   */
  clear(view) {
    let sectionIndex = view.index
    if (sectionIndex in this._annotationsBySectionIndex) {
      let annotations = this._annotationsBySectionIndex[sectionIndex]
      annotations.forEach((hash) => {
        let annotation = this._annotations[hash]
        annotation.detach(view)
      })
    }
  }

  /**
   * [Not Implemented] Show annotations
   * @TODO: needs implementation in View
   */
  show() {}

  /**
   * [Not Implemented] Hide annotations
   * @TODO: needs implementation in View
   */
  hide() {}
}

/**
 * Annotation object
 * @class
 * @param {object} options
 * @param {string} options.type Type of annotation to add: "highlight", "underline", "mark"
 * @param {EpubCFI} options.cfiRange EpubCFI range to attach annotation to
 * @param {object} options.data Data to assign to annotation
 * @param {int} options.sectionIndex Index in the Spine of the Section annotation belongs to
 * @param {function} [options.cb] Callback after annotation is clicked
 * @param {string} className CSS class to assign to annotation
 * @param {object} styles CSS styles to assign to annotation
 * @returns {Annotation} annotation
 */
class Annotation {
  constructor({ type, cfiRange, data, sectionIndex, cb, className, styles }) {
    this.type = type
    this.cfiRange = cfiRange
    this.data = data
    this.sectionIndex = sectionIndex
    this.mark = undefined
    this.cb = cb
    this.className = className
    this.styles = styles
  }

  /**
   * Update stored data
   * @param {object} data
   */
  update(data) {
    this.data = data
  }

  /**
   * Add to a view
   * @param {View} view
   */
  attach(view) {
    let { cfiRange, data, type, mark, cb, className, styles } = this
    let result

    if (type === 'highlight') {
      result = view.highlight(cfiRange, data, cb, className, styles)
    } else if (type === 'underline') {
      result = view.underline(cfiRange, data, cb, className, styles)
    } else if (type === 'mark') {
      result = view.mark(cfiRange, data, cb)
    }

    this.mark = result
    this.emit(EVENTS.ANNOTATION.ATTACH, result)
    return result
  }

  /**
   * Remove from a view
   * @param {View} view
   */
  detach(view) {
    let { cfiRange, type } = this
    let result

    if (view) {
      if (type === 'highlight') {
        result = view.unhighlight(cfiRange)
      } else if (type === 'underline') {
        result = view.ununderline(cfiRange)
      } else if (type === 'mark') {
        result = view.unmark(cfiRange)
      }
    }

    this.mark = undefined
    this.emit(EVENTS.ANNOTATION.DETACH, result)
    return result
  }

  /**
   * [Not Implemented] Get text of an annotation
   * @TODO: needs implementation in contents
   */
  text() {}
}

EventEmitter(Annotation.prototype)

export default Annotations

</code>

packages\epubjs\src\archive.js:
<code>
import JSZip from 'jszip/dist/jszip'

import { defer, isXml, parse } from './utils/core'
import mime from './utils/mime'
import Path from './utils/path'
import request from './utils/request'

/**
 * Handles Unzipping a requesting files from an Epub Archive
 * @class
 */
class Archive {
  constructor() {
    this.zip = undefined
    this.urlCache = {}

    this.checkRequirements()
  }

  /**
   * Checks to see if JSZip exists in global namspace,
   * Requires JSZip if it isn't there
   * @private
   */
  checkRequirements() {
    try {
      this.zip = new JSZip()
    } catch (e) {
      throw new Error('JSZip lib not loaded')
    }
  }

  /**
   * Open an archive
   * @param  {binary} input
   * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded
   * @return {Promise} zipfile
   */
  open(input, isBase64) {
    return this.zip.loadAsync(input, { base64: isBase64 })
  }

  /**
   * Load and Open an archive
   * @param  {string} zipUrl
   * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded
   * @return {Promise} zipfile
   */
  openUrl(zipUrl, isBase64) {
    return request(zipUrl, 'binary').then(
      function (data) {
        return this.zip.loadAsync(data, { base64: isBase64 })
      }.bind(this),
    )
  }

  /**
   * Request a url from the archive
   * @param  {string} url  a url to request from the archive
   * @param  {string} [type] specify the type of the returned result
   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}
   */
  request(url, type) {
    var deferred = new defer()
    var response
    var path = new Path(url)

    // If type isn't set, determine it from the file extension
    if (!type) {
      type = path.extension
    }

    if (type == 'blob') {
      response = this.getBlob(url)
    } else {
      response = this.getText(url)
    }

    if (response) {
      response.then(
        function (r) {
          let result = this.handleResponse(r, type)
          deferred.resolve(result)
        }.bind(this),
      )
    } else {
      deferred.reject({
        message: 'File not found in the epub: ' + url,
        stack: new Error().stack,
      })
    }
    return deferred.promise
  }

  /**
   * Handle the response from request
   * @private
   * @param  {any} response
   * @param  {string} [type]
   * @return {any} the parsed result
   */
  handleResponse(response, type) {
    var r

    if (type == 'json') {
      r = JSON.parse(response)
    } else if (isXml(type)) {
      r = parse(response, 'text/xml')
    } else if (type == 'xhtml') {
      r = parse(response, 'application/xhtml+xml')
    } else if (type == 'html' || type == 'htm') {
      r = parse(response, 'text/html')
    } else {
      r = response
    }

    return r
  }

  /**
   * Get a Blob from Archive by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {Blob}
   */
  getBlob(url, mimeType) {
    var decodededUrl = window.decodeURIComponent(url.substr(1)) // Remove first slash
    var entry = this.zip.file(decodededUrl)

    if (entry) {
      mimeType = mimeType || mime.lookup(entry.name)
      return entry.async('uint8array').then(function (uint8array) {
        return new Blob([uint8array], { type: mimeType })
      })
    }
  }

  /**
   * Get Text from Archive by Url
   * @param  {string} url
   * @param  {string} [encoding]
   * @return {string}
   */
  getText(url, encoding) {
    var decodededUrl = window.decodeURIComponent(url.substr(1)) // Remove first slash
    var entry = this.zip.file(decodededUrl)

    if (entry) {
      return entry.async('string').then(function (text) {
        return text
      })
    }
  }

  /**
   * Get a base64 encoded result from Archive by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {string} base64 encoded
   */
  getBase64(url, mimeType) {
    var decodededUrl = window.decodeURIComponent(url.substr(1)) // Remove first slash
    var entry = this.zip.file(decodededUrl)

    if (entry) {
      mimeType = mimeType || mime.lookup(entry.name)
      return entry.async('base64').then(function (data) {
        return 'data:' + mimeType + ';base64,' + data
      })
    }
  }

  /**
   * Create a Url from an unarchived item
   * @param  {string} url
   * @param  {object} [options.base64] use base64 encoding or blob url
   * @return {Promise} url promise with Url string
   */
  createUrl(url, options) {
    var deferred = new defer()
    var _URL = window.URL || window.webkitURL || window.mozURL
    var tempUrl
    var response
    var useBase64 = options && options.base64

    if (url in this.urlCache) {
      deferred.resolve(this.urlCache[url])
      return deferred.promise
    }

    if (useBase64) {
      response = this.getBase64(url)

      if (response) {
        response.then(
          function (tempUrl) {
            this.urlCache[url] = tempUrl
            deferred.resolve(tempUrl)
          }.bind(this),
        )
      }
    } else {
      response = this.getBlob(url)

      if (response) {
        response.then(
          function (blob) {
            tempUrl = _URL.createObjectURL(blob)
            this.urlCache[url] = tempUrl
            deferred.resolve(tempUrl)
          }.bind(this),
        )
      }
    }

    if (!response) {
      deferred.reject({
        message: 'File not found in the epub: ' + url,
        stack: new Error().stack,
      })
    }

    return deferred.promise
  }

  /**
   * Revoke Temp Url for a archive item
   * @param  {string} url url of the item in the archive
   */
  revokeUrl(url) {
    var _URL = window.URL || window.webkitURL || window.mozURL
    var fromCache = this.urlCache[url]
    if (fromCache) _URL.revokeObjectURL(fromCache)
  }

  destroy() {
    var _URL = window.URL || window.webkitURL || window.mozURL
    for (let fromCache in this.urlCache) {
      _URL.revokeObjectURL(fromCache)
    }
    this.zip = undefined
    this.urlCache = {}
  }
}

export default Archive

</code>

packages\epubjs\src\book.js:
<code>
import EventEmitter from 'event-emitter'

import Archive from './archive'
import Container from './container'
import DisplayOptions from './displayoptions'
import EpubCFI from './epubcfi'
import Locations from './locations'
import Navigation from './navigation'
import Packaging from './packaging'
import PageList from './pagelist'
import Rendition from './rendition'
import Resources from './resources'
import Spine from './spine'
import Store from './store'
import { EPUBJS_VERSION, EVENTS } from './utils/constants'
import { extend, defer } from './utils/core'
import Path from './utils/path'
import request from './utils/request'
import Url from './utils/url'

const CONTAINER_PATH = 'META-INF/container.xml'
const IBOOKS_DISPLAY_OPTIONS_PATH =
  'META-INF/com.apple.ibooks.display-options.xml'

const INPUT_TYPE = {
  BINARY: 'binary',
  BASE64: 'base64',
  EPUB: 'epub',
  OPF: 'opf',
  MANIFEST: 'json',
  DIRECTORY: 'directory',
}

/**
 * An Epub representation with methods for the loading, parsing and manipulation
 * of its contents.
 * @class
 * @param {string} [url]
 * @param {object} [options]
 * @param {method} [options.requestMethod] a request function to use instead of the default
 * @param {boolean} [options.requestCredentials=undefined] send the xhr request withCredentials
 * @param {object} [options.requestHeaders=undefined] send the xhr request headers
 * @param {string} [options.encoding=binary] optional to pass 'binary' or base64' for archived Epubs
 * @param {string} [options.replacements=none] use base64, blobUrl, or none for replacing assets in archived Epubs
 * @param {method} [options.canonical] optional function to determine canonical urls for a path
 * @param {string} [options.openAs] optional string to determine the input type
 * @param {string} [options.store=false] cache the contents in local storage, value should be the name of the reader
 * @returns {Book}
 * @example new Book("/path/to/book.epub", {})
 * @example new Book({ replacements: "blobUrl" })
 */
class Book {
  constructor(url, options) {
    // Allow passing just options to the Book
    if (
      typeof options === 'undefined' &&
      typeof url !== 'string' &&
      url instanceof Blob === false &&
      url instanceof ArrayBuffer === false
    ) {
      options = url
      url = undefined
    }

    this.settings = extend(this.settings || {}, {
      requestMethod: undefined,
      requestCredentials: undefined,
      requestHeaders: undefined,
      encoding: undefined,
      replacements: undefined,
      canonical: undefined,
      openAs: undefined,
      store: undefined,
    })

    extend(this.settings, options)

    // Promises
    this.opening = new defer()
    /**
     * @member {promise} opened returns after the book is loaded
     * @memberof Book
     */
    this.opened = this.opening.promise
    this.isOpen = false

    this.loading = {
      manifest: new defer(),
      spine: new defer(),
      metadata: new defer(),
      cover: new defer(),
      navigation: new defer(),
      pageList: new defer(),
      resources: new defer(),
      displayOptions: new defer(),
    }

    this.loaded = {
      manifest: this.loading.manifest.promise,
      spine: this.loading.spine.promise,
      metadata: this.loading.metadata.promise,
      cover: this.loading.cover.promise,
      navigation: this.loading.navigation.promise,
      pageList: this.loading.pageList.promise,
      resources: this.loading.resources.promise,
      displayOptions: this.loading.displayOptions.promise,
    }

    /**
     * @member {promise} ready returns after the book is loaded and parsed
     * @memberof Book
     * @private
     */
    this.ready = Promise.all([
      this.loaded.manifest,
      this.loaded.spine,
      this.loaded.metadata,
      this.loaded.cover,
      this.loaded.navigation,
      this.loaded.resources,
      this.loaded.displayOptions,
    ])

    // Queue for methods used before opening
    this.isRendered = false
    // this._q = queue(this);

    /**
     * @member {method} request
     * @memberof Book
     * @private
     */
    this.request = this.settings.requestMethod || request

    /**
     * @member {Spine} spine
     * @memberof Book
     */
    this.spine = new Spine()

    /**
     * @member {Locations} locations
     * @memberof Book
     */
    this.locations = new Locations(this.spine, this.load.bind(this))

    /**
     * @member {Navigation} navigation
     * @memberof Book
     */
    this.navigation = undefined

    /**
     * @member {PageList} pagelist
     * @memberof Book
     */
    this.pageList = undefined

    /**
     * @member {Url} url
     * @memberof Book
     * @private
     */
    this.url = undefined

    /**
     * @member {Path} path
     * @memberof Book
     * @private
     */
    this.path = undefined

    /**
     * @member {boolean} archived
     * @memberof Book
     * @private
     */
    this.archived = false

    /**
     * @member {Archive} archive
     * @memberof Book
     * @private
     */
    this.archive = undefined

    /**
     * @member {Store} storage
     * @memberof Book
     * @private
     */
    this.storage = undefined

    /**
     * @member {Resources} resources
     * @memberof Book
     * @private
     */
    this.resources = undefined

    /**
     * @member {Rendition} rendition
     * @memberof Book
     * @private
     */
    this.rendition = undefined

    /**
     * @member {Container} container
     * @memberof Book
     * @private
     */
    this.container = undefined

    /**
     * @member {Packaging} packaging
     * @memberof Book
     * @private
     */
    this.packaging = undefined

    /**
     * @member {DisplayOptions} displayOptions
     * @memberof DisplayOptions
     * @private
     */
    this.displayOptions = undefined

    // this.toc = undefined;
    if (this.settings.store) {
      this.store(this.settings.store)
    }

    if (url) {
      this.open(url, this.settings.openAs).catch((error) => {
        var err = new Error('Cannot load book at ' + url)
        this.emit(EVENTS.BOOK.OPEN_FAILED, err)
      })
    }
  }

  /**
   * Open a epub or url
   * @param {string | ArrayBuffer} input Url, Path or ArrayBuffer
   * @param {string} [what="binary", "base64", "epub", "opf", "json", "directory"] force opening as a certain type
   * @returns {Promise} of when the book has been loaded
   * @example book.open("/path/to/book.epub")
   */
  open(input, what) {
    var opening
    var type = what || this.determineType(input)

    if (type === INPUT_TYPE.BINARY) {
      this.archived = true
      this.url = new Url('/', '')
      opening = this.openEpub(input)
    } else if (type === INPUT_TYPE.BASE64) {
      this.archived = true
      this.url = new Url('/', '')
      opening = this.openEpub(input, type)
    } else if (type === INPUT_TYPE.EPUB) {
      this.archived = true
      this.url = new Url('/', '')
      opening = this.request(
        input,
        'binary',
        this.settings.requestCredentials,
        this.settings.requestHeaders,
      ).then(this.openEpub.bind(this))
    } else if (type == INPUT_TYPE.OPF) {
      this.url = new Url(input)
      opening = this.openPackaging(this.url.Path.toString())
    } else if (type == INPUT_TYPE.MANIFEST) {
      this.url = new Url(input)
      opening = this.openManifest(this.url.Path.toString())
    } else {
      this.url = new Url(input)
      opening = this.openContainer(CONTAINER_PATH).then(
        this.openPackaging.bind(this),
      )
    }

    return opening
  }

  /**
   * Open an archived epub
   * @private
   * @param  {binary} data
   * @param  {string} [encoding]
   * @return {Promise}
   */
  openEpub(data, encoding) {
    return this.unarchive(data, encoding || this.settings.encoding)
      .then(() => {
        return this.openContainer(CONTAINER_PATH)
      })
      .then((packagePath) => {
        return this.openPackaging(packagePath)
      })
  }

  /**
   * Open the epub container
   * @private
   * @param  {string} url
   * @return {string} packagePath
   */
  openContainer(url) {
    return this.load(url).then((xml) => {
      this.container = new Container(xml)
      return this.resolve(this.container.packagePath)
    })
  }

  /**
   * Open the Open Packaging Format Xml
   * @private
   * @param  {string} url
   * @return {Promise}
   */
  openPackaging(url) {
    this.path = new Path(url)
    return this.load(url).then((xml) => {
      this.packaging = new Packaging(xml)
      return this.unpack(this.packaging)
    })
  }

  /**
   * Open the manifest JSON
   * @private
   * @param  {string} url
   * @return {Promise}
   */
  openManifest(url) {
    this.path = new Path(url)
    return this.load(url).then((json) => {
      this.packaging = new Packaging()
      this.packaging.load(json)
      return this.unpack(this.packaging)
    })
  }

  /**
   * Load a resource from the Book
   * @param  {string} path path to the resource to load
   * @return {Promise}     returns a promise with the requested resource
   */
  load(path) {
    var resolved = this.resolve(path)
    if (this.archived) {
      return this.archive.request(resolved)
    } else {
      return this.request(
        resolved,
        null,
        this.settings.requestCredentials,
        this.settings.requestHeaders,
      )
    }
  }

  /**
   * Resolve a path to it's absolute position in the Book
   * @param  {string} path
   * @param  {boolean} [absolute] force resolving the full URL
   * @return {string}          the resolved path string
   */
  resolve(path, absolute) {
    if (!path) {
      return
    }
    var resolved = path
    var isAbsolute = path.indexOf('://') > -1

    if (isAbsolute) {
      return path
    }

    if (this.path) {
      resolved = this.path.resolve(path)
    }

    if (absolute != false && this.url) {
      resolved = this.url.resolve(resolved)
    }

    return resolved
  }

  /**
   * Get a canonical link to a path
   * @param  {string} path
   * @return {string} the canonical path string
   */
  canonical(path) {
    var url = path

    if (!path) {
      return ''
    }

    if (this.settings.canonical) {
      url = this.settings.canonical(path)
    } else {
      url = this.resolve(path, true)
    }

    return url
  }

  /**
   * Determine the type of they input passed to open
   * @private
   * @param  {string} input
   * @return {string}  binary | directory | epub | opf
   */
  determineType(input) {
    var url
    var path
    var extension

    if (this.settings.encoding === 'base64') {
      return INPUT_TYPE.BASE64
    }

    if (typeof input != 'string') {
      return INPUT_TYPE.BINARY
    }

    url = new Url(input)
    path = url.path()
    extension = path.extension

    // If there's a search string, remove it before determining type
    if (extension) {
      extension = extension.replace(/\?.*$/, '')
    }

    if (!extension) {
      return INPUT_TYPE.DIRECTORY
    }

    if (extension === 'epub') {
      return INPUT_TYPE.EPUB
    }

    if (extension === 'opf') {
      return INPUT_TYPE.OPF
    }

    if (extension === 'json') {
      return INPUT_TYPE.MANIFEST
    }
  }

  /**
   * unpack the contents of the Books packaging
   * @private
   * @param {Packaging} packaging object
   */
  unpack(packaging) {
    this.package = packaging //TODO: deprecated this

    if (this.packaging.metadata.layout === '') {
      // rendition:layout not set - check display options if book is pre-paginated
      this.load(this.url.resolve(IBOOKS_DISPLAY_OPTIONS_PATH))
        .then((xml) => {
          this.displayOptions = new DisplayOptions(xml)
          this.loading.displayOptions.resolve(this.displayOptions)
        })
        .catch((err) => {
          this.displayOptions = new DisplayOptions()
          this.loading.displayOptions.resolve(this.displayOptions)
        })
    } else {
      this.displayOptions = new DisplayOptions()
      this.loading.displayOptions.resolve(this.displayOptions)
    }

    this.spine.unpack(
      this.packaging,
      this.resolve.bind(this),
      this.canonical.bind(this),
    )

    this.resources = new Resources(this.packaging.manifest, {
      archive: this.archive,
      resolver: this.resolve.bind(this),
      request: this.request.bind(this),
      replacements:
        this.settings.replacements || (this.archived ? 'blobUrl' : 'base64'),
    })

    this.loadNavigation(this.packaging).then(() => {
      // this.toc = this.navigation.toc;
      this.loading.navigation.resolve(this.navigation)
    })

    if (this.packaging.coverPath) {
      this.cover = this.resolve(this.packaging.coverPath)
    }
    // Resolve promises
    this.loading.manifest.resolve(this.packaging.manifest)
    this.loading.metadata.resolve(this.packaging.metadata)
    this.loading.spine.resolve(this.spine)
    this.loading.cover.resolve(this.cover)
    this.loading.resources.resolve(this.resources)
    this.loading.pageList.resolve(this.pageList)

    this.isOpen = true

    if (
      this.archived ||
      (this.settings.replacements && this.settings.replacements != 'none')
    ) {
      this.replacements()
        .then(() => {
          this.loaded.displayOptions.then(() => {
            this.opening.resolve(this)
          })
        })
        .catch((err) => {
          console.error(err)
        })
    } else {
      // Resolve book opened promise
      this.loaded.displayOptions.then(() => {
        this.opening.resolve(this)
      })
    }
  }

  /**
   * Load Navigation and PageList from package
   * @private
   * @param {Packaging} packaging
   */
  loadNavigation(packaging) {
    let navPath = packaging.navPath || packaging.ncxPath
    let toc = packaging.toc

    // From json manifest
    if (toc) {
      return new Promise((resolve, reject) => {
        this.navigation = new Navigation(toc)

        if (packaging.pageList) {
          this.pageList = new PageList(packaging.pageList) // TODO: handle page lists from Manifest
        }

        resolve(this.navigation)
      })
    }

    if (!navPath) {
      return new Promise((resolve, reject) => {
        this.navigation = new Navigation()
        this.pageList = new PageList()

        resolve(this.navigation)
      })
    }

    return this.load(navPath, 'xml').then((xml) => {
      this.navigation = new Navigation(xml)
      this.pageList = new PageList(xml)
      return this.navigation
    })
  }

  /**
   * Gets a Section of the Book from the Spine
   * Alias for `book.spine.get`
   * @param {string} target
   * @return {Section}
   */
  section(target) {
    return this.spine.get(target)
  }

  /**
   * Sugar to render a book to an element
   * @param  {element | string} element element or string to add a rendition to
   * @param  {object} [options]
   * @return {Rendition}
   */
  renderTo(element, options) {
    this.rendition = new Rendition(this, options)
    this.rendition.attachTo(element)

    return this.rendition
  }

  /**
   * Set if request should use withCredentials
   * @param {boolean} credentials
   */
  setRequestCredentials(credentials) {
    this.settings.requestCredentials = credentials
  }

  /**
   * Set headers request should use
   * @param {object} headers
   */
  setRequestHeaders(headers) {
    this.settings.requestHeaders = headers
  }

  /**
   * Unarchive a zipped epub
   * @private
   * @param  {binary} input epub data
   * @param  {string} [encoding]
   * @return {Archive}
   */
  unarchive(input, encoding) {
    this.archive = new Archive()
    return this.archive.open(input, encoding)
  }

  /**
   * Store the epubs contents
   * @private
   * @param  {binary} input epub data
   * @param  {string} [encoding]
   * @return {Store}
   */
  store(name) {
    // Use "blobUrl" or "base64" for replacements
    let replacementsSetting =
      this.settings.replacements && this.settings.replacements !== 'none'
    // Save original url
    let originalUrl = this.url
    // Save original request method
    let requester = this.settings.requestMethod || request.bind(this)
    // Create new Store
    this.storage = new Store(name, requester, this.resolve.bind(this))
    // Replace request method to go through store
    this.request = this.storage.request.bind(this.storage)

    this.opened.then(() => {
      if (this.archived) {
        this.storage.requester = this.archive.request.bind(this.archive)
      }
      // Substitute hook
      let substituteResources = (output, section) => {
        section.output = this.resources.substitute(output, section.url)
      }

      // Set to use replacements
      this.resources.settings.replacements = replacementsSetting || 'blobUrl'
      // Create replacement urls
      this.resources.replacements().then(() => {
        return this.resources.replaceCss()
      })

      this.storage.on('offline', () => {
        // Remove url to use relative resolving for hrefs
        this.url = new Url('/', '')
        // Add hook to replace resources in contents
        this.spine.hooks.serialize.register(substituteResources)
      })

      this.storage.on('online', () => {
        // Restore original url
        this.url = originalUrl
        // Remove hook
        this.spine.hooks.serialize.deregister(substituteResources)
      })
    })

    return this.storage
  }

  /**
   * Get the cover url
   * @return {Promise<?string>} coverUrl
   */
  coverUrl() {
    return this.loaded.cover.then(() => {
      if (!this.cover) {
        return null
      }

      if (this.archived) {
        return this.archive.createUrl(this.cover)
      } else {
        return this.cover
      }
    })
  }

  /**
   * Load replacement urls
   * @private
   * @return {Promise} completed loading urls
   */
  replacements() {
    this.spine.hooks.serialize.register((output, section) => {
      section.output = this.resources.substitute(output, section.url)
    })

    return this.resources.replacements().then(() => {
      return this.resources.replaceCss()
    })
  }

  /**
   * Find a DOM Range for a given CFI Range
   * @param  {EpubCFI} cfiRange a epub cfi range
   * @return {Promise}
   */
  getRange(cfiRange) {
    var cfi = new EpubCFI(cfiRange)
    var item = this.spine.get(cfi.spinePos)
    var _request = this.load.bind(this)
    if (!item) {
      return new Promise((resolve, reject) => {
        reject('CFI could not be found')
      })
    }
    return item.load(_request).then(function (contents) {
      var range = cfi.toRange(item.document)
      return range
    })
  }

  /**
   * Generates the Book Key using the identifier in the manifest or other string provided
   * @param  {string} [identifier] to use instead of metadata identifier
   * @return {string} key
   */
  key(identifier) {
    var ident =
      identifier || this.packaging.metadata.identifier || this.url.filename
    return `epubjs:${EPUBJS_VERSION}:${ident}`
  }

  /**
   * Destroy the Book and all associated objects
   */
  destroy() {
    this.opened = undefined
    this.loading = undefined
    this.loaded = undefined
    this.ready = undefined

    this.isOpen = false
    this.isRendered = false

    this.spine && this.spine.destroy()
    this.locations && this.locations.destroy()
    this.pageList && this.pageList.destroy()
    this.archive && this.archive.destroy()
    this.resources && this.resources.destroy()
    this.container && this.container.destroy()
    this.packaging && this.packaging.destroy()
    this.rendition && this.rendition.destroy()
    this.displayOptions && this.displayOptions.destroy()

    this.spine = undefined
    this.locations = undefined
    this.pageList = undefined
    this.archive = undefined
    this.resources = undefined
    this.container = undefined
    this.packaging = undefined
    this.rendition = undefined

    this.navigation = undefined
    this.url = undefined
    this.path = undefined
    this.archived = false
  }
}

//-- Enable binding events to book
EventEmitter(Book.prototype)

export default Book

</code>

packages\epubjs\src\container.js:
<code>
import path from 'path-webpack'

import { qs } from './utils/core'

/**
 * Handles Parsing and Accessing an Epub Container
 * @class
 * @param {document} [containerDocument] xml document
 */
class Container {
  constructor(containerDocument) {
    this.packagePath = ''
    this.directory = ''
    this.encoding = ''

    if (containerDocument) {
      this.parse(containerDocument)
    }
  }

  /**
   * Parse the Container XML
   * @param  {document} containerDocument
   */
  parse(containerDocument) {
    //-- <rootfile full-path="OPS/package.opf" media-type="application/oebps-package+xml"/>
    var rootfile

    if (!containerDocument) {
      throw new Error('Container File Not Found')
    }

    rootfile = qs(containerDocument, 'rootfile')

    if (!rootfile) {
      throw new Error('No RootFile Found')
    }

    this.packagePath = rootfile.getAttribute('full-path')
    this.directory = path.dirname(this.packagePath)
    this.encoding = containerDocument.xmlEncoding
  }

  destroy() {
    this.packagePath = undefined
    this.directory = undefined
    this.encoding = undefined
  }
}

export default Container

</code>

packages\epubjs\src\contents.js:
<code>
import EventEmitter from 'event-emitter'

import EpubCFI from './epubcfi'
import Mapping from './mapping'
import { EPUBJS_VERSION, EVENTS, DOM_EVENTS } from './utils/constants'
import { isNumber, prefixed, borders, defaults } from './utils/core'
import { replaceLinks } from './utils/replacements'

const hasNavigator = typeof navigator !== 'undefined'

const isChrome = hasNavigator && /Chrome/.test(navigator.userAgent)
const isWebkit =
  hasNavigator && !isChrome && /AppleWebKit/.test(navigator.userAgent)

const ELEMENT_NODE = 1
const TEXT_NODE = 3

/**
 * Handles DOM manipulation, queries and events for View contents
 * @class
 * @param {document} doc Document
 * @param {element} content Parent Element (typically Body)
 * @param {string} cfiBase Section component of CFIs
 * @param {number} sectionIndex Index in Spine of Conntent's Section
 */
class Contents {
  constructor(doc, content, cfiBase, sectionIndex) {
    // Blank Cfi for Parsing
    this.epubcfi = new EpubCFI()

    this.document = doc
    this.documentElement = this.document.documentElement
    this.content = content || this.document.body
    this.window = this.document.defaultView

    this._size = {
      width: 0,
      height: 0,
    }

    this.sectionIndex = sectionIndex || 0
    this.cfiBase = cfiBase || ''

    this.epubReadingSystem('epub.js', EPUBJS_VERSION)
    this.called = 0
    this.active = true
    this.listeners()
  }

  /**
   * Get DOM events that are listened for and passed along
   */
  static get listenedEvents() {
    return DOM_EVENTS
  }

  /**
   * Get or Set width
   * @param {number} [w]
   * @returns {number} width
   */
  width(w) {
    // var frame = this.documentElement;
    var frame = this.content

    if (w && isNumber(w)) {
      w = w + 'px'
    }

    if (w) {
      frame.style.width = w
      // this.content.style.width = w;
    }

    return parseInt(this.window.getComputedStyle(frame)['width'])
  }

  /**
   * Get or Set height
   * @param {number} [h]
   * @returns {number} height
   */
  height(h) {
    // var frame = this.documentElement;
    var frame = this.content

    if (h && isNumber(h)) {
      h = h + 'px'
    }

    if (h) {
      frame.style.height = h
      // this.content.style.height = h;
    }

    return parseInt(this.window.getComputedStyle(frame)['height'])
  }

  /**
   * Get or Set width of the contents
   * @param {number} [w]
   * @returns {number} width
   */
  contentWidth(w) {
    var content = this.content || this.document.body

    if (w && isNumber(w)) {
      w = w + 'px'
    }

    if (w) {
      content.style.width = w
    }

    return parseInt(this.window.getComputedStyle(content)['width'])
  }

  /**
   * Get or Set height of the contents
   * @param {number} [h]
   * @returns {number} height
   */
  contentHeight(h) {
    var content = this.content || this.document.body

    if (h && isNumber(h)) {
      h = h + 'px'
    }

    if (h) {
      content.style.height = h
    }

    return parseInt(this.window.getComputedStyle(content)['height'])
  }

  /**
   * Get the width of the text using Range
   * @returns {number} width
   */
  textWidth() {
    let rect
    let width
    let range = this.document.createRange()
    let content = this.content || this.document.body
    let border = borders(content)

    // Select the contents of frame
    range.selectNodeContents(content)

    // get the width of the text content
    rect = range.getBoundingClientRect()
    width = rect.width

    if (border && border.width) {
      width += border.width
    }

    return Math.round(width)
  }

  /**
   * Get the height of the text using Range
   * @returns {number} height
   */
  textHeight() {
    let rect
    let height
    let range = this.document.createRange()
    let content = this.content || this.document.body

    range.selectNodeContents(content)

    rect = range.getBoundingClientRect()
    height = rect.bottom

    return Math.round(height)
  }

  /**
   * Get documentElement scrollWidth
   * @returns {number} width
   */
  scrollWidth() {
    var width = this.documentElement.scrollWidth

    return width
  }

  /**
   * Get documentElement scrollHeight
   * @returns {number} height
   */
  scrollHeight() {
    var height = this.documentElement.scrollHeight

    return height
  }

  /**
   * Set overflow css style of the contents
   * @param {string} [overflow]
   */
  overflow(overflow) {
    if (overflow) {
      this.documentElement.style.overflow = overflow
    }

    return this.window.getComputedStyle(this.documentElement)['overflow']
  }

  /**
   * Set overflowX css style of the documentElement
   * @param {string} [overflow]
   */
  overflowX(overflow) {
    if (overflow) {
      this.documentElement.style.overflowX = overflow
    }

    return this.window.getComputedStyle(this.documentElement)['overflowX']
  }

  /**
   * Set overflowY css style of the documentElement
   * @param {string} [overflow]
   */
  overflowY(overflow) {
    if (overflow) {
      this.documentElement.style.overflowY = overflow
    }

    return this.window.getComputedStyle(this.documentElement)['overflowY']
  }

  /**
   * Set Css styles on the contents element (typically Body)
   * @param {string} property
   * @param {string} value
   * @param {boolean} [priority] set as "important"
   */
  css(property, value, priority) {
    var content = this.content || this.document.body

    if (value) {
      content.style.setProperty(property, value, priority ? 'important' : '')
    } else {
      content.style.removeProperty(property)
    }

    return this.window.getComputedStyle(content)[property]
  }

  /**
   * Get or Set the viewport element
   * @param {object} [options]
   * @param {string} [options.width]
   * @param {string} [options.height]
   * @param {string} [options.scale]
   * @param {string} [options.minimum]
   * @param {string} [options.maximum]
   * @param {string} [options.scalable]
   */
  viewport(options) {
    var _width, _height, _scale, _minimum, _maximum, _scalable
    // var width, height, scale, minimum, maximum, scalable;
    var $viewport = this.document.querySelector("meta[name='viewport']")
    var parsed = {
      width: undefined,
      height: undefined,
      scale: undefined,
      minimum: undefined,
      maximum: undefined,
      scalable: undefined,
    }
    var newContent = []
    var settings = {}

    /*
     * check for the viewport size
     * <meta name="viewport" content="width=1024,height=697" />
     */
    if ($viewport && $viewport.hasAttribute('content')) {
      let content = $viewport.getAttribute('content')
      let _width = content.match(/width\s*=\s*([^,]*)/)
      let _height = content.match(/height\s*=\s*([^,]*)/)
      let _scale = content.match(/initial-scale\s*=\s*([^,]*)/)
      let _minimum = content.match(/minimum-scale\s*=\s*([^,]*)/)
      let _maximum = content.match(/maximum-scale\s*=\s*([^,]*)/)
      let _scalable = content.match(/user-scalable\s*=\s*([^,]*)/)

      if (_width && _width.length && typeof _width[1] !== 'undefined') {
        parsed.width = _width[1]
      }
      if (_height && _height.length && typeof _height[1] !== 'undefined') {
        parsed.height = _height[1]
      }
      if (_scale && _scale.length && typeof _scale[1] !== 'undefined') {
        parsed.scale = _scale[1]
      }
      if (_minimum && _minimum.length && typeof _minimum[1] !== 'undefined') {
        parsed.minimum = _minimum[1]
      }
      if (_maximum && _maximum.length && typeof _maximum[1] !== 'undefined') {
        parsed.maximum = _maximum[1]
      }
      if (
        _scalable &&
        _scalable.length &&
        typeof _scalable[1] !== 'undefined'
      ) {
        parsed.scalable = _scalable[1]
      }
    }

    settings = defaults(options || {}, parsed)

    if (options) {
      if (settings.width) {
        newContent.push('width=' + settings.width)
      }

      if (settings.height) {
        newContent.push('height=' + settings.height)
      }

      if (settings.scale) {
        newContent.push('initial-scale=' + settings.scale)
      }

      if (settings.scalable === 'no') {
        newContent.push('minimum-scale=' + settings.scale)
        newContent.push('maximum-scale=' + settings.scale)
        newContent.push('user-scalable=' + settings.scalable)
      } else {
        if (settings.scalable) {
          newContent.push('user-scalable=' + settings.scalable)
        }

        if (settings.minimum) {
          newContent.push('minimum-scale=' + settings.minimum)
        }

        if (settings.maximum) {
          newContent.push('minimum-scale=' + settings.maximum)
        }
      }

      if (!$viewport) {
        $viewport = this.document.createElement('meta')
        $viewport.setAttribute('name', 'viewport')
        this.document.querySelector('head').appendChild($viewport)
      }

      $viewport.setAttribute('content', newContent.join(', '))

      this.window.scrollTo(0, 0)
    }

    return settings
  }

  /**
   * Event emitter for when the contents has expanded
   * @private
   */
  expand() {
    this.emit(EVENTS.CONTENTS.EXPAND)
  }

  /**
   * Add DOM listeners
   * @private
   */
  listeners() {
    this.imageLoadListeners()

    this.mediaQueryListeners()

    // this.fontLoadListeners();

    this.addEventListeners()

    this.addSelectionListeners()

    // this.transitionListeners();

    if (typeof ResizeObserver === 'undefined') {
      this.resizeListeners()
      this.visibilityListeners()
    } else {
      this.resizeObservers()
    }

    // this.mutationObservers();

    this.linksHandler()
  }

  /**
   * Remove DOM listeners
   * @private
   */
  removeListeners() {
    this.removeEventListeners()

    this.removeSelectionListeners()

    if (this.observer) {
      this.observer.disconnect()
    }

    clearTimeout(this.expanding)
  }

  /**
   * Check if size of contents has changed and
   * emit 'resize' event if it has.
   * @private
   */
  resizeCheck() {
    let width = this.textWidth()
    let height = this.textHeight()

    if (width != this._size.width || height != this._size.height) {
      this._size = {
        width: width,
        height: height,
      }

      this.onResize && this.onResize(this._size)
      this.emit(EVENTS.CONTENTS.RESIZE, this._size)
    }
  }

  /**
   * Poll for resize detection
   * @private
   */
  resizeListeners() {
    var width, height
    // Test size again
    clearTimeout(this.expanding)
    requestAnimationFrame(this.resizeCheck.bind(this))
    this.expanding = setTimeout(this.resizeListeners.bind(this), 350)
  }

  /**
   * Listen for visibility of tab to change
   * @private
   */
  visibilityListeners() {
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible' && this.active === false) {
        this.active = true
        this.resizeListeners()
      } else {
        this.active = false
        clearTimeout(this.expanding)
      }
    })
  }

  /**
   * Use css transitions to detect resize
   * @private
   */
  transitionListeners() {
    let body = this.content

    body.style['transitionProperty'] =
      'font, font-size, font-size-adjust, font-stretch, font-variation-settings, font-weight, width, height'
    body.style['transitionDuration'] = '0.001ms'
    body.style['transitionTimingFunction'] = 'linear'
    body.style['transitionDelay'] = '0'

    this._resizeCheck = this.resizeCheck.bind(this)
    this.document.addEventListener('transitionend', this._resizeCheck)
  }

  /**
   * Listen for media query changes and emit 'expand' event
   * Adapted from: https://github.com/tylergaw/media-query-events/blob/master/js/mq-events.js
   * @private
   */
  mediaQueryListeners() {
    var sheets = this.document.styleSheets
    var mediaChangeHandler = function (m) {
      if (m.matches && !this._expanding) {
        setTimeout(this.expand.bind(this), 1)
      }
    }.bind(this)

    for (var i = 0; i < sheets.length; i += 1) {
      var rules
      // Firefox errors if we access cssRules cross-domain
      try {
        rules = sheets[i].cssRules
      } catch (e) {
        return
      }
      if (!rules) return // Stylesheets changed
      for (var j = 0; j < rules.length; j += 1) {
        //if (rules[j].constructor === CSSMediaRule) {
        if (rules[j].media) {
          var mql = this.window.matchMedia(rules[j].media.mediaText)
          mql.addListener(mediaChangeHandler)
          //mql.onchange = mediaChangeHandler;
        }
      }
    }
  }

  /**
   * Use ResizeObserver to listen for changes in the DOM and check for resize
   * @private
   */
  resizeObservers() {
    // create an observer instance
    this.observer = new ResizeObserver((e) => {
      requestAnimationFrame(this.resizeCheck.bind(this))
    })

    // pass in the target node
    this.observer.observe(this.document.documentElement)
  }

  /**
   * Use MutationObserver to listen for changes in the DOM and check for resize
   * @private
   */
  mutationObservers() {
    // create an observer instance
    this.observer = new MutationObserver((mutations) => {
      this.resizeCheck()
    })

    // configuration of the observer:
    let config = {
      attributes: true,
      childList: true,
      characterData: true,
      subtree: true,
    }

    // pass in the target node, as well as the observer options
    this.observer.observe(this.document, config)
  }

  /**
   * Test if images are loaded or add listener for when they load
   * @private
   */
  imageLoadListeners() {
    var images = this.document.querySelectorAll('img')
    var img
    for (var i = 0; i < images.length; i++) {
      img = images[i]

      if (typeof img.naturalWidth !== 'undefined' && img.naturalWidth === 0) {
        img.onload = this.expand.bind(this)
      }
    }
  }

  /**
   * Listen for font load and check for resize when loaded
   * @private
   */
  fontLoadListeners() {
    if (!this.document || !this.document.fonts) {
      return
    }

    this.document.fonts.ready.then(
      function () {
        this.resizeCheck()
      }.bind(this),
    )
  }

  /**
   * Get the documentElement
   * @returns {element} documentElement
   */
  root() {
    if (!this.document) return null
    return this.document.documentElement
  }

  /**
   * Get the location offset of a EpubCFI or an #id
   * @param {string | EpubCFI} target
   * @param {string} [ignoreClass] for the cfi
   * @returns { {left: Number, top: Number }
   */
  locationOf(target, ignoreClass) {
    var position
    var targetPos = { left: 0, top: 0 }

    if (!this.document) return targetPos

    if (this.epubcfi.isCfiString(target)) {
      let range = new EpubCFI(target).toRange(this.document, ignoreClass)

      if (range) {
        try {
          if (
            !range.endContainer ||
            (range.startContainer == range.endContainer &&
              range.startOffset == range.endOffset)
          ) {
            // If the end for the range is not set, it results in collapsed becoming
            // true. This in turn leads to inconsistent behaviour when calling
            // getBoundingRect. Wrong bounds lead to the wrong page being displayed.
            // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/15684911/
            let pos = range.startContainer.textContent.indexOf(
              ' ',
              range.startOffset,
            )
            if (pos == -1) {
              pos = range.startContainer.textContent.length
            }
            range.setEnd(range.startContainer, pos)
          }
        } catch (e) {
          console.error(
            'setting end offset to start container length failed',
            e,
          )
        }

        if (range.startContainer.nodeType === Node.ELEMENT_NODE) {
          position = range.startContainer.getBoundingClientRect()
          targetPos.left = position.left
          targetPos.top = position.top
        } else {
          // Webkit does not handle collapsed range bounds correctly
          // https://bugs.webkit.org/show_bug.cgi?id=138949

          // Construct a new non-collapsed range
          if (isWebkit) {
            let container = range.startContainer
            let newRange = new Range()
            try {
              if (container.nodeType === ELEMENT_NODE) {
                position = container.getBoundingClientRect()
              } else if (range.startOffset + 2 < container.length) {
                newRange.setStart(container, range.startOffset)
                newRange.setEnd(container, range.startOffset + 2)
                position = newRange.getBoundingClientRect()
              } else if (range.startOffset - 2 > 0) {
                newRange.setStart(container, range.startOffset - 2)
                newRange.setEnd(container, range.startOffset)
                position = newRange.getBoundingClientRect()
              } else {
                // empty, return the parent element
                position = container.parentNode.getBoundingClientRect()
              }
            } catch (e) {
              console.error(e, e.stack)
            }
          } else {
            position = range.getBoundingClientRect()
          }
        }
      }
    } else if (typeof target === 'string' && target.indexOf('#') > -1) {
      let id = target.substring(target.indexOf('#') + 1)
      let el = this.document.getElementById(id)
      if (el) {
        if (isWebkit) {
          // Webkit reports incorrect bounding rects in Columns
          let newRange = new Range()
          newRange.selectNode(el)
          position = newRange.getBoundingClientRect()
        } else {
          position = el.getBoundingClientRect()
        }
      }
    }

    if (position) {
      targetPos.left = position.left
      targetPos.top = position.top
    }

    return targetPos
  }

  /**
   * Append a stylesheet link to the document head
   * @param {string} src url
   */
  addStylesheet(src) {
    return new Promise(
      function (resolve, reject) {
        var $stylesheet
        var ready = false

        if (!this.document) {
          resolve(false)
          return
        }

        // Check if link already exists
        $stylesheet = this.document.querySelector("link[href='" + src + "']")
        if ($stylesheet) {
          resolve(true)
          return // already present
        }

        $stylesheet = this.document.createElement('link')
        $stylesheet.type = 'text/css'
        $stylesheet.rel = 'stylesheet'
        $stylesheet.href = src
        $stylesheet.onload = $stylesheet.onreadystatechange = function () {
          if (!ready && (!this.readyState || this.readyState == 'complete')) {
            ready = true
            // Let apply
            setTimeout(() => {
              resolve(true)
            }, 1)
          }
        }

        this.document.head.appendChild($stylesheet)
      }.bind(this),
    )
  }

  _getStylesheetNode(key) {
    var styleEl
    key = 'epubjs-inserted-css-' + (key || '')

    if (!this.document) return false

    // Check if link already exists
    styleEl = this.document.getElementById(key)
    if (!styleEl) {
      styleEl = this.document.createElement('style')
      styleEl.id = key
      // Append style element to head
      this.document.head.appendChild(styleEl)
    }
    return styleEl
  }

  /**
   * Append stylesheet css
   * @param {string} serializedCss
   * @param {string} key If the key is the same, the CSS will be replaced instead of inserted
   */
  addStylesheetCss(serializedCss, key) {
    if (!this.document || !serializedCss) return false

    var styleEl
    styleEl = this._getStylesheetNode(key)
    styleEl.innerHTML = serializedCss

    return true
  }

  /**
   * Append stylesheet rules to a generate stylesheet
   * Array: https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule
   * Object: https://github.com/desirable-objects/json-to-css
   * @param {array | object} rules
   * @param {string} key If the key is the same, the CSS will be replaced instead of inserted
   */
  addStylesheetRules(rules, key) {
    var styleSheet

    if (!this.document || !rules || rules.length === 0) return

    // Grab style sheet
    styleSheet = this._getStylesheetNode(key).sheet

    if (Object.prototype.toString.call(rules) === '[object Array]') {
      for (var i = 0, rl = rules.length; i < rl; i++) {
        var j = 1,
          rule = rules[i],
          selector = rules[i][0],
          propStr = ''
        // If the second argument of a rule is an array of arrays, correct our variables.
        if (Object.prototype.toString.call(rule[1][0]) === '[object Array]') {
          rule = rule[1]
          j = 0
        }

        for (var pl = rule.length; j < pl; j++) {
          var prop = rule[j]
          propStr +=
            prop[0] + ':' + prop[1] + (prop[2] ? ' !important' : '') + ';\n'
        }

        // Insert CSS Rule
        styleSheet.insertRule(
          selector + '{' + propStr + '}',
          styleSheet.cssRules.length,
        )
      }
    } else {
      const selectors = Object.keys(rules)
      selectors.forEach((selector) => {
        const definition = rules[selector]
        if (Array.isArray(definition)) {
          definition.forEach((item) => {
            const _rules = Object.keys(item)
            const result = _rules
              .map((rule) => {
                return `${rule}:${item[rule]}`
              })
              .join(';')
            styleSheet.insertRule(
              `${selector}{${result}}`,
              styleSheet.cssRules.length,
            )
          })
        } else {
          const _rules = Object.keys(definition)
          const result = _rules
            .map((rule) => {
              return `${rule}:${definition[rule]}`
            })
            .join(';')
          styleSheet.insertRule(
            `${selector}{${result}}`,
            styleSheet.cssRules.length,
          )
        }
      })
    }
  }

  /**
   * Append a script tag to the document head
   * @param {string} src url
   * @returns {Promise} loaded
   */
  addScript(src) {
    return new Promise(
      function (resolve, reject) {
        var $script
        var ready = false

        if (!this.document) {
          resolve(false)
          return
        }

        $script = this.document.createElement('script')
        $script.type = 'text/javascript'
        $script.async = true
        $script.src = src
        $script.onload = $script.onreadystatechange = function () {
          if (!ready && (!this.readyState || this.readyState == 'complete')) {
            ready = true
            setTimeout(function () {
              resolve(true)
            }, 1)
          }
        }

        this.document.head.appendChild($script)
      }.bind(this),
    )
  }

  /**
   * Add a class to the contents container
   * @param {string} className
   */
  addClass(className) {
    var content

    if (!this.document) return

    content = this.content || this.document.body

    if (content) {
      content.classList.add(className)
    }
  }

  /**
   * Remove a class from the contents container
   * @param {string} removeClass
   */
  removeClass(className) {
    var content

    if (!this.document) return

    content = this.content || this.document.body

    if (content) {
      content.classList.remove(className)
    }
  }

  /**
   * Add DOM event listeners
   * @private
   */
  addEventListeners() {
    if (!this.document) {
      return
    }

    this._triggerEvent = this.triggerEvent.bind(this)

    DOM_EVENTS.forEach(function (eventName) {
      this.document.addEventListener(eventName, this._triggerEvent, {
        passive: true,
      })
    }, this)
  }

  /**
   * Remove DOM event listeners
   * @private
   */
  removeEventListeners() {
    if (!this.document) {
      return
    }
    DOM_EVENTS.forEach(function (eventName) {
      this.document.removeEventListener(eventName, this._triggerEvent, {
        passive: true,
      })
    }, this)
    this._triggerEvent = undefined
  }

  /**
   * Emit passed browser events
   * @private
   */
  triggerEvent(e) {
    this.emit(e.type, e)
  }

  /**
   * Add listener for text selection
   * @private
   */
  addSelectionListeners() {
    if (!this.document) {
      return
    }
    this._onSelectionChange = this.onSelectionChange.bind(this)
    this.document.addEventListener('selectionchange', this._onSelectionChange, {
      passive: true,
    })
  }

  /**
   * Remove listener for text selection
   * @private
   */
  removeSelectionListeners() {
    if (!this.document) {
      return
    }
    this.document.removeEventListener(
      'selectionchange',
      this._onSelectionChange,
      { passive: true },
    )
    this._onSelectionChange = undefined
  }

  /**
   * Handle getting text on selection
   * @private
   */
  onSelectionChange(e) {
    if (this.selectionEndTimeout) {
      clearTimeout(this.selectionEndTimeout)
    }
    this.selectionEndTimeout = setTimeout(
      function () {
        var selection = this.window.getSelection()
        this.triggerSelectedEvent(selection)
      }.bind(this),
      250,
    )
  }

  /**
   * Emit event on text selection
   * @private
   */
  triggerSelectedEvent(selection) {
    var range, cfirange

    if (selection && selection.rangeCount > 0) {
      range = selection.getRangeAt(0)
      if (!range.collapsed) {
        // cfirange = this.section.cfiFromRange(range);
        cfirange = new EpubCFI(range, this.cfiBase).toString()
        this.emit(EVENTS.CONTENTS.SELECTED, cfirange)
        this.emit(EVENTS.CONTENTS.SELECTED_RANGE, range)
      }
    }
  }

  /**
   * Get a Dom Range from EpubCFI
   * @param {EpubCFI} _cfi
   * @param {string} [ignoreClass]
   * @returns {Range} range
   */
  range(_cfi, ignoreClass) {
    var cfi = new EpubCFI(_cfi)
    return cfi.toRange(this.document, ignoreClass)
  }

  /**
   * Get an EpubCFI from a Dom Range
   * @param {Range} range
   * @param {string} [ignoreClass]
   * @returns {EpubCFI} cfi
   */
  cfiFromRange(range, ignoreClass) {
    return new EpubCFI(range, this.cfiBase, ignoreClass).toString()
  }

  /**
   * Get an EpubCFI from a Dom node
   * @param {node} node
   * @param {string} [ignoreClass]
   * @returns {EpubCFI} cfi
   */
  cfiFromNode(node, ignoreClass) {
    return new EpubCFI(node, this.cfiBase, ignoreClass).toString()
  }

  // TODO: find where this is used - remove?
  map(layout) {
    var map = new Mapping(layout)
    return map.section()
  }

  /**
   * Size the contents to a given width and height
   * @param {number} [width]
   * @param {number} [height]
   */
  size(width, height) {
    var viewport = { scale: 1.0, scalable: 'no' }

    this.layoutStyle('scrolling')

    if (width >= 0) {
      this.width(width)
      viewport.width = width
      this.css('padding', '0 ' + width / 12 + 'px')
    }

    if (height >= 0) {
      this.height(height)
      viewport.height = height
    }

    this.css('margin', '0')
    this.css('box-sizing', 'border-box')

    this.viewport(viewport)
  }

  /**
   * Apply columns to the contents for pagination
   * @param {number} width
   * @param {number} height
   * @param {number} columnWidth
   * @param {number} gap
   */
  columns(width, height, columnWidth, gap, dir) {
    let COLUMN_AXIS = prefixed('column-axis')
    let COLUMN_GAP = prefixed('column-gap')
    let COLUMN_WIDTH = prefixed('column-width')
    let COLUMN_FILL = prefixed('column-fill')

    let writingMode = this.writingMode()
    let axis = writingMode.indexOf('vertical') === 0 ? 'vertical' : 'horizontal'

    this.layoutStyle('paginated')

    if (dir === 'rtl' && axis === 'horizontal') {
      this.direction(dir)
    }

    this.width(width)
    this.height(height)

    // Deal with Mobile trying to scale to viewport
    this.viewport({ width: width, height: height, scale: 1.0, scalable: 'no' })

    // TODO: inline-block needs more testing
    // Fixes Safari column cut offs, but causes RTL issues
    // this.css("display", "inline-block");

    this.css('overflow-y', 'hidden')
    this.css('margin', '0', true)

    if (axis === 'vertical') {
      this.css('padding-top', gap / 2 + 'px')
      this.css('padding-bottom', gap / 2 + 'px')
      this.css('padding-left', '20px')
      this.css('padding-right', '20px')
      this.css(COLUMN_AXIS, 'vertical')
    } else {
      this.css('padding-top', '20px')
      this.css('padding-bottom', '20px')
      this.css('padding-left', gap / 2 + 'px')
      this.css('padding-right', gap / 2 + 'px')
      this.css(COLUMN_AXIS, 'horizontal')
    }

    this.css('box-sizing', 'border-box')
    this.css('max-width', 'inherit')

    this.css(COLUMN_FILL, 'auto')

    this.css(COLUMN_GAP, gap + 'px')
    this.css(COLUMN_WIDTH, columnWidth + 'px')

    // Fix glyph clipping in WebKit
    // https://github.com/futurepress/epub.js/issues/983
    this.css('-webkit-line-box-contain', 'block glyphs replaced')
  }

  /**
   * Scale contents from center
   * @param {number} scale
   * @param {number} offsetX
   * @param {number} offsetY
   */
  scaler(scale, offsetX, offsetY) {
    var scaleStr = 'scale(' + scale + ')'
    var translateStr = ''
    // this.css("position", "absolute"));
    this.css('transform-origin', 'top left')

    if (offsetX >= 0 || offsetY >= 0) {
      translateStr =
        ' translate(' + (offsetX || 0) + 'px, ' + (offsetY || 0) + 'px )'
    }

    this.css('transform', scaleStr + translateStr)
  }

  /**
   * Fit contents into a fixed width and height
   * @param {number} width
   * @param {number} height
   */
  fit(width, height, section) {
    var viewport = this.viewport()
    var viewportWidth = parseInt(viewport.width)
    var viewportHeight = parseInt(viewport.height)
    var widthScale = width / viewportWidth
    var heightScale = height / viewportHeight
    var scale = widthScale < heightScale ? widthScale : heightScale

    // the translate does not work as intended, elements can end up unaligned
    // var offsetY = (height - (viewportHeight * scale)) / 2;
    // var offsetX = 0;
    // if (this.sectionIndex % 2 === 1) {
    // 	offsetX = width - (viewportWidth * scale);
    // }

    this.layoutStyle('paginated')

    // scale needs width and height to be set
    this.width(viewportWidth)
    this.height(viewportHeight)
    this.overflow('hidden')

    // Scale to the correct size
    this.scaler(scale, 0, 0)
    // this.scaler(scale, offsetX > 0 ? offsetX : 0, offsetY);

    // background images are not scaled by transform
    this.css(
      'background-size',
      viewportWidth * scale + 'px ' + viewportHeight * scale + 'px',
    )

    this.css('background-color', 'transparent')
    if (section && section.properties.includes('page-spread-left')) {
      // set margin since scale is weird
      var marginLeft = width - viewportWidth * scale
      this.css('margin-left', marginLeft + 'px')
    }
  }

  /**
   * Set the direction of the text
   * @param {string} [dir="ltr"] "rtl" | "ltr"
   */
  direction(dir) {
    if (this.documentElement) {
      this.documentElement.style['direction'] = dir
    }
  }

  mapPage(cfiBase, layout, start, end, dev) {
    var mapping = new Mapping(layout, dev)

    return mapping.page(this, cfiBase, start, end)
  }

  /**
   * Emit event when link in content is clicked
   * @private
   */
  linksHandler() {
    replaceLinks(this.content, (href) => {
      this.emit(EVENTS.CONTENTS.LINK_CLICKED, href)
    })
  }

  /**
   * Set the writingMode of the text
   * @param {string} [mode="horizontal-tb"] "horizontal-tb" | "vertical-rl" | "vertical-lr"
   */
  writingMode(mode) {
    let WRITING_MODE = prefixed('writing-mode')

    if (mode && this.documentElement) {
      this.documentElement.style[WRITING_MODE] = mode
    }

    return (
      this.window.getComputedStyle(this.documentElement)[WRITING_MODE] || ''
    )
  }

  /**
   * Set the layoutStyle of the content
   * @param {string} [style="paginated"] "scrolling" | "paginated"
   * @private
   */
  layoutStyle(style) {
    if (style) {
      this._layoutStyle = style
      navigator.epubReadingSystem.layoutStyle = this._layoutStyle
    }

    return this._layoutStyle || 'paginated'
  }

  /**
   * Add the epubReadingSystem object to the navigator
   * @param {string} name
   * @param {string} version
   * @private
   */
  epubReadingSystem(name, version) {
    navigator.epubReadingSystem = {
      name: name,
      version: version,
      layoutStyle: this.layoutStyle(),
      hasFeature: function (feature) {
        switch (feature) {
          case 'dom-manipulation':
            return true
          case 'layout-changes':
            return true
          case 'touch-events':
            return true
          case 'mouse-events':
            return true
          case 'keyboard-events':
            return true
          case 'spine-scripting':
            return false
          default:
            return false
        }
      },
    }
    return navigator.epubReadingSystem
  }

  destroy() {
    // this.document.removeEventListener('transitionend', this._resizeCheck);

    this.removeListeners()
  }
}

EventEmitter(Contents.prototype)

export default Contents

</code>

packages\epubjs\src\displayoptions.js:
<code>
import { qs, qsa } from './utils/core'

/**
 * Open DisplayOptions Format Parser
 * @class
 * @param {document} displayOptionsDocument XML
 */
class DisplayOptions {
  constructor(displayOptionsDocument) {
    this.interactive = ''
    this.fixedLayout = ''
    this.openToSpread = ''
    this.orientationLock = ''

    if (displayOptionsDocument) {
      this.parse(displayOptionsDocument)
    }
  }

  /**
   * Parse XML
   * @param  {document} displayOptionsDocument XML
   * @return {DisplayOptions} self
   */
  parse(displayOptionsDocument) {
    if (!displayOptionsDocument) {
      return this
    }

    const displayOptionsNode = qs(displayOptionsDocument, 'display_options')
    if (!displayOptionsNode) {
      return this
    }

    const options = qsa(displayOptionsNode, 'option')
    options.forEach((el) => {
      let value = ''

      if (el.childNodes.length) {
        value = el.childNodes[0].nodeValue
      }

      switch (el.attributes.name.value) {
        case 'interactive':
          this.interactive = value
          break
        case 'fixed-layout':
          this.fixedLayout = value
          break
        case 'open-to-spread':
          this.openToSpread = value
          break
        case 'orientation-lock':
          this.orientationLock = value
          break
      }
    })

    return this
  }

  destroy() {
    this.interactive = undefined
    this.fixedLayout = undefined
    this.openToSpread = undefined
    this.orientationLock = undefined
  }
}

export default DisplayOptions

</code>

packages\epubjs\src\epub.js:
<code>
import Book from './book'
import Contents from './contents'
import CFI from './epubcfi'
import ContinuousViewManager from './managers/continuous'
import DefaultViewManager from './managers/default'
import IframeView from './managers/views/iframe'
import Rendition from './rendition'
import { EPUBJS_VERSION } from './utils/constants'
import * as utils from './utils/core'

/**
 * Creates a new Book
 * @param {string|ArrayBuffer} url URL, Path or ArrayBuffer
 * @param {object} options to pass to the book
 * @returns {Book} a new Book object
 * @example ePub("/path/to/book.epub", {})
 */
function ePub(url, options) {
  return new Book(url, options)
}

ePub.VERSION = EPUBJS_VERSION

if (typeof global !== 'undefined') {
  global.EPUBJS_VERSION = EPUBJS_VERSION
}

ePub.Book = Book
ePub.Rendition = Rendition
ePub.Contents = Contents
ePub.CFI = CFI
ePub.utils = utils

export default ePub

</code>

packages\epubjs\src\epubcfi.js:
<code>
import { extend, type, findChildren, RangeObject, isNumber } from './utils/core'

const ELEMENT_NODE = 1
const TEXT_NODE = 3
const COMMENT_NODE = 8
const DOCUMENT_NODE = 9

/**
	* Parsing and creation of EpubCFIs: http://www.idpf.org/epub/linking/cfi/epub-cfi.html

	* Implements:
	* - Character Offset: epubcfi(/6/4[chap01ref]!/4[body01]/10[para05]/2/1:3)
	* - Simple Ranges : epubcfi(/6/4[chap01ref]!/4[body01]/10[para05],/2/1:1,/3:4)

	* Does Not Implement:
	* - Temporal Offset (~)
	* - Spatial Offset (@)
	* - Temporal-Spatial Offset (~ + @)
	* - Text Location Assertion ([)
	* @class
	@param {string | Range | Node } [cfiFrom]
	@param {string | object} [base]
	@param {string} [ignoreClass] class to ignore when parsing DOM
*/
class EpubCFI {
  constructor(cfiFrom, base, ignoreClass) {
    var type

    this.str = ''

    this.base = {}
    this.spinePos = 0 // For compatibility

    this.range = false // true || false;

    this.path = {}
    this.start = null
    this.end = null

    // Allow instantiation without the "new" keyword
    if (!(this instanceof EpubCFI)) {
      return new EpubCFI(cfiFrom, base, ignoreClass)
    }

    if (typeof base === 'string') {
      this.base = this.parseComponent(base)
    } else if (typeof base === 'object' && base.steps) {
      this.base = base
    }

    type = this.checkType(cfiFrom)

    if (type === 'string') {
      this.str = cfiFrom
      return extend(this, this.parse(cfiFrom))
    } else if (type === 'range') {
      return extend(this, this.fromRange(cfiFrom, this.base, ignoreClass))
    } else if (type === 'node') {
      return extend(this, this.fromNode(cfiFrom, this.base, ignoreClass))
    } else if (type === 'EpubCFI' && cfiFrom.path) {
      return cfiFrom
    } else if (!cfiFrom) {
      return this
    } else {
      throw new TypeError('not a valid argument for EpubCFI')
    }
  }

  /**
   * Check the type of constructor input
   * @private
   */
  checkType(cfi) {
    if (this.isCfiString(cfi)) {
      return 'string'
      // Is a range object
    } else if (
      cfi &&
      typeof cfi === 'object' &&
      (type(cfi) === 'Range' || typeof cfi.startContainer != 'undefined')
    ) {
      return 'range'
    } else if (
      cfi &&
      typeof cfi === 'object' &&
      typeof cfi.nodeType != 'undefined'
    ) {
      // || typeof cfi === "function"
      return 'node'
    } else if (cfi && typeof cfi === 'object' && cfi instanceof EpubCFI) {
      return 'EpubCFI'
    } else {
      return false
    }
  }

  /**
   * Parse a cfi string to a CFI object representation
   * @param {string} cfiStr
   * @returns {object} cfi
   */
  parse(cfiStr) {
    var cfi = {
      spinePos: -1,
      range: false,
      base: {},
      path: {},
      start: null,
      end: null,
    }
    var baseComponent, pathComponent, range

    if (typeof cfiStr !== 'string') {
      return { spinePos: -1 }
    }

    if (cfiStr.indexOf('epubcfi(') === 0 && cfiStr[cfiStr.length - 1] === ')') {
      // Remove initial epubcfi( and ending )
      cfiStr = cfiStr.slice(8, cfiStr.length - 1)
    }

    baseComponent = this.getChapterComponent(cfiStr)

    // Make sure this is a valid cfi or return
    if (!baseComponent) {
      return { spinePos: -1 }
    }

    cfi.base = this.parseComponent(baseComponent)

    pathComponent = this.getPathComponent(cfiStr)
    cfi.path = this.parseComponent(pathComponent)

    range = this.getRange(cfiStr)

    if (range) {
      cfi.range = true
      cfi.start = this.parseComponent(range[0])
      cfi.end = this.parseComponent(range[1])
    }

    // Get spine node position
    // cfi.spineSegment = cfi.base.steps[1];

    // Chapter segment is always the second step
    cfi.spinePos = cfi.base.steps[1].index

    return cfi
  }

  parseComponent(componentStr) {
    var component = {
      steps: [],
      terminal: {
        offset: null,
        assertion: null,
      },
    }
    var parts = componentStr.split(':')
    var steps = parts[0].split('/')
    var terminal

    if (parts.length > 1) {
      terminal = parts[1]
      component.terminal = this.parseTerminal(terminal)
    }

    if (steps[0] === '') {
      steps.shift() // Ignore the first slash
    }

    component.steps = steps.map(
      function (step) {
        return this.parseStep(step)
      }.bind(this),
    )

    return component
  }

  parseStep(stepStr) {
    var type, num, index, has_brackets, id

    has_brackets = stepStr.match(/\[(.*)\]/)
    if (has_brackets && has_brackets[1]) {
      id = has_brackets[1]
    }

    //-- Check if step is a text node or element
    num = parseInt(stepStr)

    if (isNaN(num)) {
      return
    }

    if (num % 2 === 0) {
      // Even = is an element
      type = 'element'
      index = num / 2 - 1
    } else {
      type = 'text'
      index = (num - 1) / 2
    }

    return {
      type: type,
      index: index,
      id: id || null,
    }
  }

  parseTerminal(termialStr) {
    var characterOffset, textLocationAssertion
    var assertion = termialStr.match(/\[(.*)\]/)

    if (assertion && assertion[1]) {
      characterOffset = parseInt(termialStr.split('[')[0])
      textLocationAssertion = assertion[1]
    } else {
      characterOffset = parseInt(termialStr)
    }

    if (!isNumber(characterOffset)) {
      characterOffset = null
    }

    return {
      offset: characterOffset,
      assertion: textLocationAssertion,
    }
  }

  getChapterComponent(cfiStr) {
    var indirection = cfiStr.split('!')

    return indirection[0]
  }

  getPathComponent(cfiStr) {
    var indirection = cfiStr.split('!')

    if (indirection[1]) {
      let ranges = indirection[1].split(',')
      return ranges[0]
    }
  }

  getRange(cfiStr) {
    var ranges = cfiStr.split(',')

    if (ranges.length === 3) {
      return [ranges[1], ranges[2]]
    }

    return false
  }

  getCharecterOffsetComponent(cfiStr) {
    var splitStr = cfiStr.split(':')
    return splitStr[1] || ''
  }

  joinSteps(steps) {
    if (!steps) {
      return ''
    }

    return steps
      .map(function (part) {
        var segment = ''

        if (part.type === 'element') {
          segment += (part.index + 1) * 2
        }

        if (part.type === 'text') {
          segment += 1 + 2 * part.index // TODO: double check that this is odd
        }

        if (part.id) {
          segment += '[' + part.id + ']'
        }

        return segment
      })
      .join('/')
  }

  segmentString(segment) {
    var segmentString = '/'

    segmentString += this.joinSteps(segment.steps)

    if (segment.terminal && segment.terminal.offset != null) {
      segmentString += ':' + segment.terminal.offset
    }

    if (segment.terminal && segment.terminal.assertion != null) {
      segmentString += '[' + segment.terminal.assertion + ']'
    }

    return segmentString
  }

  /**
   * Convert CFI to a epubcfi(...) string
   * @returns {string} epubcfi
   */
  toString() {
    var cfiString = 'epubcfi('

    cfiString += this.segmentString(this.base)

    cfiString += '!'
    cfiString += this.segmentString(this.path)

    // Add Range, if present
    if (this.range && this.start) {
      cfiString += ','
      cfiString += this.segmentString(this.start)
    }

    if (this.range && this.end) {
      cfiString += ','
      cfiString += this.segmentString(this.end)
    }

    cfiString += ')'

    return cfiString
  }

  /**
   * Compare which of two CFIs is earlier in the text
   * @returns {number} First is earlier = -1, Second is earlier = 1, They are equal = 0
   */
  compare(cfiOne, cfiTwo) {
    var stepsA, stepsB
    var terminalA, terminalB

    var rangeAStartSteps, rangeAEndSteps
    var rangeBEndSteps, rangeBEndSteps
    var rangeAStartTerminal, rangeAEndTerminal
    var rangeBStartTerminal, rangeBEndTerminal

    if (typeof cfiOne === 'string') {
      cfiOne = new EpubCFI(cfiOne)
    }
    if (typeof cfiTwo === 'string') {
      cfiTwo = new EpubCFI(cfiTwo)
    }
    // Compare Spine Positions
    if (cfiOne.spinePos > cfiTwo.spinePos) {
      return 1
    }
    if (cfiOne.spinePos < cfiTwo.spinePos) {
      return -1
    }

    if (cfiOne.range) {
      stepsA = cfiOne.path.steps.concat(cfiOne.start.steps)
      terminalA = cfiOne.start.terminal
    } else {
      stepsA = cfiOne.path.steps
      terminalA = cfiOne.path.terminal
    }

    if (cfiTwo.range) {
      stepsB = cfiTwo.path.steps.concat(cfiTwo.start.steps)
      terminalB = cfiTwo.start.terminal
    } else {
      stepsB = cfiTwo.path.steps
      terminalB = cfiTwo.path.terminal
    }

    // Compare Each Step in the First item
    for (var i = 0; i < stepsA.length; i++) {
      if (!stepsA[i]) {
        return -1
      }
      if (!stepsB[i]) {
        return 1
      }
      if (stepsA[i].index > stepsB[i].index) {
        return 1
      }
      if (stepsA[i].index < stepsB[i].index) {
        return -1
      }
      // Otherwise continue checking
    }

    // All steps in First equal to Second and First is Less Specific
    if (stepsA.length < stepsB.length) {
      return -1
    }

    // Compare the character offset of the text node
    if (terminalA.offset > terminalB.offset) {
      return 1
    }
    if (terminalA.offset < terminalB.offset) {
      return -1
    }

    // CFI's are equal
    return 0
  }

  step(node) {
    var nodeType = node.nodeType === TEXT_NODE ? 'text' : 'element'

    return {
      id: node.id,
      tagName: node.tagName,
      type: nodeType,
      index: this.position(node),
    }
  }

  filteredStep(node, ignoreClass) {
    var filteredNode = this.filter(node, ignoreClass)
    var nodeType

    // Node filtered, so ignore
    if (!filteredNode) {
      return
    }

    // Otherwise add the filter node in
    nodeType = filteredNode.nodeType === TEXT_NODE ? 'text' : 'element'

    return {
      id: filteredNode.id,
      tagName: filteredNode.tagName,
      type: nodeType,
      index: this.filteredPosition(filteredNode, ignoreClass),
    }
  }

  pathTo(node, offset, ignoreClass) {
    var segment = {
      steps: [],
      terminal: {
        offset: null,
        assertion: null,
      },
    }
    var currentNode = node
    var step

    while (
      currentNode &&
      currentNode.parentNode &&
      currentNode.parentNode.nodeType != DOCUMENT_NODE
    ) {
      if (ignoreClass) {
        step = this.filteredStep(currentNode, ignoreClass)
      } else {
        step = this.step(currentNode)
      }

      if (step) {
        segment.steps.unshift(step)
      }

      currentNode = currentNode.parentNode
    }

    if (offset != null && offset >= 0) {
      segment.terminal.offset = offset

      // Make sure we are getting to a textNode if there is an offset
      if (segment.steps[segment.steps.length - 1].type != 'text') {
        segment.steps.push({
          type: 'text',
          index: 0,
        })
      }
    }

    return segment
  }

  equalStep(stepA, stepB) {
    if (!stepA || !stepB) {
      return false
    }

    if (
      stepA.index === stepB.index &&
      stepA.id === stepB.id &&
      stepA.type === stepB.type
    ) {
      return true
    }

    return false
  }

  /**
   * Create a CFI object from a Range
   * @param {Range} range
   * @param {string | object} base
   * @param {string} [ignoreClass]
   * @returns {object} cfi
   */
  fromRange(range, base, ignoreClass) {
    var cfi = {
      range: false,
      base: {},
      path: {},
      start: null,
      end: null,
    }

    var start = range.startContainer
    var end = range.endContainer

    var startOffset = range.startOffset
    var endOffset = range.endOffset

    var needsIgnoring = false

    if (ignoreClass) {
      // Tell pathTo if / what to ignore
      needsIgnoring =
        start.ownerDocument.querySelector('.' + ignoreClass) != null
    }

    if (typeof base === 'string') {
      cfi.base = this.parseComponent(base)
      cfi.spinePos = cfi.base.steps[1].index
    } else if (typeof base === 'object') {
      cfi.base = base
    }

    if (range.collapsed) {
      if (needsIgnoring) {
        startOffset = this.patchOffset(start, startOffset, ignoreClass)
      }
      cfi.path = this.pathTo(start, startOffset, ignoreClass)
    } else {
      cfi.range = true

      if (needsIgnoring) {
        startOffset = this.patchOffset(start, startOffset, ignoreClass)
      }

      cfi.start = this.pathTo(start, startOffset, ignoreClass)
      if (needsIgnoring) {
        endOffset = this.patchOffset(end, endOffset, ignoreClass)
      }

      cfi.end = this.pathTo(end, endOffset, ignoreClass)

      // Create a new empty path
      cfi.path = {
        steps: [],
        terminal: null,
      }

      // Push steps that are shared between start and end to the common path
      var len = cfi.start.steps.length
      var i

      for (i = 0; i < len; i++) {
        if (this.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {
          if (i === len - 1) {
            // Last step is equal, check terminals
            if (cfi.start.terminal === cfi.end.terminal) {
              // CFI's are equal
              cfi.path.steps.push(cfi.start.steps[i])
              // Not a range
              cfi.range = false
            }
          } else {
            cfi.path.steps.push(cfi.start.steps[i])
          }
        } else {
          break
        }
      }

      cfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length)
      cfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length)

      // TODO: Add Sanity check to make sure that the end if greater than the start
    }

    return cfi
  }

  /**
   * Create a CFI object from a Node
   * @param {Node} anchor
   * @param {string | object} base
   * @param {string} [ignoreClass]
   * @returns {object} cfi
   */
  fromNode(anchor, base, ignoreClass) {
    var cfi = {
      range: false,
      base: {},
      path: {},
      start: null,
      end: null,
    }

    if (typeof base === 'string') {
      cfi.base = this.parseComponent(base)
      cfi.spinePos = cfi.base.steps[1].index
    } else if (typeof base === 'object') {
      cfi.base = base
    }

    cfi.path = this.pathTo(anchor, null, ignoreClass)

    return cfi
  }

  filter(anchor, ignoreClass) {
    var needsIgnoring
    var sibling // to join with
    var parent, previousSibling, nextSibling
    var isText = false

    if (anchor.nodeType === TEXT_NODE) {
      isText = true
      parent = anchor.parentNode
      needsIgnoring = anchor.parentNode.classList.contains(ignoreClass)
    } else {
      isText = false
      needsIgnoring = anchor.classList.contains(ignoreClass)
    }

    if (needsIgnoring && isText) {
      previousSibling = parent.previousSibling
      nextSibling = parent.nextSibling

      // If the sibling is a text node, join the nodes
      if (previousSibling && previousSibling.nodeType === TEXT_NODE) {
        sibling = previousSibling
      } else if (nextSibling && nextSibling.nodeType === TEXT_NODE) {
        sibling = nextSibling
      }

      if (sibling) {
        return sibling
      } else {
        // Parent will be ignored on next step
        return anchor
      }
    } else if (needsIgnoring && !isText) {
      // Otherwise just skip the element node
      return false
    } else {
      // No need to filter
      return anchor
    }
  }

  patchOffset(anchor, offset, ignoreClass) {
    if (anchor.nodeType != TEXT_NODE) {
      throw new Error('Anchor must be a text node')
    }

    var curr = anchor
    var totalOffset = offset

    // If the parent is a ignored node, get offset from it's start
    if (anchor.parentNode.classList.contains(ignoreClass)) {
      curr = anchor.parentNode
    }

    while (curr.previousSibling) {
      if (curr.previousSibling.nodeType === ELEMENT_NODE) {
        // Originally a text node, so join
        if (curr.previousSibling.classList.contains(ignoreClass)) {
          totalOffset += curr.previousSibling.textContent.length
        } else {
          break // Normal node, dont join
        }
      } else {
        // If the previous sibling is a text node, join the nodes
        totalOffset += curr.previousSibling.textContent.length
      }

      curr = curr.previousSibling
    }

    return totalOffset
  }

  normalizedMap(children, nodeType, ignoreClass) {
    var output = {}
    var prevIndex = -1
    var i,
      len = children.length
    var currNodeType
    var prevNodeType

    for (i = 0; i < len; i++) {
      currNodeType = children[i].nodeType

      // Check if needs ignoring
      if (
        currNodeType === ELEMENT_NODE &&
        children[i].classList.contains(ignoreClass)
      ) {
        currNodeType = TEXT_NODE
      }

      if (i > 0 && currNodeType === TEXT_NODE && prevNodeType === TEXT_NODE) {
        // join text nodes
        output[i] = prevIndex
      } else if (nodeType === currNodeType) {
        prevIndex = prevIndex + 1
        output[i] = prevIndex
      }

      prevNodeType = currNodeType
    }

    return output
  }

  position(anchor) {
    var children, index
    if (anchor.nodeType === ELEMENT_NODE) {
      children = anchor.parentNode.children
      if (!children) {
        children = findChildren(anchor.parentNode)
      }
      index = Array.prototype.indexOf.call(children, anchor)
    } else {
      children = this.textNodes(anchor.parentNode)
      index = children.indexOf(anchor)
    }

    return index
  }

  filteredPosition(anchor, ignoreClass) {
    var children, index, map

    if (anchor.nodeType === ELEMENT_NODE) {
      children = anchor.parentNode.children
      map = this.normalizedMap(children, ELEMENT_NODE, ignoreClass)
    } else {
      children = anchor.parentNode.childNodes
      // Inside an ignored node
      if (anchor.parentNode.classList.contains(ignoreClass)) {
        anchor = anchor.parentNode
        children = anchor.parentNode.childNodes
      }
      map = this.normalizedMap(children, TEXT_NODE, ignoreClass)
    }

    index = Array.prototype.indexOf.call(children, anchor)

    return map[index]
  }

  stepsToXpath(steps) {
    var xpath = ['.', '*']

    steps.forEach(function (step) {
      var position = step.index + 1

      if (step.id) {
        xpath.push('*[position()=' + position + " and @id='" + step.id + "']")
      } else if (step.type === 'text') {
        xpath.push('text()[' + position + ']')
      } else {
        xpath.push('*[' + position + ']')
      }
    })

    return xpath.join('/')
  }

  /*

	To get the last step if needed:

	// Get the terminal step
	lastStep = steps[steps.length-1];
	// Get the query string
	query = this.stepsToQuery(steps);
	// Find the containing element
	startContainerParent = doc.querySelector(query);
	// Find the text node within that element
	if(startContainerParent && lastStep.type == "text") {
		container = startContainerParent.childNodes[lastStep.index];
	}
	*/
  stepsToQuerySelector(steps) {
    var query = ['html']

    steps.forEach(function (step) {
      var position = step.index + 1

      if (step.id) {
        query.push('#' + step.id)
      } else if (step.type === 'text') {
        // unsupported in querySelector
        // query.push("text()[" + position + "]");
      } else {
        query.push('*:nth-child(' + position + ')')
      }
    })

    return query.join('>')
  }

  textNodes(container, ignoreClass) {
    return Array.prototype.slice
      .call(container.childNodes)
      .filter(function (node) {
        if (node.nodeType === TEXT_NODE) {
          return true
        } else if (ignoreClass && node.classList.contains(ignoreClass)) {
          return true
        }
        return false
      })
  }

  walkToNode(steps, _doc, ignoreClass) {
    var doc = _doc || document
    var container = doc.documentElement
    var children
    var step
    var len = steps.length
    var i

    for (i = 0; i < len; i++) {
      step = steps[i]

      if (step.type === 'element') {
        //better to get a container using id as some times step.index may not be correct
        //For ex.https://github.com/futurepress/epub.js/issues/561
        if (step.id) {
          container = doc.getElementById(step.id)
        } else {
          children = container.children || findChildren(container)
          container = children[step.index]
        }
      } else if (step.type === 'text') {
        container = this.textNodes(container, ignoreClass)[step.index]
      }
      if (!container) {
        //Break the for loop as due to incorrect index we can get error if
        //container is undefined so that other functionailties works fine
        //like navigation
        break
      }
    }

    return container
  }

  findNode(steps, _doc, ignoreClass) {
    var doc = _doc || document
    var container
    var xpath

    if (!ignoreClass && typeof doc.evaluate != 'undefined') {
      xpath = this.stepsToXpath(steps)
      container = doc.evaluate(
        xpath,
        doc,
        null,
        XPathResult.FIRST_ORDERED_NODE_TYPE,
        null,
      ).singleNodeValue
    } else if (ignoreClass) {
      container = this.walkToNode(steps, doc, ignoreClass)
    } else {
      container = this.walkToNode(steps, doc)
    }

    return container
  }

  fixMiss(steps, offset, _doc, ignoreClass) {
    var container = this.findNode(steps.slice(0, -1), _doc, ignoreClass)
    var children = container.childNodes
    var map = this.normalizedMap(children, TEXT_NODE, ignoreClass)
    var child
    var len
    var lastStepIndex = steps[steps.length - 1].index

    for (let childIndex in map) {
      if (!map.hasOwnProperty(childIndex)) return

      if (map[childIndex] === lastStepIndex) {
        child = children[childIndex]
        len = child.textContent.length
        if (offset > len) {
          offset = offset - len
        } else {
          if (child.nodeType === ELEMENT_NODE) {
            container = child.childNodes[0]
          } else {
            container = child
          }
          break
        }
      }
    }

    return {
      container: container,
      offset: offset,
    }
  }

  /**
   * Creates a DOM range representing a CFI
   * @param {document} _doc document referenced in the base
   * @param {string} [ignoreClass]
   * @return {Range}
   */
  toRange(_doc, ignoreClass) {
    var doc = _doc || document
    var range
    var start, end, startContainer, endContainer
    var cfi = this
    var startSteps, endSteps
    var needsIgnoring = ignoreClass
      ? doc.querySelector('.' + ignoreClass) != null
      : false
    var missed

    if (typeof doc.createRange !== 'undefined') {
      range = doc.createRange()
    } else {
      range = new RangeObject()
    }

    if (cfi.range) {
      start = cfi.start
      startSteps = cfi.path.steps.concat(start.steps)
      startContainer = this.findNode(
        startSteps,
        doc,
        needsIgnoring ? ignoreClass : null,
      )
      end = cfi.end
      endSteps = cfi.path.steps.concat(end.steps)
      endContainer = this.findNode(
        endSteps,
        doc,
        needsIgnoring ? ignoreClass : null,
      )
    } else {
      start = cfi.path
      startSteps = cfi.path.steps
      startContainer = this.findNode(
        cfi.path.steps,
        doc,
        needsIgnoring ? ignoreClass : null,
      )
    }

    if (startContainer) {
      try {
        if (start.terminal.offset != null) {
          range.setStart(startContainer, start.terminal.offset)
        } else {
          range.setStart(startContainer, 0)
        }
      } catch (e) {
        missed = this.fixMiss(
          startSteps,
          start.terminal.offset,
          doc,
          needsIgnoring ? ignoreClass : null,
        )
        range.setStart(missed.container, missed.offset)
      }
    } else {
      console.log('No startContainer found for', this.toString())
      // No start found
      return null
    }

    if (endContainer) {
      try {
        if (end.terminal.offset != null) {
          range.setEnd(endContainer, end.terminal.offset)
        } else {
          range.setEnd(endContainer, 0)
        }
      } catch (e) {
        missed = this.fixMiss(
          endSteps,
          cfi.end.terminal.offset,
          doc,
          needsIgnoring ? ignoreClass : null,
        )
        range.setEnd(missed.container, missed.offset)
      }
    }

    // doc.defaultView.getSelection().addRange(range);
    return range
  }

  /**
   * Check if a string is wrapped with "epubcfi()"
   * @param {string} str
   * @returns {boolean}
   */
  isCfiString(str) {
    if (
      typeof str === 'string' &&
      str.indexOf('epubcfi(') === 0 &&
      str[str.length - 1] === ')'
    ) {
      return true
    }

    return false
  }

  generateChapterComponent(_spineNodeIndex, _pos, id) {
    var pos = parseInt(_pos),
      spineNodeIndex = (_spineNodeIndex + 1) * 2,
      cfi = '/' + spineNodeIndex + '/'

    cfi += (pos + 1) * 2

    if (id) {
      cfi += '[' + id + ']'
    }

    return cfi
  }

  /**
   * Collapse a CFI Range to a single CFI Position
   * @param {boolean} [toStart=false]
   */
  collapse(toStart) {
    if (!this.range) {
      return
    }

    this.range = false

    if (toStart) {
      this.path.steps = this.path.steps.concat(this.start.steps)
      this.path.terminal = this.start.terminal
    } else {
      this.path.steps = this.path.steps.concat(this.end.steps)
      this.path.terminal = this.end.terminal
    }
  }
}

export default EpubCFI

</code>

packages\epubjs\src\index.js:
<code>
import Book from './book'
import Contents from './contents'
import ePub from './epub'
import EpubCFI from './epubcfi'
import Layout from './layout'
import Rendition from './rendition'

export default ePub
export { Book, EpubCFI, Rendition, Contents, Layout }

</code>

packages\epubjs\src\layout.js:
<code>
import EventEmitter from 'event-emitter'

import { EVENTS } from './utils/constants'
import { extend } from './utils/core'

/**
 * Figures out the CSS values to apply for a layout
 * @class
 * @param {object} settings
 * @param {string} [settings.layout='reflowable']
 * @param {string} [settings.spread]
 * @param {number} [settings.minSpreadWidth=800]
 * @param {boolean} [settings.evenSpreads=false]
 */
class Layout {
  constructor(settings) {
    this.settings = settings
    this.name = settings.layout || 'reflowable'
    this._spread = settings.spread === 'none' ? false : true
    this._minSpreadWidth = settings.minSpreadWidth || 800
    this._evenSpreads = settings.evenSpreads || false

    if (
      settings.flow === 'scrolled' ||
      settings.flow === 'scrolled-continuous' ||
      settings.flow === 'scrolled-doc'
    ) {
      this._flow = 'scrolled'
    } else {
      this._flow = 'paginated'
    }

    this.width = 0
    this.height = 0
    this.spreadWidth = 0
    this.delta = 0

    this.columnWidth = 0
    this.gap = 0
    this.divisor = 1

    this.props = {
      name: this.name,
      spread: this._spread,
      flow: this._flow,
      width: 0,
      height: 0,
      spreadWidth: 0,
      delta: 0,
      columnWidth: 0,
      gap: 0,
      divisor: 1,
    }
  }

  /**
   * Switch the flow between paginated and scrolled
   * @param  {string} flow paginated | scrolled
   * @return {string} simplified flow
   */
  flow(flow) {
    if (typeof flow != 'undefined') {
      if (
        flow === 'scrolled' ||
        flow === 'scrolled-continuous' ||
        flow === 'scrolled-doc'
      ) {
        this._flow = 'scrolled'
      } else {
        this._flow = 'paginated'
      }
      // this.props.flow = this._flow;
      this.update({ flow: this._flow })
    }
    return this._flow
  }

  /**
   * Switch between using spreads or not, and set the
   * width at which they switch to single.
   * @param  {string} spread "none" | "always" | "auto"
   * @param  {number} min integer in pixels
   * @return {boolean} spread true | false
   */
  spread(spread, min) {
    if (spread) {
      this._spread = spread === 'none' ? false : true
      // this.props.spread = this._spread;
      this.update({ spread: this._spread })
    }

    if (min >= 0) {
      this._minSpreadWidth = min
    }

    return this._spread
  }

  /**
   * Calculate the dimensions of the pagination
   * @param  {number} _width  width of the rendering
   * @param  {number} _height height of the rendering
   * @param  {number} _gap    width of the gap between columns
   */
  calculate(_width, _height, _gap) {
    var divisor = 1
    var gap = _gap || 0

    //-- Check the width and create even width columns
    // var fullWidth = Math.floor(_width);
    var width = _width
    var height = _height

    var section = Math.floor(width / 12)

    var columnWidth
    var spreadWidth
    var pageWidth
    var delta

    if (this._spread && width >= this._minSpreadWidth) {
      divisor = 2
    } else {
      divisor = 1
    }

    if (
      this.name === 'reflowable' &&
      this._flow === 'paginated' &&
      !(_gap >= 0)
    ) {
      gap = section % 2 === 0 ? section : section - 1
    }

    if (this.name === 'pre-paginated') {
      gap = 0
    }

    //-- Double Page
    if (divisor > 1) {
      // width = width - gap;
      // columnWidth = (width - gap) / divisor;
      // gap = gap / divisor;
      columnWidth = width / divisor - gap
      pageWidth = columnWidth + gap
    } else {
      columnWidth = width
      pageWidth = width
    }

    if (this.name === 'pre-paginated' && divisor > 1) {
      width = columnWidth
    }

    spreadWidth = columnWidth * divisor + gap

    delta = width

    this.width = width
    this.height = height
    this.spreadWidth = spreadWidth
    this.pageWidth = pageWidth
    this.delta = delta

    this.columnWidth = columnWidth
    this.gap = gap
    this.divisor = divisor

    // this.props.width = width;
    // this.props.height = _height;
    // this.props.spreadWidth = spreadWidth;
    // this.props.pageWidth = pageWidth;
    // this.props.delta = delta;
    //
    // this.props.columnWidth = colWidth;
    // this.props.gap = gap;
    // this.props.divisor = divisor;

    this.update({
      width,
      height,
      spreadWidth,
      pageWidth,
      delta,
      columnWidth,
      gap,
      divisor,
    })
  }

  /**
   * Apply Css to a Document
   * @param  {Contents} contents
   * @return {Promise}
   */
  format(contents, section, axis) {
    var formating

    if (this.name === 'pre-paginated') {
      formating = contents.fit(this.columnWidth, this.height, section)
    } else if (this._flow === 'paginated') {
      formating = contents.columns(
        this.width,
        this.height,
        this.columnWidth,
        this.gap,
        this.settings.direction,
      )
    } else if (axis && axis === 'horizontal') {
      formating = contents.size(null, this.height)
    } else {
      formating = contents.size(this.width, null)
    }

    return formating // might be a promise in some View Managers
  }

  /**
   * Count number of pages
   * @param  {number} totalLength
   * @param  {number} pageLength
   * @return {{spreads: Number, pages: Number}}
   */
  count(totalLength, pageLength) {
    let spreads, pages

    if (this.name === 'pre-paginated') {
      spreads = 1
      pages = 1
    } else if (this._flow === 'paginated') {
      pageLength = pageLength || this.delta
      spreads = Math.ceil(totalLength / pageLength)
      pages = spreads * this.divisor
    } else {
      // scrolled
      pageLength = pageLength || this.height
      spreads = Math.ceil(totalLength / pageLength)
      pages = spreads
    }

    return {
      spreads,
      pages,
    }
  }

  /**
   * Update props that have changed
   * @private
   * @param  {object} props
   */
  update(props) {
    // Remove props that haven't changed
    Object.keys(props).forEach((propName) => {
      if (this.props[propName] === props[propName]) {
        delete props[propName]
      }
    })

    if (Object.keys(props).length > 0) {
      let newProps = extend(this.props, props)
      this.emit(EVENTS.LAYOUT.UPDATED, newProps, props)
    }
  }
}

EventEmitter(Layout.prototype)

export default Layout

</code>

packages\epubjs\src\locations.js:
<code>
import EventEmitter from 'event-emitter'

import EpubCFI from './epubcfi'
import { EVENTS } from './utils/constants'
import { qs, sprint, locationOf, defer } from './utils/core'
import Queue from './utils/queue'

/**
 * Find Locations for a Book
 * @param {Spine} spine
 * @param {request} request
 * @param {number} [pause=100]
 */
class Locations {
  constructor(spine, request, pause) {
    this.spine = spine
    this.request = request
    this.pause = pause || 100

    this.q = new Queue(this)
    this.epubcfi = new EpubCFI()

    this._locations = []
    this._locationsWords = []
    this.total = 0

    this.break = 150

    this._current = 0

    this._wordCounter = 0

    this.currentLocation = ''
    this._currentCfi = ''
    this.processingTimeout = undefined
  }

  /**
   * Load all of sections in the book to generate locations
   * @param  {int} chars how many chars to split on
   * @return {Promise<Array<string>>} locations
   */
  generate(chars) {
    if (chars) {
      this.break = chars
    }

    this.q.pause()

    this.spine.each(
      function (section) {
        if (section.linear) {
          this.q.enqueue(this.process.bind(this), section)
        }
      }.bind(this),
    )

    return this.q.run().then(
      function () {
        this.total = this._locations.length - 1

        if (this._currentCfi) {
          this.currentLocation = this._currentCfi
        }

        return this._locations
        // console.log(this.percentage(this.book.rendition.location.start), this.percentage(this.book.rendition.location.end));
      }.bind(this),
    )
  }

  createRange() {
    return {
      startContainer: undefined,
      startOffset: undefined,
      endContainer: undefined,
      endOffset: undefined,
    }
  }

  process(section) {
    return section.load(this.request).then(
      function (contents) {
        var completed = new defer()
        var locations = this.parse(contents, section.cfiBase)
        this._locations = this._locations.concat(locations)

        section.unload()

        this.processingTimeout = setTimeout(
          () => completed.resolve(locations),
          this.pause,
        )
        return completed.promise
      }.bind(this),
    )
  }

  parse(contents, cfiBase, chars) {
    var locations = []
    var range
    var doc = contents.ownerDocument
    var body = qs(doc, 'body')
    var counter = 0
    var prev
    var _break = chars || this.break
    var parser = function (node) {
      var len = node.length
      var dist
      var pos = 0

      if (node.textContent.trim().length === 0) {
        return false // continue
      }

      // Start range
      if (counter == 0) {
        range = this.createRange()
        range.startContainer = node
        range.startOffset = 0
      }

      dist = _break - counter

      // Node is smaller than a break,
      // skip over it
      if (dist > len) {
        counter += len
        pos = len
      }

      while (pos < len) {
        dist = _break - counter

        if (counter === 0) {
          // Start new range
          pos += 1
          range = this.createRange()
          range.startContainer = node
          range.startOffset = pos
        }

        // pos += dist;

        // Gone over
        if (pos + dist >= len) {
          // Continue counter for next node
          counter += len - pos
          // break
          pos = len
          // At End
        } else {
          // Advance pos
          pos += dist

          // End the previous range
          range.endContainer = node
          range.endOffset = pos
          // cfi = section.cfiFromRange(range);
          let cfi = new EpubCFI(range, cfiBase).toString()
          locations.push(cfi)
          counter = 0
        }
      }
      prev = node
    }

    sprint(body, parser.bind(this))

    // Close remaining
    if (range && range.startContainer && prev) {
      range.endContainer = prev
      range.endOffset = prev.length
      let cfi = new EpubCFI(range, cfiBase).toString()
      locations.push(cfi)
      counter = 0
    }

    return locations
  }

  /**
   * Load all of sections in the book to generate locations
   * @param  {string} startCfi start position
   * @param  {int} wordCount how many words to split on
   * @param  {int} count result count
   * @return {object} locations
   */
  generateFromWords(startCfi, wordCount, count) {
    var start = startCfi ? new EpubCFI(startCfi) : undefined
    this.q.pause()
    this._locationsWords = []
    this._wordCounter = 0

    this.spine.each(
      function (section) {
        if (section.linear) {
          if (start) {
            if (section.index >= start.spinePos) {
              this.q.enqueue(
                this.processWords.bind(this),
                section,
                wordCount,
                start,
                count,
              )
            }
          } else {
            this.q.enqueue(
              this.processWords.bind(this),
              section,
              wordCount,
              start,
              count,
            )
          }
        }
      }.bind(this),
    )

    return this.q.run().then(
      function () {
        if (this._currentCfi) {
          this.currentLocation = this._currentCfi
        }

        return this._locationsWords
      }.bind(this),
    )
  }

  processWords(section, wordCount, startCfi, count) {
    if (count && this._locationsWords.length >= count) {
      return Promise.resolve()
    }

    return section.load(this.request).then(
      function (contents) {
        var completed = new defer()
        var locations = this.parseWords(contents, section, wordCount, startCfi)
        var remainingCount = count - this._locationsWords.length
        this._locationsWords = this._locationsWords.concat(
          locations.length >= count
            ? locations.slice(0, remainingCount)
            : locations,
        )

        section.unload()

        this.processingTimeout = setTimeout(
          () => completed.resolve(locations),
          this.pause,
        )
        return completed.promise
      }.bind(this),
    )
  }

  //http://stackoverflow.com/questions/18679576/counting-words-in-string
  countWords(s) {
    s = s.replace(/(^\s*)|(\s*$)/gi, '') //exclude  start and end white-space
    s = s.replace(/[ ]{2,}/gi, ' ') //2 or more space to 1
    s = s.replace(/\n /, '\n') // exclude newline with a start spacing
    return s.split(' ').length
  }

  parseWords(contents, section, wordCount, startCfi) {
    var cfiBase = section.cfiBase
    var locations = []
    var doc = contents.ownerDocument
    var body = qs(doc, 'body')
    var prev
    var _break = wordCount
    var foundStartNode = startCfi ? startCfi.spinePos !== section.index : true
    var startNode
    if (startCfi && section.index === startCfi.spinePos) {
      startNode = startCfi.findNode(
        startCfi.range
          ? startCfi.path.steps.concat(startCfi.start.steps)
          : startCfi.path.steps,
        contents.ownerDocument,
      )
    }
    var parser = function (node) {
      if (!foundStartNode) {
        if (node === startNode) {
          foundStartNode = true
        } else {
          return false
        }
      }
      if (node.textContent.length < 10) {
        if (node.textContent.trim().length === 0) {
          return false
        }
      }
      var len = this.countWords(node.textContent)
      var dist
      var pos = 0

      if (len === 0) {
        return false // continue
      }

      dist = _break - this._wordCounter

      // Node is smaller than a break,
      // skip over it
      if (dist > len) {
        this._wordCounter += len
        pos = len
      }

      while (pos < len) {
        dist = _break - this._wordCounter

        // Gone over
        if (pos + dist >= len) {
          // Continue counter for next node
          this._wordCounter += len - pos
          // break
          pos = len
          // At End
        } else {
          // Advance pos
          pos += dist

          let cfi = new EpubCFI(node, cfiBase)
          locations.push({ cfi: cfi.toString(), wordCount: this._wordCounter })
          this._wordCounter = 0
        }
      }
      prev = node
    }

    sprint(body, parser.bind(this))

    return locations
  }

  /**
   * Get a location from an EpubCFI
   * @param {EpubCFI} cfi
   * @return {number}
   */
  locationFromCfi(cfi) {
    let loc
    if (EpubCFI.prototype.isCfiString(cfi)) {
      cfi = new EpubCFI(cfi)
    }
    // Check if the location has not been set yet
    if (this._locations.length === 0) {
      return -1
    }

    loc = locationOf(cfi, this._locations, this.epubcfi.compare)

    if (loc > this.total) {
      return this.total
    }

    return loc
  }

  /**
   * Get a percentage position in locations from an EpubCFI
   * @param {EpubCFI} cfi
   * @return {number}
   */
  percentageFromCfi(cfi) {
    if (this._locations.length === 0) {
      return null
    }
    // Find closest cfi
    var loc = this.locationFromCfi(cfi)
    // Get percentage in total
    return this.percentageFromLocation(loc)
  }

  /**
   * Get a percentage position from a location index
   * @param {number} location
   * @return {number}
   */
  percentageFromLocation(loc) {
    if (!loc || !this.total) {
      return 0
    }

    return loc / this.total
  }

  /**
   * Get an EpubCFI from location index
   * @param {number} loc
   * @return {EpubCFI} cfi
   */
  cfiFromLocation(loc) {
    var cfi = -1
    // check that pg is an int
    if (typeof loc != 'number') {
      loc = parseInt(loc)
    }

    if (loc >= 0 && loc < this._locations.length) {
      cfi = this._locations[loc]
    }

    return cfi
  }

  /**
   * Get an EpubCFI from location percentage
   * @param {number} percentage
   * @return {EpubCFI} cfi
   */
  cfiFromPercentage(percentage) {
    let loc
    if (percentage > 1) {
      console.warn('Normalize cfiFromPercentage value to between 0 - 1')
    }

    // Make sure 1 goes to very end
    if (percentage >= 1) {
      let cfi = new EpubCFI(this._locations[this.total])
      cfi.collapse()
      return cfi.toString()
    }

    loc = Math.ceil(this.total * percentage)
    return this.cfiFromLocation(loc)
  }

  /**
   * Load locations from JSON
   * @param {json} locations
   */
  load(locations) {
    if (typeof locations === 'string') {
      this._locations = JSON.parse(locations)
    } else {
      this._locations = locations
    }
    this.total = this._locations.length - 1
    return this._locations
  }

  /**
   * Save locations to JSON
   * @return {json}
   */
  save() {
    return JSON.stringify(this._locations)
  }

  getCurrent() {
    return this._current
  }

  setCurrent(curr) {
    var loc

    if (typeof curr == 'string') {
      this._currentCfi = curr
    } else if (typeof curr == 'number') {
      this._current = curr
    } else {
      return
    }

    if (this._locations.length === 0) {
      return
    }

    if (typeof curr == 'string') {
      loc = this.locationFromCfi(curr)
      this._current = loc
    } else {
      loc = curr
    }

    this.emit(EVENTS.LOCATIONS.CHANGED, {
      percentage: this.percentageFromLocation(loc),
    })
  }

  /**
   * Get the current location
   */
  get currentLocation() {
    return this._current
  }

  /**
   * Set the current location
   */
  set currentLocation(curr) {
    this.setCurrent(curr)
  }

  /**
   * Locations length
   */
  length() {
    return this._locations.length
  }

  destroy() {
    this.spine = undefined
    this.request = undefined
    this.pause = undefined

    this.q.stop()
    this.q = undefined
    this.epubcfi = undefined

    this._locations = undefined
    this.total = undefined

    this.break = undefined
    this._current = undefined

    this.currentLocation = undefined
    this._currentCfi = undefined
    clearTimeout(this.processingTimeout)
  }
}

EventEmitter(Locations.prototype)

export default Locations

</code>

packages\epubjs\src\mapping.js:
<code>
import EpubCFI from './epubcfi'
import { nodeBounds } from './utils/core'

/**
 * Map text locations to CFI ranges
 * @class
 * @param {Layout} layout Layout to apply
 * @param {string} [direction="ltr"] Text direction
 * @param {string} [axis="horizontal"] vertical or horizontal axis
 * @param {boolean} [dev] toggle developer highlighting
 */
class Mapping {
  constructor(layout, direction, axis, dev = false) {
    this.layout = layout
    this.horizontal = axis === 'horizontal' ? true : false
    this.direction = direction || 'ltr'
    this._dev = dev
  }

  /**
   * Find CFI pairs for entire section at once
   */
  section(view) {
    var ranges = this.findRanges(view)
    var map = this.rangeListToCfiList(view.section.cfiBase, ranges)

    return map
  }

  /**
   * Find CFI pairs for a page
   * @param {Contents} contents Contents from view
   * @param {string} cfiBase string of the base for a cfi
   * @param {number} start position to start at
   * @param {number} end position to end at
   */
  page(contents, cfiBase, start, end) {
    var root = contents && contents.document ? contents.document.body : false
    var result

    if (!root) {
      return
    }

    result = this.rangePairToCfiPair(cfiBase, {
      start: this.findStart(root, start, end),
      end: this.findEnd(root, start, end),
    })

    if (this._dev === true) {
      let doc = contents.document
      let startRange = new EpubCFI(result.start).toRange(doc)
      let endRange = new EpubCFI(result.end).toRange(doc)

      let selection = doc.defaultView.getSelection()
      let r = doc.createRange()
      selection.removeAllRanges()
      r.setStart(startRange.startContainer, startRange.startOffset)
      r.setEnd(endRange.endContainer, endRange.endOffset)
      selection.addRange(r)
    }

    return result
  }

  /**
   * Walk a node, preforming a function on each node it finds
   * @private
   * @param {Node} root Node to walkToNode
   * @param {function} func walk function
   * @return {*} returns the result of the walk function
   */
  walk(root, func) {
    // IE11 has strange issue, if root is text node IE throws exception on
    // calling treeWalker.nextNode(), saying
    // Unexpected call to method or property access instead of returning null value
    if (root && root.nodeType === Node.TEXT_NODE) {
      return
    }
    // safeFilter is required so that it can work in IE as filter is a function for IE
    // and for other browser filter is an object.
    var filter = {
      acceptNode: function (node) {
        if (node.data.trim().length > 0) {
          return NodeFilter.FILTER_ACCEPT
        } else {
          return NodeFilter.FILTER_REJECT
        }
      },
    }
    var safeFilter = filter.acceptNode
    safeFilter.acceptNode = filter.acceptNode

    var treeWalker = document.createTreeWalker(
      root,
      NodeFilter.SHOW_TEXT,
      safeFilter,
      false,
    )
    var node
    var result
    while ((node = treeWalker.nextNode())) {
      result = func(node)
      if (result) break
    }

    return result
  }

  findRanges(view) {
    var columns = []
    var scrollWidth = view.contents.scrollWidth()
    var spreads = Math.ceil(scrollWidth / this.layout.spreadWidth)
    var count = spreads * this.layout.divisor
    var columnWidth = this.layout.columnWidth
    var gap = this.layout.gap
    var start, end

    for (var i = 0; i < count.pages; i++) {
      start = (columnWidth + gap) * i
      end = columnWidth * (i + 1) + gap * i
      columns.push({
        start: this.findStart(view.document.body, start, end),
        end: this.findEnd(view.document.body, start, end),
      })
    }

    return columns
  }

  /**
   * Find Start Range
   * @private
   * @param {Node} root root node
   * @param {number} start position to start at
   * @param {number} end position to end at
   * @return {Range}
   */
  findStart(root, start, end) {
    var stack = [root]
    var $el
    var found
    var $prev = root

    while (stack.length) {
      $el = stack.shift()

      found = this.walk($el, (node) => {
        var left, right, top, bottom
        var elPos
        var elRange

        elPos = nodeBounds(node)

        if (this.horizontal && this.direction === 'ltr') {
          left = this.horizontal ? elPos.left : elPos.top
          right = this.horizontal ? elPos.right : elPos.bottom

          if (left >= start && left <= end) {
            return node
          } else if (right > start) {
            return node
          } else {
            $prev = node
            stack.push(node)
          }
        } else if (this.horizontal && this.direction === 'rtl') {
          left = elPos.left
          right = elPos.right

          if (right <= end && right >= start) {
            return node
          } else if (left < end) {
            return node
          } else {
            $prev = node
            stack.push(node)
          }
        } else {
          top = elPos.top
          bottom = elPos.bottom

          if (top >= start && top <= end) {
            return node
          } else if (bottom > start) {
            return node
          } else {
            $prev = node
            stack.push(node)
          }
        }
      })

      if (found) {
        return this.findTextStartRange(found, start, end)
      }
    }

    // Return last element
    return this.findTextStartRange($prev, start, end)
  }

  /**
   * Find End Range
   * @private
   * @param {Node} root root node
   * @param {number} start position to start at
   * @param {number} end position to end at
   * @return {Range}
   */
  findEnd(root, start, end) {
    var stack = [root]
    var $el
    var $prev = root
    var found

    while (stack.length) {
      $el = stack.shift()

      found = this.walk($el, (node) => {
        var left, right, top, bottom
        var elPos
        var elRange

        elPos = nodeBounds(node)

        if (this.horizontal && this.direction === 'ltr') {
          left = Math.round(elPos.left)
          right = Math.round(elPos.right)

          if (left > end && $prev) {
            return $prev
          } else if (right > end) {
            return node
          } else {
            $prev = node
            stack.push(node)
          }
        } else if (this.horizontal && this.direction === 'rtl') {
          left = Math.round(this.horizontal ? elPos.left : elPos.top)
          right = Math.round(this.horizontal ? elPos.right : elPos.bottom)

          if (right < start && $prev) {
            return $prev
          } else if (left < start) {
            return node
          } else {
            $prev = node
            stack.push(node)
          }
        } else {
          top = Math.round(elPos.top)
          bottom = Math.round(elPos.bottom)

          if (top > end && $prev) {
            return $prev
          } else if (bottom > end) {
            return node
          } else {
            $prev = node
            stack.push(node)
          }
        }
      })

      if (found) {
        return this.findTextEndRange(found, start, end)
      }
    }

    // end of chapter
    return this.findTextEndRange($prev, start, end)
  }

  /**
   * Find Text Start Range
   * @private
   * @param {Node} root root node
   * @param {number} start position to start at
   * @param {number} end position to end at
   * @return {Range}
   */
  findTextStartRange(node, start, end) {
    var ranges = this.splitTextNodeIntoRanges(node)
    var range
    var pos
    var left, top, right

    for (var i = 0; i < ranges.length; i++) {
      range = ranges[i]

      pos = range.getBoundingClientRect()

      if (this.horizontal && this.direction === 'ltr') {
        left = pos.left
        if (left >= start) {
          return range
        }
      } else if (this.horizontal && this.direction === 'rtl') {
        right = pos.right
        if (right <= end) {
          return range
        }
      } else {
        top = pos.top
        if (top >= start) {
          return range
        }
      }

      // prev = range;
    }

    return ranges[0]
  }

  /**
   * Find Text End Range
   * @private
   * @param {Node} root root node
   * @param {number} start position to start at
   * @param {number} end position to end at
   * @return {Range}
   */
  findTextEndRange(node, start, end) {
    var ranges = this.splitTextNodeIntoRanges(node)
    var prev
    var range
    var pos
    var left, right, top, bottom

    for (var i = 0; i < ranges.length; i++) {
      range = ranges[i]

      pos = range.getBoundingClientRect()

      if (this.horizontal && this.direction === 'ltr') {
        left = pos.left
        right = pos.right

        if (left > end && prev) {
          return prev
        } else if (right > end) {
          return range
        }
      } else if (this.horizontal && this.direction === 'rtl') {
        left = pos.left
        right = pos.right

        if (right < start && prev) {
          return prev
        } else if (left < start) {
          return range
        }
      } else {
        top = pos.top
        bottom = pos.bottom

        if (top > end && prev) {
          return prev
        } else if (bottom > end) {
          return range
        }
      }

      prev = range
    }

    // Ends before limit
    return ranges[ranges.length - 1]
  }

  /**
   * Split up a text node into ranges for each word
   * @private
   * @param {Node} root root node
   * @param {string} [_splitter] what to split on
   * @return {Range[]}
   */
  splitTextNodeIntoRanges(node, _splitter) {
    var ranges = []
    var textContent = node.textContent || ''
    var text = textContent.trim()
    var range
    var doc = node.ownerDocument
    var splitter = _splitter || ' '

    var pos = text.indexOf(splitter)

    if (pos === -1 || node.nodeType != Node.TEXT_NODE) {
      range = doc.createRange()
      range.selectNodeContents(node)
      return [range]
    }

    range = doc.createRange()
    range.setStart(node, 0)
    range.setEnd(node, pos)
    ranges.push(range)
    range = false

    while (pos != -1) {
      pos = text.indexOf(splitter, pos + 1)
      if (pos > 0) {
        if (range) {
          range.setEnd(node, pos)
          ranges.push(range)
        }

        range = doc.createRange()
        range.setStart(node, pos + 1)
      }
    }

    if (range) {
      range.setEnd(node, text.length)
      ranges.push(range)
    }

    return ranges
  }

  /**
   * Turn a pair of ranges into a pair of CFIs
   * @private
   * @param {string} cfiBase base string for an EpubCFI
   * @param {object} rangePair { start: Range, end: Range }
   * @return {object} { start: "epubcfi(...)", end: "epubcfi(...)" }
   */
  rangePairToCfiPair(cfiBase, rangePair) {
    var startRange = rangePair.start
    var endRange = rangePair.end

    startRange.collapse(true)
    endRange.collapse(false)

    let startCfi = new EpubCFI(startRange, cfiBase).toString()
    let endCfi = new EpubCFI(endRange, cfiBase).toString()

    return {
      start: startCfi,
      end: endCfi,
    }
  }

  rangeListToCfiList(cfiBase, columns) {
    var map = []
    var cifPair

    for (var i = 0; i < columns.length; i++) {
      cifPair = this.rangePairToCfiPair(cfiBase, columns[i])

      map.push(cifPair)
    }

    return map
  }

  /**
   * Set the axis for mapping
   * @param {string} axis horizontal | vertical
   * @return {boolean} is it horizontal?
   */
  axis(axis) {
    if (axis) {
      this.horizontal = axis === 'horizontal' ? true : false
    }
    return this.horizontal
  }
}

export default Mapping

</code>

packages\epubjs\src\navigation.js:
<code>
import {
  qs,
  qsa,
  querySelectorByType,
  filterChildren,
  getParentByTagName,
} from './utils/core'

/**
 * Navigation Parser
 * @param {document} xml navigation html / xhtml / ncx
 */
class Navigation {
  constructor(xml) {
    this.toc = []
    this.tocByHref = {}
    this.tocById = {}

    this.landmarks = []
    this.landmarksByType = {}

    this.length = 0
    if (xml) {
      this.parse(xml)
    }
  }

  /**
   * Parse out the navigation items
   * @param {document} xml navigation html / xhtml / ncx
   */
  parse(xml) {
    let isXml = xml.nodeType
    let html
    let ncx

    if (isXml) {
      html = qs(xml, 'html')
      ncx = qs(xml, 'ncx')
    }

    if (!isXml) {
      this.toc = this.load(xml)
    } else if (html) {
      this.toc = this.parseNav(xml)
      this.landmarks = this.parseLandmarks(xml)
    } else if (ncx) {
      this.toc = this.parseNcx(xml)
    }

    this.length = 0

    this.unpack(this.toc)
  }

  /**
   * Unpack navigation items
   * @private
   * @param  {array} toc
   */
  unpack(toc) {
    var item

    for (var i = 0; i < toc.length; i++) {
      item = toc[i]

      if (item.href) {
        this.tocByHref[item.href] = i
      }

      if (item.id) {
        this.tocById[item.id] = i
      }

      this.length++

      if (item.subitems.length) {
        this.unpack(item.subitems)
      }
    }
  }

  /**
   * Get an item from the navigation
   * @param  {string} target
   * @return {object} navItem
   */
  get(target) {
    var index

    if (!target) {
      return this.toc
    }

    if (target.indexOf('#') === 0) {
      index = this.tocById[target.substring(1)]
    } else if (target in this.tocByHref) {
      index = this.tocByHref[target]
    }

    return this.getByIndex(target, index, this.toc)
  }

  /**
   * Get an item from navigation subitems recursively by index
   * @param  {string} target
   * @param  {number} index
   * @param  {array} navItems
   * @return {object} navItem
   */
  getByIndex(target, index, navItems) {
    if (navItems.length === 0) {
      return
    }

    const item = navItems[index]
    if (item && (target === item.id || target === item.href)) {
      return item
    } else {
      let result
      for (let i = 0; i < navItems.length; ++i) {
        result = this.getByIndex(target, index, navItems[i].subitems)
        if (result) {
          break
        }
      }
      return result
    }
  }

  /**
   * Get a landmark by type
   * List of types: https://idpf.github.io/epub-vocabs/structure/
   * @param  {string} type
   * @return {object} landmarkItem
   */
  landmark(type) {
    var index

    if (!type) {
      return this.landmarks
    }

    index = this.landmarksByType[type]

    return this.landmarks[index]
  }

  /**
   * Parse toc from a Epub > 3.0 Nav
   * @private
   * @param  {document} navHtml
   * @return {array} navigation list
   */
  parseNav(navHtml) {
    var navElement = querySelectorByType(navHtml, 'nav', 'toc')
    var list = []

    if (!navElement) return list

    let navList = filterChildren(navElement, 'ol', true)
    if (!navList) return list

    list = this.parseNavList(navList)
    return list
  }

  /**
   * Parses lists in the toc
   * @param  {document} navListHtml
   * @param  {string} parent id
   * @return {array} navigation list
   */
  parseNavList(navListHtml, parent) {
    const result = []

    if (!navListHtml) return result
    if (!navListHtml.children) return result

    for (let i = 0; i < navListHtml.children.length; i++) {
      const item = this.navItem(navListHtml.children[i], parent)

      if (item) {
        result.push(item)
      }
    }

    return result
  }

  /**
   * Create a navItem
   * @private
   * @param  {element} item
   * @return {object} navItem
   */
  navItem(item, parent) {
    let id = item.getAttribute('id') || undefined
    let content =
      filterChildren(item, 'a', true) || filterChildren(item, 'span', true)

    if (!content) {
      return
    }

    let src = content.getAttribute('href') || ''

    if (!id) {
      id = src
    }
    let text = content.textContent || ''

    let subitems = []
    let nested = filterChildren(item, 'ol', true)
    if (nested) {
      subitems = this.parseNavList(nested, id)
    }

    return {
      id: id,
      href: src,
      label: text,
      subitems: subitems,
      parent: parent,
    }
  }

  /**
   * Parse landmarks from a Epub > 3.0 Nav
   * @private
   * @param  {document} navHtml
   * @return {array} landmarks list
   */
  parseLandmarks(navHtml) {
    var navElement = querySelectorByType(navHtml, 'nav', 'landmarks')
    var navItems = navElement ? qsa(navElement, 'li') : []
    var length = navItems.length
    var i
    var list = []
    var item

    if (!navItems || length === 0) return list

    for (i = 0; i < length; ++i) {
      item = this.landmarkItem(navItems[i])
      if (item) {
        list.push(item)
        this.landmarksByType[item.type] = i
      }
    }

    return list
  }

  /**
   * Create a landmarkItem
   * @private
   * @param  {element} item
   * @return {object} landmarkItem
   */
  landmarkItem(item) {
    let content = filterChildren(item, 'a', true)

    if (!content) {
      return
    }

    let type =
      content.getAttributeNS('http://www.idpf.org/2007/ops', 'type') ||
      undefined
    let href = content.getAttribute('href') || ''
    let text = content.textContent || ''

    return {
      href: href,
      label: text,
      type: type,
    }
  }

  /**
   * Parse from a Epub > 3.0 NC
   * @private
   * @param  {document} navHtml
   * @return {array} navigation list
   */
  parseNcx(tocXml) {
    var navPoints = qsa(tocXml, 'navPoint')
    var length = navPoints.length
    var i
    var toc = {}
    var list = []
    var item, parent

    if (!navPoints || length === 0) return list

    for (i = 0; i < length; ++i) {
      item = this.ncxItem(navPoints[i])
      toc[item.id] = item
      if (!item.parent) {
        list.push(item)
      } else {
        parent = toc[item.parent]
        parent.subitems.push(item)
      }
    }

    return list
  }

  /**
   * Create a ncxItem
   * @private
   * @param  {element} item
   * @return {object} ncxItem
   */
  ncxItem(item) {
    var id = item.getAttribute('id') || false,
      content = qs(item, 'content'),
      src = content.getAttribute('src'),
      navLabel = qs(item, 'navLabel'),
      text = navLabel.textContent ? navLabel.textContent : '',
      subitems = [],
      parentNode = item.parentNode,
      parent

    if (
      parentNode &&
      (parentNode.nodeName === 'navPoint' ||
        parentNode.nodeName.split(':').slice(-1)[0] === 'navPoint')
    ) {
      parent = parentNode.getAttribute('id')
    }

    return {
      id: id,
      href: src,
      label: text,
      subitems: subitems,
      parent: parent,
    }
  }

  /**
   * Load Spine Items
   * @param  {object} json the items to be loaded
   * @return {Array} navItems
   */
  load(json) {
    return json.map((item) => {
      item.label = item.title
      item.subitems = item.children ? this.load(item.children) : []
      return item
    })
  }

  /**
   * forEach pass through
   * @param  {Function} fn function to run on each item
   * @return {method} forEach loop
   */
  forEach(fn) {
    return this.toc.forEach(fn)
  }
}

export default Navigation

</code>

packages\epubjs\src\packaging.js:
<code>
import { qs, qsa, qsp, indexOfElementNode } from './utils/core'

/**
 * Open Packaging Format Parser
 * @class
 * @param {document} packageDocument OPF XML
 */
class Packaging {
  constructor(packageDocument) {
    this.manifest = {}
    this.navPath = ''
    this.ncxPath = ''
    this.coverPath = ''
    this.spineNodeIndex = 0
    this.spine = []
    this.metadata = {}

    if (packageDocument) {
      this.parse(packageDocument)
    }
  }

  /**
   * Parse OPF XML
   * @param  {document} packageDocument OPF XML
   * @return {object} parsed package parts
   */
  parse(packageDocument) {
    var metadataNode, manifestNode, spineNode

    if (!packageDocument) {
      throw new Error('Package File Not Found')
    }

    metadataNode = qs(packageDocument, 'metadata')
    if (!metadataNode) {
      throw new Error('No Metadata Found')
    }

    manifestNode = qs(packageDocument, 'manifest')
    if (!manifestNode) {
      throw new Error('No Manifest Found')
    }

    spineNode = qs(packageDocument, 'spine')
    if (!spineNode) {
      throw new Error('No Spine Found')
    }

    this.manifest = this.parseManifest(manifestNode)
    this.navPath = this.findNavPath(manifestNode)
    this.ncxPath = this.findNcxPath(manifestNode, spineNode)
    this.coverPath = this.findCoverPath(packageDocument)

    this.spineNodeIndex = indexOfElementNode(spineNode)

    this.spine = this.parseSpine(spineNode, this.manifest)

    this.uniqueIdentifier = this.findUniqueIdentifier(packageDocument)
    this.metadata = this.parseMetadata(metadataNode)

    this.metadata.direction = spineNode.getAttribute(
      'page-progression-direction',
    )

    return {
      metadata: this.metadata,
      spine: this.spine,
      manifest: this.manifest,
      navPath: this.navPath,
      ncxPath: this.ncxPath,
      coverPath: this.coverPath,
      spineNodeIndex: this.spineNodeIndex,
    }
  }

  /**
   * Parse Metadata
   * @private
   * @param  {node} xml
   * @return {object} metadata
   */
  parseMetadata(xml) {
    var metadata = {}

    metadata.title = this.getElementText(xml, 'title')
    metadata.creator = this.getElementText(xml, 'creator')
    metadata.description = this.getElementText(xml, 'description')

    metadata.pubdate = this.getElementText(xml, 'date')

    metadata.publisher = this.getElementText(xml, 'publisher')

    metadata.identifier = this.getElementText(xml, 'identifier')
    metadata.language = this.getElementText(xml, 'language')
    metadata.rights = this.getElementText(xml, 'rights')

    metadata.modified_date = this.getPropertyText(xml, 'dcterms:modified')

    metadata.layout = this.getPropertyText(xml, 'rendition:layout')
    metadata.orientation = this.getPropertyText(xml, 'rendition:orientation')
    metadata.flow = this.getPropertyText(xml, 'rendition:flow')
    metadata.viewport = this.getPropertyText(xml, 'rendition:viewport')
    metadata.media_active_class = this.getPropertyText(
      xml,
      'media:active-class',
    )
    metadata.spread = this.getPropertyText(xml, 'rendition:spread')
    // metadata.page_prog_dir = packageXml.querySelector("spine").getAttribute("page-progression-direction");

    return metadata
  }

  /**
   * Parse Manifest
   * @private
   * @param  {node} manifestXml
   * @return {object} manifest
   */
  parseManifest(manifestXml) {
    var manifest = {}

    //-- Turn items into an array
    // var selected = manifestXml.querySelectorAll("item");
    var selected = qsa(manifestXml, 'item')
    var items = Array.prototype.slice.call(selected)

    //-- Create an object with the id as key
    items.forEach(function (item) {
      var id = item.getAttribute('id'),
        href = item.getAttribute('href') || '',
        type = item.getAttribute('media-type') || '',
        overlay = item.getAttribute('media-overlay') || '',
        properties = item.getAttribute('properties') || ''

      manifest[id] = {
        href: href,
        // "url" : href,
        type: type,
        overlay: overlay,
        properties: properties.length ? properties.split(' ') : [],
      }
    })

    return manifest
  }

  /**
   * Parse Spine
   * @private
   * @param  {node} spineXml
   * @param  {Packaging.manifest} manifest
   * @return {object} spine
   */
  parseSpine(spineXml, manifest) {
    var spine = []

    var selected = qsa(spineXml, 'itemref')
    var items = Array.prototype.slice.call(selected)

    // var epubcfi = new EpubCFI();

    //-- Add to array to maintain ordering and cross reference with manifest
    items.forEach(function (item, index) {
      var idref = item.getAttribute('idref')
      // var cfiBase = epubcfi.generateChapterComponent(spineNodeIndex, index, Id);
      var props = item.getAttribute('properties') || ''
      var propArray = props.length ? props.split(' ') : []
      // var manifestProps = manifest[Id].properties;
      // var manifestPropArray = manifestProps.length ? manifestProps.split(" ") : [];

      var itemref = {
        id: item.getAttribute('id'),
        idref: idref,
        linear: item.getAttribute('linear') || 'yes',
        properties: propArray,
        // "href" : manifest[Id].href,
        // "url" :  manifest[Id].url,
        index: index,
        // "cfiBase" : cfiBase
      }
      spine.push(itemref)
    })

    return spine
  }

  /**
   * Find Unique Identifier
   * @private
   * @param  {node} packageXml
   * @return {string} Unique Identifier text
   */
  findUniqueIdentifier(packageXml) {
    var uniqueIdentifierId =
      packageXml.documentElement.getAttribute('unique-identifier')
    if (!uniqueIdentifierId) {
      return ''
    }
    var identifier = packageXml.getElementById(uniqueIdentifierId)
    if (!identifier) {
      return ''
    }

    if (
      identifier.localName === 'identifier' &&
      identifier.namespaceURI === 'http://purl.org/dc/elements/1.1/'
    ) {
      return identifier.childNodes.length > 0
        ? identifier.childNodes[0].nodeValue.trim()
        : ''
    }

    return ''
  }

  /**
   * Find TOC NAV
   * @private
   * @param {element} manifestNode
   * @return {string}
   */
  findNavPath(manifestNode) {
    // Find item with property "nav"
    // Should catch nav regardless of order
    // var node = manifestNode.querySelector("item[properties$='nav'], item[properties^='nav '], item[properties*=' nav ']");
    var node = qsp(manifestNode, 'item', { properties: 'nav' })
    return node ? node.getAttribute('href') : false
  }

  /**
   * Find TOC NCX
   * media-type="application/x-dtbncx+xml" href="toc.ncx"
   * @private
   * @param {element} manifestNode
   * @param {element} spineNode
   * @return {string}
   */
  findNcxPath(manifestNode, spineNode) {
    // var node = manifestNode.querySelector("item[media-type='application/x-dtbncx+xml']");
    var node = qsp(manifestNode, 'item', {
      'media-type': 'application/x-dtbncx+xml',
    })
    var tocId

    // If we can't find the toc by media-type then try to look for id of the item in the spine attributes as
    // according to http://www.idpf.org/epub/20/spec/OPF_2.0.1_draft.htm#Section2.4.1.2,
    // "The item that describes the NCX must be referenced by the spine toc attribute."
    if (!node) {
      tocId = spineNode.getAttribute('toc')
      if (tocId) {
        // node = manifestNode.querySelector("item[id='" + tocId + "']");
        node = manifestNode.querySelector(`#${tocId}`)
      }
    }

    return node ? node.getAttribute('href') : false
  }

  /**
   * Find the Cover Path
   * <item properties="cover-image" id="ci" href="cover.svg" media-type="image/svg+xml" />
   * Fallback for Epub 2.0
   * @private
   * @param  {node} packageXml
   * @return {string} href
   */
  findCoverPath(packageXml) {
    var pkg = qs(packageXml, 'package')
    var epubVersion = pkg.getAttribute('version')

    // Try parsing cover with epub 3.
    // var node = packageXml.querySelector("item[properties='cover-image']");
    var node = qsp(packageXml, 'item', { properties: 'cover-image' })
    if (node) return node.getAttribute('href')

    // Fallback to epub 2.
    var metaCover = qsp(packageXml, 'meta', { name: 'cover' })

    if (metaCover) {
      var coverId = metaCover.getAttribute('content')
      // var cover = packageXml.querySelector("item[id='" + coverId + "']");
      var cover = packageXml.getElementById(coverId)
      return cover ? cover.getAttribute('href') : ''
    } else {
      return false
    }
  }

  /**
   * Get text of a namespaced element
   * @private
   * @param  {node} xml
   * @param  {string} tag
   * @return {string} text
   */
  getElementText(xml, tag) {
    var found = xml.getElementsByTagNameNS(
      'http://purl.org/dc/elements/1.1/',
      tag,
    )
    var el

    if (!found || found.length === 0) return ''

    el = found[0]

    if (el.childNodes.length) {
      return el.childNodes[0].nodeValue
    }

    return ''
  }

  /**
   * Get text by property
   * @private
   * @param  {node} xml
   * @param  {string} property
   * @return {string} text
   */
  getPropertyText(xml, property) {
    var el = qsp(xml, 'meta', { property: property })

    if (el && el.childNodes.length) {
      return el.childNodes[0].nodeValue
    }

    return ''
  }

  /**
   * Load JSON Manifest
   * @param  {document} packageDocument OPF XML
   * @return {object} parsed package parts
   */
  load(json) {
    this.metadata = json.metadata

    let spine = json.readingOrder || json.spine
    this.spine = spine.map((item, index) => {
      item.index = index
      item.linear = item.linear || 'yes'
      return item
    })

    json.resources.forEach((item, index) => {
      this.manifest[index] = item

      if (item.rel && item.rel[0] === 'cover') {
        this.coverPath = item.href
      }
    })

    this.spineNodeIndex = 0

    this.toc = json.toc.map((item, index) => {
      item.label = item.title
      return item
    })

    return {
      metadata: this.metadata,
      spine: this.spine,
      manifest: this.manifest,
      navPath: this.navPath,
      ncxPath: this.ncxPath,
      coverPath: this.coverPath,
      spineNodeIndex: this.spineNodeIndex,
      toc: this.toc,
    }
  }

  destroy() {
    this.manifest = undefined
    this.navPath = undefined
    this.ncxPath = undefined
    this.coverPath = undefined
    this.spineNodeIndex = undefined
    this.spine = undefined
    this.metadata = undefined
  }
}

export default Packaging

</code>

packages\epubjs\src\pagelist.js:
<code>
import EpubCFI from './epubcfi'
import {
  qs,
  qsa,
  querySelectorByType,
  indexOfSorted,
  locationOf,
} from './utils/core'

/**
 * Page List Parser
 * @param {document} [xml]
 */
class PageList {
  constructor(xml) {
    this.pages = []
    this.locations = []
    this.epubcfi = new EpubCFI()

    this.firstPage = 0
    this.lastPage = 0
    this.totalPages = 0

    this.toc = undefined
    this.ncx = undefined

    if (xml) {
      this.pageList = this.parse(xml)
    }

    if (this.pageList && this.pageList.length) {
      this.process(this.pageList)
    }
  }

  /**
   * Parse PageList Xml
   * @param  {document} xml
   */
  parse(xml) {
    var html = qs(xml, 'html')
    var ncx = qs(xml, 'ncx')

    if (html) {
      return this.parseNav(xml)
    } else if (ncx) {
      return this.parseNcx(xml)
    }
  }

  /**
   * Parse a Nav PageList
   * @private
   * @param  {node} navHtml
   * @return {PageList.item[]} list
   */
  parseNav(navHtml) {
    var navElement = querySelectorByType(navHtml, 'nav', 'page-list')
    var navItems = navElement ? qsa(navElement, 'li') : []
    var length = navItems.length
    var i
    var list = []
    var item

    if (!navItems || length === 0) return list

    for (i = 0; i < length; ++i) {
      item = this.item(navItems[i])
      list.push(item)
    }

    return list
  }

  parseNcx(navXml) {
    var list = []
    var i = 0
    var item
    var pageList
    var pageTargets
    var length = 0

    pageList = qs(navXml, 'pageList')
    if (!pageList) return list

    pageTargets = qsa(pageList, 'pageTarget')
    length = pageTargets.length

    if (!pageTargets || pageTargets.length === 0) {
      return list
    }

    for (i = 0; i < length; ++i) {
      item = this.ncxItem(pageTargets[i])
      list.push(item)
    }

    return list
  }

  ncxItem(item) {
    var navLabel = qs(item, 'navLabel')
    var navLabelText = qs(navLabel, 'text')
    var pageText = navLabelText.textContent
    var content = qs(item, 'content')

    var href = content.getAttribute('src')
    var page = parseInt(pageText, 10)

    return {
      href: href,
      page: page,
    }
  }

  /**
   * Page List Item
   * @private
   * @param  {node} item
   * @return {object} pageListItem
   */
  item(item) {
    var content = qs(item, 'a'),
      href = content.getAttribute('href') || '',
      text = content.textContent || '',
      page = parseInt(text),
      isCfi = href.indexOf('epubcfi'),
      split,
      packageUrl,
      cfi

    if (isCfi != -1) {
      split = href.split('#')
      packageUrl = split[0]
      cfi = split.length > 1 ? split[1] : false
      return {
        cfi: cfi,
        href: href,
        packageUrl: packageUrl,
        page: page,
      }
    } else {
      return {
        href: href,
        page: page,
      }
    }
  }

  /**
   * Process pageList items
   * @private
   * @param  {array} pageList
   */
  process(pageList) {
    pageList.forEach(function (item) {
      this.pages.push(item.page)
      if (item.cfi) {
        this.locations.push(item.cfi)
      }
    }, this)
    this.firstPage = parseInt(this.pages[0])
    this.lastPage = parseInt(this.pages[this.pages.length - 1])
    this.totalPages = this.lastPage - this.firstPage
  }

  /**
   * Get a PageList result from a EpubCFI
   * @param  {string} cfi EpubCFI String
   * @return {number} page
   */
  pageFromCfi(cfi) {
    var pg = -1

    // Check if the pageList has not been set yet
    if (this.locations.length === 0) {
      return -1
    }

    // TODO: check if CFI is valid?

    // check if the cfi is in the location list
    // var index = this.locations.indexOf(cfi);
    var index = indexOfSorted(cfi, this.locations, this.epubcfi.compare)
    if (index != -1) {
      pg = this.pages[index]
    } else {
      // Otherwise add it to the list of locations
      // Insert it in the correct position in the locations page
      //index = EPUBJS.core.insert(cfi, this.locations, this.epubcfi.compare);
      index = locationOf(cfi, this.locations, this.epubcfi.compare)
      // Get the page at the location just before the new one, or return the first
      pg = index - 1 >= 0 ? this.pages[index - 1] : this.pages[0]
      if (pg !== undefined) {
        // Add the new page in so that the locations and page array match up
        //this.pages.splice(index, 0, pg);
      } else {
        pg = -1
      }
    }
    return pg
  }

  /**
   * Get an EpubCFI from a Page List Item
   * @param  {string | number} pg
   * @return {string} cfi
   */
  cfiFromPage(pg) {
    var cfi = -1
    // check that pg is an int
    if (typeof pg != 'number') {
      pg = parseInt(pg)
    }

    // check if the cfi is in the page list
    // Pages could be unsorted.
    var index = this.pages.indexOf(pg)
    if (index != -1) {
      cfi = this.locations[index]
    }
    // TODO: handle pages not in the list
    return cfi
  }

  /**
   * Get a Page from Book percentage
   * @param  {number} percent
   * @return {number} page
   */
  pageFromPercentage(percent) {
    var pg = Math.round(this.totalPages * percent)
    return pg
  }

  /**
   * Returns a value between 0 - 1 corresponding to the location of a page
   * @param  {number} pg the page
   * @return {number} percentage
   */
  percentageFromPage(pg) {
    var percentage = (pg - this.firstPage) / this.totalPages
    return Math.round(percentage * 1000) / 1000
  }

  /**
   * Returns a value between 0 - 1 corresponding to the location of a cfi
   * @param  {string} cfi EpubCFI String
   * @return {number} percentage
   */
  percentageFromCfi(cfi) {
    var pg = this.pageFromCfi(cfi)
    var percentage = this.percentageFromPage(pg)
    return percentage
  }

  /**
   * Destroy
   */
  destroy() {
    this.pages = undefined
    this.locations = undefined
    this.epubcfi = undefined

    this.pageList = undefined

    this.toc = undefined
    this.ncx = undefined
  }
}

export default PageList

</code>

packages\epubjs\src\rendition.js:
<code>
import EventEmitter from 'event-emitter'

import Annotations from './annotations'
import Contents from './contents'
import EpubCFI from './epubcfi'
import Layout from './layout'
import ContinuousViewManager from './managers/continuous/index'
import DefaultViewManager from './managers/default/index'
import IframeView from './managers/views/iframe'
import Themes from './themes'
import { EVENTS, DOM_EVENTS } from './utils/constants'
import { extend, defer, isFloat } from './utils/core'
import Hook from './utils/hook'
import Queue from './utils/queue'
// import Mapping from "./mapping";

// Default Views

// Default View Managers

/**
 * Displays an Epub as a series of Views for each Section.
 * Requires Manager and View class to handle specifics of rendering
 * the section content.
 * @class
 * @param {Book} book
 * @param {object} [options]
 * @param {number} [options.width]
 * @param {number} [options.height]
 * @param {string} [options.ignoreClass] class for the cfi parser to ignore
 * @param {string | function | object} [options.manager='default']
 * @param {string | function} [options.view='iframe']
 * @param {string} [options.layout] layout to force
 * @param {string} [options.spread] force spread value
 * @param {number} [options.minSpreadWidth] overridden by spread: none (never) / both (always)
 * @param {string} [options.stylesheet] url of stylesheet to be injected
 * @param {boolean} [options.resizeOnOrientationChange] false to disable orientation events
 * @param {string} [options.script] url of script to be injected
 * @param {boolean | object} [options.snap=false] use snap scrolling
 * @param {string} [options.defaultDirection='ltr'] default text direction
 * @param {boolean} [options.allowScriptedContent=false] enable running scripts in content
 * @param {boolean} [options.allowPopups=false] enable opening popup in content
 */
class Rendition {
  constructor(book, options) {
    this.settings = extend(this.settings || {}, {
      width: null,
      height: null,
      ignoreClass: '',
      manager: 'default',
      view: 'iframe',
      flow: null,
      layout: null,
      spread: null,
      minSpreadWidth: 800,
      stylesheet: null,
      resizeOnOrientationChange: true,
      script: null,
      snap: false,
      defaultDirection: 'ltr',
      allowScriptedContent: false,
      allowPopups: false,
    })

    extend(this.settings, options)

    if (typeof this.settings.manager === 'object') {
      this.manager = this.settings.manager
    }

    this.book = book

    /**
     * Adds Hook methods to the Rendition prototype
     * @member {object} hooks
     * @property {Hook} hooks.content
     * @memberof Rendition
     */
    this.hooks = {}
    this.hooks.display = new Hook(this)
    this.hooks.serialize = new Hook(this)
    this.hooks.content = new Hook(this)
    this.hooks.unloaded = new Hook(this)
    this.hooks.layout = new Hook(this)
    this.hooks.render = new Hook(this)
    this.hooks.show = new Hook(this)

    this.hooks.content.register(this.handleLinks.bind(this))
    this.hooks.content.register(this.passEvents.bind(this))
    this.hooks.content.register(this.adjustImages.bind(this))

    this.book.spine.hooks.content.register(this.injectIdentifier.bind(this))

    if (this.settings.stylesheet) {
      this.book.spine.hooks.content.register(this.injectStylesheet.bind(this))
    }

    if (this.settings.script) {
      this.book.spine.hooks.content.register(this.injectScript.bind(this))
    }

    /**
     * @member {Themes} themes
     * @memberof Rendition
     */
    this.themes = new Themes(this)

    /**
     * @member {Annotations} annotations
     * @memberof Rendition
     */
    this.annotations = new Annotations(this)

    this.epubcfi = new EpubCFI()

    this.q = new Queue(this)

    /**
     * A Rendered Location Range
     * @typedef location
     * @type {Object}
     * @property {object} start
     * @property {string} start.index
     * @property {string} start.href
     * @property {object} start.displayed
     * @property {EpubCFI} start.cfi
     * @property {number} start.location
     * @property {number} start.percentage
     * @property {number} start.displayed.page
     * @property {number} start.displayed.total
     * @property {object} end
     * @property {string} end.index
     * @property {string} end.href
     * @property {object} end.displayed
     * @property {EpubCFI} end.cfi
     * @property {number} end.location
     * @property {number} end.percentage
     * @property {number} end.displayed.page
     * @property {number} end.displayed.total
     * @property {boolean} atStart
     * @property {boolean} atEnd
     * @memberof Rendition
     */
    this.location = undefined

    // Hold queue until book is opened
    this.q.enqueue(this.book.opened)

    this.starting = new defer()
    /**
     * @member {promise} started returns after the rendition has started
     * @memberof Rendition
     */
    this.started = this.starting.promise

    // Block the queue until rendering is started
    this.q.enqueue(this.start)
  }

  /**
   * Set the manager function
   * @param {function} manager
   */
  setManager(manager) {
    this.manager = manager
  }

  /**
   * Require the manager from passed string, or as a class function
   * @param  {string|object} manager [description]
   * @return {method}
   */
  requireManager(manager) {
    var viewManager

    // If manager is a string, try to load from imported managers
    if (typeof manager === 'string' && manager === 'default') {
      viewManager = DefaultViewManager
    } else if (typeof manager === 'string' && manager === 'continuous') {
      viewManager = ContinuousViewManager
    } else {
      // otherwise, assume we were passed a class function
      viewManager = manager
    }

    return viewManager
  }

  /**
   * Require the view from passed string, or as a class function
   * @param  {string|object} view
   * @return {view}
   */
  requireView(view) {
    var View

    // If view is a string, try to load from imported views,
    if (typeof view == 'string' && view === 'iframe') {
      View = IframeView
    } else {
      // otherwise, assume we were passed a class function
      View = view
    }

    return View
  }

  /**
   * Start the rendering
   * @return {Promise} rendering has started
   */
  start() {
    if (
      !this.settings.layout &&
      (this.book.package.metadata.layout === 'pre-paginated' ||
        this.book.displayOptions.fixedLayout === 'true')
    ) {
      this.settings.layout = 'pre-paginated'
    }
    switch (this.book.package.metadata.spread) {
      case 'none':
        this.settings.spread = 'none'
        break
      case 'both':
        this.settings.spread = true
        break
    }

    if (!this.manager) {
      this.ViewManager = this.requireManager(this.settings.manager)
      this.View = this.requireView(this.settings.view)

      this.manager = new this.ViewManager({
        view: this.View,
        queue: this.q,
        request: this.book.load.bind(this.book),
        settings: this.settings,
      })
    }

    this.direction(
      this.book.package.metadata.direction || this.settings.defaultDirection,
    )

    // Parse metadata to get layout props
    this.settings.globalLayoutProperties = this.determineLayoutProperties(
      this.book.package.metadata,
    )

    this.flow(this.settings.globalLayoutProperties.flow)

    this.layout(this.settings.globalLayoutProperties)

    // Listen for displayed views
    this.manager.on(EVENTS.MANAGERS.ADDED, this.afterDisplayed.bind(this))
    this.manager.on(EVENTS.MANAGERS.REMOVED, this.afterRemoved.bind(this))

    // Listen for resizing
    this.manager.on(EVENTS.MANAGERS.RESIZED, this.onResized.bind(this))

    // Listen for rotation
    this.manager.on(
      EVENTS.MANAGERS.ORIENTATION_CHANGE,
      this.onOrientationChange.bind(this),
    )

    // Listen for scroll changes
    this.manager.on(EVENTS.MANAGERS.SCROLLED, this.reportLocation.bind(this))

    /**
     * Emit that rendering has started
     * @event started
     * @memberof Rendition
     */
    this.emit(EVENTS.RENDITION.STARTED)

    // Start processing queue
    this.starting.resolve()
  }

  /**
   * Call to attach the container to an element in the dom
   * Container must be attached before rendering can begin
   * @param  {element} element to attach to
   * @return {Promise}
   */
  attachTo(element) {
    return this.q.enqueue(
      function () {
        // Start rendering
        this.manager.render(element, {
          width: this.settings.width,
          height: this.settings.height,
        })

        /**
         * Emit that rendering has attached to an element
         * @event attached
         * @memberof Rendition
         */
        this.emit(EVENTS.RENDITION.ATTACHED)
      }.bind(this),
    )
  }

  /**
   * Display a point in the book
   * The request will be added to the rendering Queue,
   * so it will wait until book is opened, rendering started
   * and all other rendering tasks have finished to be called.
   * @param  {string} target Url or EpubCFI
   * @return {Promise}
   */
  display(target) {
    if (this.displaying) {
      this.displaying.resolve()
    }
    return this.q.enqueue(this._display, target)
  }

  /**
   * Tells the manager what to display immediately
   * @private
   * @param  {string} target Url or EpubCFI
   * @return {Promise}
   */
  _display(target) {
    if (!this.book) {
      return
    }
    var isCfiString = this.epubcfi.isCfiString(target)
    var displaying = new defer()
    var displayed = displaying.promise
    var section
    var moveTo

    this.displaying = displaying

    // Check if this is a book percentage
    if (this.book.locations.length() && isFloat(target)) {
      target = this.book.locations.cfiFromPercentage(parseFloat(target))
    }

    section = this.book.spine.get(target)

    if (!section) {
      displaying.reject(new Error('No Section Found'))
      return displayed
    }

    this.manager.display(section, target).then(
      () => {
        displaying.resolve(section)
        this.displaying = undefined

        /**
         * Emit that a section has been displayed
         * @event displayed
         * @param {Section} section
         * @memberof Rendition
         */
        this.emit(EVENTS.RENDITION.DISPLAYED, section)
        this.reportLocation()
      },
      (err) => {
        /**
         * Emit that has been an error displaying
         * @event displayError
         * @param {Section} section
         * @memberof Rendition
         */
        this.emit(EVENTS.RENDITION.DISPLAY_ERROR, err)
      },
    )

    return displayed
  }

  /*
	render(view, show) {

		// view.onLayout = this.layout.format.bind(this.layout);
		view.create();

		// Fit to size of the container, apply padding
		this.manager.resizeView(view);

		// Render Chain
		return view.section.render(this.book.request)
			.then(function(contents){
				return view.load(contents);
			}.bind(this))
			.then(function(doc){
				return this.hooks.content.trigger(view, this);
			}.bind(this))
			.then(function(){
				this.layout.format(view.contents);
				return this.hooks.layout.trigger(view, this);
			}.bind(this))
			.then(function(){
				return view.display();
			}.bind(this))
			.then(function(){
				return this.hooks.render.trigger(view, this);
			}.bind(this))
			.then(function(){
				if(show !== false) {
					this.q.enqueue(function(view){
						view.show();
					}, view);
				}
				// this.map = new Map(view, this.layout);
				this.hooks.show.trigger(view, this);
				this.trigger("rendered", view.section);

			}.bind(this))
			.catch(function(e){
				this.trigger("loaderror", e);
			}.bind(this));

	}
	*/

  /**
   * Report what section has been displayed
   * @private
   * @param  {*} view
   */
  afterDisplayed(view) {
    view.on(EVENTS.VIEWS.MARK_CLICKED, (cfiRange, data) =>
      this.triggerMarkEvent(cfiRange, data, view.contents),
    )

    this.hooks.render.trigger(view, this).then(() => {
      if (view.contents) {
        this.hooks.content.trigger(view.contents, this).then(() => {
          /**
           * Emit that a section has been rendered
           * @event rendered
           * @param {Section} section
           * @param {View} view
           * @memberof Rendition
           */
          this.emit(EVENTS.RENDITION.RENDERED, view.section, view)
        })
      } else {
        this.emit(EVENTS.RENDITION.RENDERED, view.section, view)
      }
    })
  }

  /**
   * Report what has been removed
   * @private
   * @param  {*} view
   */
  afterRemoved(view) {
    this.hooks.unloaded.trigger(view, this).then(() => {
      /**
       * Emit that a section has been removed
       * @event removed
       * @param {Section} section
       * @param {View} view
       * @memberof Rendition
       */
      this.emit(EVENTS.RENDITION.REMOVED, view.section, view)
    })
  }

  /**
   * Report resize events and display the last seen location
   * @private
   */
  onResized(size, epubcfi) {
    /**
     * Emit that the rendition has been resized
     * @event resized
     * @param {number} width
     * @param {height} height
     * @param {string} epubcfi (optional)
     * @memberof Rendition
     */
    this.emit(
      EVENTS.RENDITION.RESIZED,
      {
        width: size.width,
        height: size.height,
      },
      epubcfi,
    )

    if (this.location && this.location.start) {
      this.display(epubcfi || this.location.start.cfi)
    }
  }

  /**
   * Report orientation events and display the last seen location
   * @private
   */
  onOrientationChange(orientation) {
    /**
     * Emit that the rendition has been rotated
     * @event orientationchange
     * @param {string} orientation
     * @memberof Rendition
     */
    this.emit(EVENTS.RENDITION.ORIENTATION_CHANGE, orientation)
  }

  /**
   * Move the Rendition to a specific offset
   * Usually you would be better off calling display()
   * @param {object} offset
   */
  moveTo(offset) {
    this.manager.moveTo(offset)
  }

  /**
   * Trigger a resize of the views
   * @param {number} [width]
   * @param {number} [height]
   * @param {string} [epubcfi] (optional)
   */
  resize(width, height, epubcfi) {
    if (width) {
      this.settings.width = width
    }
    if (height) {
      this.settings.height = height
    }
    this.manager.resize(width, height, epubcfi)
  }

  /**
   * Clear all rendered views
   */
  clear() {
    this.manager.clear()
  }

  /**
   * Go to the next "page" in the rendition
   * @return {Promise}
   */
  next() {
    return this.q
      .enqueue(this.manager.next.bind(this.manager))
      .then(this.reportLocation.bind(this))
  }

  /**
   * Go to the previous "page" in the rendition
   * @return {Promise}
   */
  prev() {
    return this.q
      .enqueue(this.manager.prev.bind(this.manager))
      .then(this.reportLocation.bind(this))
  }

  //-- http://www.idpf.org/epub/301/spec/epub-publications.html#meta-properties-rendering
  /**
   * Determine the Layout properties from metadata and settings
   * @private
   * @param  {object} metadata
   * @return {object} properties
   */
  determineLayoutProperties(metadata) {
    var properties
    var layout = this.settings.layout || metadata.layout || 'reflowable'
    var spread = this.settings.spread || metadata.spread || 'auto'
    var orientation =
      this.settings.orientation || metadata.orientation || 'auto'
    var flow = this.settings.flow || metadata.flow || 'auto'
    var viewport = metadata.viewport || ''
    var minSpreadWidth =
      this.settings.minSpreadWidth || metadata.minSpreadWidth || 800
    var direction = this.settings.direction || metadata.direction || 'ltr'

    if (
      (this.settings.width === 0 || this.settings.width > 0) &&
      (this.settings.height === 0 || this.settings.height > 0)
    ) {
      // viewport = "width="+this.settings.width+", height="+this.settings.height+"";
    }

    properties = {
      layout: layout,
      spread: spread,
      orientation: orientation,
      flow: flow,
      viewport: viewport,
      minSpreadWidth: minSpreadWidth,
      direction: direction,
    }

    return properties
  }

  /**
   * Adjust the flow of the rendition to paginated or scrolled
   * (scrolled-continuous vs scrolled-doc are handled by different view managers)
   * @param  {string} flow
   */
  flow(flow) {
    var _flow = flow
    if (
      flow === 'scrolled' ||
      flow === 'scrolled-doc' ||
      flow === 'scrolled-continuous'
    ) {
      _flow = 'scrolled'
    }

    if (flow === 'auto' || flow === 'paginated') {
      _flow = 'paginated'
    }

    this.settings.flow = flow

    if (this._layout) {
      this._layout.flow(_flow)
    }

    if (this.manager && this._layout) {
      this.manager.applyLayout(this._layout)
    }

    if (this.manager) {
      this.manager.updateFlow(_flow)
    }

    if (this.manager && this.manager.isRendered() && this.location) {
      this.manager.clear()
      this.display(this.location.start.cfi)
    }
  }

  /**
   * Adjust the layout of the rendition to reflowable or pre-paginated
   * @param  {object} settings
   */
  layout(settings) {
    if (settings) {
      this._layout = new Layout(settings)
      this._layout.spread(settings.spread, this.settings.minSpreadWidth)

      // this.mapping = new Mapping(this._layout.props);

      this._layout.on(EVENTS.LAYOUT.UPDATED, (props, changed) => {
        this.emit(EVENTS.RENDITION.LAYOUT, props, changed)
      })
    }

    if (this.manager && this._layout) {
      this.manager.applyLayout(this._layout)
    }

    return this._layout
  }

  /**
   * Adjust if the rendition uses spreads
   * @param  {string} spread none | auto (TODO: implement landscape, portrait, both)
   * @param  {int} [min] min width to use spreads at
   */
  spread(spread, min) {
    this.settings.spread = spread

    if (min) {
      this.settings.minSpreadWidth = min
    }

    if (this._layout) {
      this._layout.spread(spread, min)
    }

    if (this.manager && this.manager.isRendered()) {
      this.manager.updateLayout()
    }
  }

  /**
   * Adjust the direction of the rendition
   * @param  {string} dir
   */
  direction(dir) {
    this.settings.direction = dir || 'ltr'

    if (this.manager) {
      this.manager.direction(this.settings.direction)
    }

    if (this.manager && this.manager.isRendered() && this.location) {
      this.manager.clear()
      this.display(this.location.start.cfi)
    }
  }

  /**
   * Report the current location
   * @fires relocated
   * @fires locationChanged
   */
  reportLocation() {
    return this.q.enqueue(
      function reportedLocation() {
        requestAnimationFrame(
          function reportedLocationAfterRAF() {
            var location = this.manager.currentLocation()
            if (
              location &&
              location.then &&
              typeof location.then === 'function'
            ) {
              location.then(
                function (result) {
                  let located = this.located(result)

                  if (!located || !located.start || !located.end) {
                    return
                  }

                  this.location = located

                  this.emit(EVENTS.RENDITION.LOCATION_CHANGED, {
                    index: this.location.start.index,
                    href: this.location.start.href,
                    start: this.location.start.cfi,
                    end: this.location.end.cfi,
                    percentage: this.location.start.percentage,
                  })

                  this.emit(EVENTS.RENDITION.RELOCATED, this.location)
                }.bind(this),
              )
            } else if (location) {
              let located = this.located(location)

              if (!located || !located.start || !located.end) {
                return
              }

              this.location = located

              /**
               * @event locationChanged
               * @deprecated
               * @type {object}
               * @property {number} index
               * @property {string} href
               * @property {EpubCFI} start
               * @property {EpubCFI} end
               * @property {number} percentage
               * @memberof Rendition
               */
              this.emit(EVENTS.RENDITION.LOCATION_CHANGED, {
                index: this.location.start.index,
                href: this.location.start.href,
                start: this.location.start.cfi,
                end: this.location.end.cfi,
                percentage: this.location.start.percentage,
              })

              /**
               * @event relocated
               * @type {displayedLocation}
               * @memberof Rendition
               */
              this.emit(EVENTS.RENDITION.RELOCATED, this.location)
            }
          }.bind(this),
        )
      }.bind(this),
    )
  }

  /**
   * Get the Current Location object
   * @return {displayedLocation | promise} location (may be a promise)
   */
  currentLocation() {
    var location = this.manager.currentLocation()
    if (location && location.then && typeof location.then === 'function') {
      location.then(
        function (result) {
          let located = this.located(result)
          return located
        }.bind(this),
      )
    } else if (location) {
      let located = this.located(location)
      return located
    }
  }

  /**
   * Creates a Rendition#locationRange from location
   * passed by the Manager
   * @returns {displayedLocation}
   * @private
   */
  located(location) {
    if (!location.length) {
      return {}
    }
    let start = location[0]
    let end = location[location.length - 1]

    let located = {
      start: {
        index: start.index,
        href: start.href,
        cfi: start.mapping.start,
        displayed: {
          page: start.pages[0] || 1,
          total: start.totalPages,
        },
      },
      end: {
        index: end.index,
        href: end.href,
        cfi: end.mapping.end,
        displayed: {
          page: end.pages[end.pages.length - 1] || 1,
          total: end.totalPages,
        },
      },
    }

    let locationStart = this.book.locations.locationFromCfi(start.mapping.start)
    let locationEnd = this.book.locations.locationFromCfi(end.mapping.end)

    if (locationStart != null) {
      located.start.location = locationStart
      located.start.percentage =
        this.book.locations.percentageFromLocation(locationStart)
    }
    if (locationEnd != null) {
      located.end.location = locationEnd
      located.end.percentage =
        this.book.locations.percentageFromLocation(locationEnd)
    }

    let pageStart = this.book.pageList.pageFromCfi(start.mapping.start)
    let pageEnd = this.book.pageList.pageFromCfi(end.mapping.end)

    if (pageStart != -1) {
      located.start.page = pageStart
    }
    if (pageEnd != -1) {
      located.end.page = pageEnd
    }

    if (
      end.index === this.book.spine.last().index &&
      located.end.displayed.page >= located.end.displayed.total
    ) {
      located.atEnd = true
    }

    if (
      start.index === this.book.spine.first().index &&
      located.start.displayed.page === 1
    ) {
      located.atStart = true
    }

    return located
  }

  /**
   * Remove and Clean Up the Rendition
   */
  destroy() {
    // Clear the queue
    // this.q.clear();
    // this.q = undefined;

    this.manager && this.manager.destroy()

    this.book = undefined

    // this.views = null;

    // this.hooks.display.clear();
    // this.hooks.serialize.clear();
    // this.hooks.content.clear();
    // this.hooks.layout.clear();
    // this.hooks.render.clear();
    // this.hooks.show.clear();
    // this.hooks = {};

    // this.themes.destroy();
    // this.themes = undefined;

    // this.epubcfi = undefined;

    // this.starting = undefined;
    // this.started = undefined;
  }

  /**
   * Pass the events from a view's Contents
   * @private
   * @param  {Contents} view contents
   */
  passEvents(contents) {
    DOM_EVENTS.forEach((e) => {
      contents.on(e, (ev) => this.triggerViewEvent(ev, contents))
    })

    contents.on(EVENTS.CONTENTS.SELECTED, (e) =>
      this.triggerSelectedEvent(e, contents),
    )
  }

  /**
   * Emit events passed by a view
   * @private
   * @param  {event} e
   */
  triggerViewEvent(e, contents) {
    this.emit(e.type, e, contents)
  }

  /**
   * Emit a selection event's CFI Range passed from a a view
   * @private
   * @param  {string} cfirange
   */
  triggerSelectedEvent(cfirange, contents) {
    /**
     * Emit that a text selection has occurred
     * @event selected
     * @param {string} cfirange
     * @param {Contents} contents
     * @memberof Rendition
     */
    this.emit(EVENTS.RENDITION.SELECTED, cfirange, contents)
  }

  /**
   * Emit a markClicked event with the cfiRange and data from a mark
   * @private
   * @param  {EpubCFI} cfirange
   */
  triggerMarkEvent(cfiRange, data, contents) {
    /**
     * Emit that a mark was clicked
     * @event markClicked
     * @param {EpubCFI} cfirange
     * @param {object} data
     * @param {Contents} contents
     * @memberof Rendition
     */
    this.emit(EVENTS.RENDITION.MARK_CLICKED, cfiRange, data, contents)
  }

  /**
   * Get a Range from a Visible CFI
   * @param  {string} cfi EpubCfi String
   * @param  {string} ignoreClass
   * @return {range}
   */
  getRange(cfi, ignoreClass) {
    var _cfi = new EpubCFI(cfi)
    var found = this.manager.visible().filter(function (view) {
      if (_cfi.spinePos === view.index) return true
    })

    // Should only every return 1 item
    if (found.length) {
      return found[0].contents.range(_cfi, ignoreClass)
    }
  }

  /**
   * Hook to adjust images to fit in columns
   * @param  {Contents} contents
   * @private
   */
  adjustImages(contents) {
    if (this._layout.name === 'pre-paginated') {
      return new Promise(function (resolve) {
        resolve()
      })
    }

    let computed = contents.window.getComputedStyle(contents.content, null)
    let height =
      (contents.content.offsetHeight -
        (parseFloat(computed.paddingTop) +
          parseFloat(computed.paddingBottom))) *
      0.95
    let horizontalPadding =
      parseFloat(computed.paddingLeft) + parseFloat(computed.paddingRight)

    contents.addStylesheetRules({
      img: {
        'max-width':
          (this._layout.columnWidth
            ? this._layout.columnWidth - horizontalPadding + 'px'
            : '100%') + '!important',
        'max-height': height + 'px' + '!important',
        'object-fit': 'contain',
        'page-break-inside': 'avoid',
        'break-inside': 'avoid',
        'box-sizing': 'border-box',
      },
      svg: {
        'max-width':
          (this._layout.columnWidth
            ? this._layout.columnWidth - horizontalPadding + 'px'
            : '100%') + '!important',
        'max-height': height + 'px' + '!important',
        'page-break-inside': 'avoid',
        'break-inside': 'avoid',
      },
    })

    return new Promise(function (resolve, reject) {
      // Wait to apply
      setTimeout(function () {
        resolve()
      }, 1)
    })
  }

  /**
   * Get the Contents object of each rendered view
   * @returns {Contents[]}
   */
  getContents() {
    return this.manager ? this.manager.getContents() : []
  }

  /**
   * Get the views member from the manager
   * @returns {Views}
   */
  views() {
    let views = this.manager ? this.manager.views : undefined
    return views || []
  }

  /**
   * Hook to handle link clicks in rendered content
   * @param  {Contents} contents
   * @private
   */
  handleLinks(contents) {
    if (contents) {
      contents.on(EVENTS.CONTENTS.LINK_CLICKED, (href) => {
        let relative = this.book.path.relative(href)
        this.display(relative)
      })
    }
  }

  /**
   * Hook to handle injecting stylesheet before
   * a Section is serialized
   * @param  {document} doc
   * @param  {Section} section
   * @private
   */
  injectStylesheet(doc, section) {
    let style = doc.createElement('link')
    style.setAttribute('type', 'text/css')
    style.setAttribute('rel', 'stylesheet')
    style.setAttribute('href', this.settings.stylesheet)
    doc.getElementsByTagName('head')[0].appendChild(style)
  }

  /**
   * Hook to handle injecting scripts before
   * a Section is serialized
   * @param  {document} doc
   * @param  {Section} section
   * @private
   */
  injectScript(doc, section) {
    let script = doc.createElement('script')
    script.setAttribute('type', 'text/javascript')
    script.setAttribute('src', this.settings.script)
    script.textContent = ' ' // Needed to prevent self closing tag
    doc.getElementsByTagName('head')[0].appendChild(script)
  }

  /**
   * Hook to handle the document identifier before
   * a Section is serialized
   * @param  {document} doc
   * @param  {Section} section
   * @private
   */
  injectIdentifier(doc, section) {
    let ident = this.book.packaging.metadata.identifier
    let meta = doc.createElement('meta')
    meta.setAttribute('name', 'dc.relation.ispartof')
    if (ident) {
      meta.setAttribute('content', ident)
    }
    doc.getElementsByTagName('head')[0].appendChild(meta)
  }
}

//-- Enable binding events to Renderer
EventEmitter(Rendition.prototype)

export default Rendition

</code>

packages\epubjs\src\resources.js:
<code>
import path from 'path-webpack'

import { createBase64Url, createBlobUrl, blob2base64 } from './utils/core'
import mime from './utils/mime'
import Path from './utils/path'
import { substitute } from './utils/replacements'
import Url from './utils/url'

/**
 * Handle Package Resources
 * @class
 * @param {Manifest} manifest
 * @param {object} [options]
 * @param {string} [options.replacements="base64"]
 * @param {Archive} [options.archive]
 * @param {method} [options.resolver]
 */
class Resources {
  constructor(manifest, options) {
    this.settings = {
      replacements: (options && options.replacements) || 'base64',
      archive: options && options.archive,
      resolver: options && options.resolver,
      request: options && options.request,
    }

    this.process(manifest)
  }

  /**
   * Process resources
   * @param {Manifest} manifest
   */
  process(manifest) {
    this.manifest = manifest
    this.resources = Object.keys(manifest).map(function (key) {
      return manifest[key]
    })

    this.replacementUrls = []

    this.html = []
    this.assets = []
    this.css = []

    this.urls = []
    this.cssUrls = []

    this.split()
    this.splitUrls()
  }

  /**
   * Split resources by type
   * @private
   */
  split() {
    // HTML
    this.html = this.resources.filter(function (item) {
      if (item.type === 'application/xhtml+xml' || item.type === 'text/html') {
        return true
      }
    })

    // Exclude HTML
    this.assets = this.resources.filter(function (item) {
      if (item.type !== 'application/xhtml+xml' && item.type !== 'text/html') {
        return true
      }
    })

    // Only CSS
    this.css = this.resources.filter(function (item) {
      if (item.type === 'text/css') {
        return true
      }
    })
  }

  /**
   * Convert split resources into Urls
   * @private
   */
  splitUrls() {
    // All Assets Urls
    this.urls = this.assets.map(
      function (item) {
        return item.href
      }.bind(this),
    )

    // Css Urls
    this.cssUrls = this.css.map(function (item) {
      return item.href
    })
  }

  /**
   * Create a url to a resource
   * @param {string} url
   * @return {Promise<string>} Promise resolves with url string
   */
  createUrl(url) {
    var parsedUrl = new Url(url)
    var mimeType = mime.lookup(parsedUrl.filename)

    if (this.settings.archive) {
      return this.settings.archive.createUrl(url, {
        base64: this.settings.replacements === 'base64',
      })
    } else {
      if (this.settings.replacements === 'base64') {
        return this.settings
          .request(url, 'blob')
          .then((blob) => {
            return blob2base64(blob)
          })
          .then((blob) => {
            return createBase64Url(blob, mimeType)
          })
      } else {
        return this.settings.request(url, 'blob').then((blob) => {
          return createBlobUrl(blob, mimeType)
        })
      }
    }
  }

  /**
   * Create blob urls for all the assets
   * @return {Promise}         returns replacement urls
   */
  replacements() {
    if (this.settings.replacements === 'none') {
      return new Promise(
        function (resolve) {
          resolve(this.urls)
        }.bind(this),
      )
    }

    var replacements = this.urls.map((url) => {
      var absolute = this.settings.resolver(url)

      return this.createUrl(absolute).catch((err) => {
        console.error(err)
        return null
      })
    })

    return Promise.all(replacements).then((replacementUrls) => {
      this.replacementUrls = replacementUrls.filter((url) => {
        return typeof url === 'string'
      })
      return replacementUrls
    })
  }

  /**
   * Replace URLs in CSS resources
   * @private
   * @param  {Archive} [archive]
   * @param  {method} [resolver]
   * @return {Promise}
   */
  replaceCss(archive, resolver) {
    var replaced = []
    archive = archive || this.settings.archive
    resolver = resolver || this.settings.resolver
    this.cssUrls.forEach(
      function (href) {
        var replacement = this.createCssFile(href, archive, resolver).then(
          function (replacementUrl) {
            // switch the url in the replacementUrls
            var indexInUrls = this.urls.indexOf(href)
            if (indexInUrls > -1) {
              this.replacementUrls[indexInUrls] = replacementUrl
            }
          }.bind(this),
        )

        replaced.push(replacement)
      }.bind(this),
    )
    return Promise.all(replaced)
  }

  /**
   * Create a new CSS file with the replaced URLs
   * @private
   * @param  {string} href the original css file
   * @return {Promise}  returns a BlobUrl to the new CSS file or a data url
   */
  createCssFile(href) {
    var newUrl

    if (path.isAbsolute(href)) {
      return new Promise(function (resolve) {
        resolve()
      })
    }

    var absolute = this.settings.resolver(href)

    // Get the text of the css file from the archive
    var textResponse

    if (this.settings.archive) {
      textResponse = this.settings.archive.getText(absolute)
    } else {
      textResponse = this.settings.request(absolute, 'text')
    }

    // Get asset links relative to css file
    var relUrls = this.urls.map((assetHref) => {
      var resolved = this.settings.resolver(assetHref)
      var relative = new Path(absolute).relative(resolved)

      return relative
    })

    if (!textResponse) {
      // file not found, don't replace
      return new Promise(function (resolve) {
        resolve()
      })
    }

    return textResponse.then(
      (text) => {
        // Replacements in the css text
        text = substitute(text, relUrls, this.replacementUrls)

        // Get the new url
        if (this.settings.replacements === 'base64') {
          newUrl = createBase64Url(text, 'text/css')
        } else {
          newUrl = createBlobUrl(text, 'text/css')
        }

        return newUrl
      },
      (err) => {
        // handle response errors
        return new Promise(function (resolve) {
          resolve()
        })
      },
    )
  }

  /**
   * Resolve all resources URLs relative to an absolute URL
   * @param  {string} absolute to be resolved to
   * @param  {resolver} [resolver]
   * @return {string[]} array with relative Urls
   */
  relativeTo(absolute, resolver) {
    resolver = resolver || this.settings.resolver

    // Get Urls relative to current sections
    return this.urls.map(
      function (href) {
        var resolved = resolver(href)
        var relative = new Path(absolute).relative(resolved)
        return relative
      }.bind(this),
    )
  }

  /**
   * Get a URL for a resource
   * @param  {string} path
   * @return {string} url
   */
  get(path) {
    var indexInUrls = this.urls.indexOf(path)
    if (indexInUrls === -1) {
      return
    }
    if (this.replacementUrls.length) {
      return new Promise(
        function (resolve, reject) {
          resolve(this.replacementUrls[indexInUrls])
        }.bind(this),
      )
    } else {
      return this.createUrl(path)
    }
  }

  /**
   * Substitute urls in content, with replacements,
   * relative to a url if provided
   * @param  {string} content
   * @param  {string} [url]   url to resolve to
   * @return {string}         content with urls substituted
   */
  substitute(content, url) {
    var relUrls
    if (url) {
      relUrls = this.relativeTo(url)
    } else {
      relUrls = this.urls
    }
    return substitute(content, relUrls, this.replacementUrls)
  }

  destroy() {
    this.settings = undefined
    this.manifest = undefined
    this.resources = undefined
    this.replacementUrls = undefined
    this.html = undefined
    this.assets = undefined
    this.css = undefined

    this.urls = undefined
    this.cssUrls = undefined
  }
}

export default Resources

</code>

packages\epubjs\src\section.js:
<code>
import { DOMParser as XMLDOMSerializer } from '@xmldom/xmldom'

import EpubCFI from './epubcfi'
import { defer } from './utils/core'
import { sprint } from './utils/core'
import Hook from './utils/hook'
import { replaceBase } from './utils/replacements'
import Request from './utils/request'

/**
 * Represents a Section of the Book
 *
 * In most books this is equivalent to a Chapter
 * @param {object} item  The spine item representing the section
 * @param {object} hooks hooks for serialize and content
 */
class Section {
  constructor(item, hooks) {
    this.idref = item.idref
    this.linear = item.linear === 'yes'
    this.properties = item.properties
    this.index = item.index
    this.href = item.href
    this.url = item.url
    this.canonical = item.canonical
    this.next = item.next
    this.prev = item.prev

    this.cfiBase = item.cfiBase

    if (hooks) {
      this.hooks = hooks
    } else {
      this.hooks = {}
      this.hooks.serialize = new Hook(this)
      this.hooks.content = new Hook(this)
    }

    this.document = undefined
    this.contents = undefined
    this.output = undefined
  }

  /**
   * Load the section from its url
   * @param  {method} [_request] a request method to use for loading
   * @return {document} a promise with the xml document
   */
  load(_request) {
    var request = _request || this.request || Request
    var loading = new defer()
    var loaded = loading.promise

    if (this.contents) {
      loading.resolve(this.contents)
    } else {
      request(this.url)
        .then(
          function (xml) {
            // var directory = new Url(this.url).directory;

            this.document = xml
            this.contents = xml.documentElement

            return this.hooks.content.trigger(this.document, this)
          }.bind(this),
        )
        .then(
          function () {
            loading.resolve(this.contents)
          }.bind(this),
        )
        .catch(function (error) {
          loading.reject(error)
        })
    }

    return loaded
  }

  /**
   * Adds a base tag for resolving urls in the section
   * @private
   */
  base() {
    return replaceBase(this.document, this)
  }

  /**
   * Render the contents of a section
   * @param  {method} [_request] a request method to use for loading
   * @return {string} output a serialized XML Document
   */
  render(_request) {
    var rendering = new defer()
    var rendered = rendering.promise
    this.output // TODO: better way to return this from hooks?

    this.load(_request)
      .then(
        function (contents) {
          var userAgent =
            (typeof navigator !== 'undefined' && navigator.userAgent) || ''
          var isIE = userAgent.indexOf('Trident') >= 0
          var Serializer
          if (typeof XMLSerializer === 'undefined' || isIE) {
            Serializer = XMLDOMSerializer
          } else {
            Serializer = XMLSerializer
          }
          var serializer = new Serializer()
          this.output = serializer.serializeToString(contents)
          return this.output
        }.bind(this),
      )
      .then(
        function () {
          return this.hooks.serialize.trigger(this.output, this)
        }.bind(this),
      )
      .then(
        function () {
          rendering.resolve(this.output)
        }.bind(this),
      )
      .catch(function (error) {
        rendering.reject(error)
      })

    return rendered
  }

  /**
   * Find a string in a section
   * @param  {string} _query The query string to find
   * @return {object[]} A list of matches, with form {cfi, excerpt}
   */
  find(_query) {
    var section = this
    var matches = []
    var query = _query.toLowerCase()
    var find = function (node) {
      var text = node.textContent.toLowerCase()
      var range = section.document.createRange()
      var cfi
      var pos
      var last = -1
      var excerpt
      var limit = 150

      while (pos != -1) {
        // Search for the query
        pos = text.indexOf(query, last + 1)

        if (pos != -1) {
          // We found it! Generate a CFI
          range = section.document.createRange()
          range.setStart(node, pos)
          range.setEnd(node, pos + query.length)

          cfi = section.cfiFromRange(range)

          // Generate the excerpt
          if (node.textContent.length < limit) {
            excerpt = node.textContent
          } else {
            excerpt = node.textContent.substring(
              pos - limit / 2,
              pos + limit / 2,
            )
            excerpt = '...' + excerpt + '...'
          }

          // Add the CFI to the matches list
          matches.push({
            cfi: cfi,
            excerpt: excerpt,
          })
        }

        last = pos
      }
    }

    sprint(section.document, function (node) {
      find(node)
    })

    return matches
  }

  /**
   * Search a string in multiple sequential Element of the section. If the document.createTreeWalker api is missed(eg: IE8), use `find` as a fallback.
   * @param  {string} _query The query string to search
   * @param  {int} maxSeqEle The maximum number of Element that are combined for search, default value is 5.
   * @return {object[]} A list of matches, with form {cfi, excerpt}
   */
  search(_query, maxSeqEle = 5) {
    if (typeof document.createTreeWalker == 'undefined') {
      return this.find(_query)
    }
    let matches = []
    const excerptLimit = 150
    const section = this
    const query = _query.toLowerCase()
    const search = function (nodeList) {
      const textWithCase = nodeList.reduce((acc, current) => {
        return acc + current.textContent
      }, '')
      const text = textWithCase.toLowerCase()
      const pos = text.indexOf(query)
      if (pos != -1) {
        const startNodeIndex = 0,
          endPos = pos + query.length
        let endNodeIndex = 0,
          l = 0
        if (pos < nodeList[startNodeIndex].length) {
          let cfi
          while (endNodeIndex < nodeList.length - 1) {
            l += nodeList[endNodeIndex].length
            if (endPos <= l) {
              break
            }
            endNodeIndex += 1
          }

          let startNode = nodeList[startNodeIndex],
            endNode = nodeList[endNodeIndex]
          let range = section.document.createRange()
          range.setStart(startNode, pos)
          let beforeEndLengthCount = nodeList
            .slice(0, endNodeIndex)
            .reduce((acc, current) => {
              return acc + current.textContent.length
            }, 0)
          range.setEnd(
            endNode,
            beforeEndLengthCount > endPos
              ? endPos
              : endPos - beforeEndLengthCount,
          )
          cfi = section.cfiFromRange(range)

          let excerpt = nodeList
            .slice(0, endNodeIndex + 1)
            .reduce((acc, current) => {
              return acc + current.textContent
            }, '')
          if (excerpt.length > excerptLimit) {
            excerpt = excerpt.substring(
              pos - excerptLimit / 2,
              pos + excerptLimit / 2,
            )
            excerpt = '...' + excerpt + '...'
          }
          matches.push({
            cfi: cfi,
            excerpt: excerpt,
          })
        }
      }
    }

    const treeWalker = document.createTreeWalker(
      section.document,
      NodeFilter.SHOW_TEXT,
      null,
      false,
    )
    let node,
      nodeList = []
    while ((node = treeWalker.nextNode())) {
      nodeList.push(node)
      if (nodeList.length == maxSeqEle) {
        search(nodeList.slice(0, maxSeqEle))
        nodeList = nodeList.slice(1, maxSeqEle)
      }
    }
    if (nodeList.length > 0) {
      search(nodeList)
    }
    return matches
  }

  /**
   * Reconciles the current chapters layout properties with
   * the global layout properties.
   * @param {object} globalLayout  The global layout settings object, chapter properties string
   * @return {object} layoutProperties Object with layout properties
   */
  reconcileLayoutSettings(globalLayout) {
    //-- Get the global defaults
    var settings = {
      layout: globalLayout.layout,
      spread: globalLayout.spread,
      orientation: globalLayout.orientation,
    }

    //-- Get the chapter's display type
    this.properties.forEach(function (prop) {
      var rendition = prop.replace('rendition:', '')
      var split = rendition.indexOf('-')
      var property, value

      if (split != -1) {
        property = rendition.slice(0, split)
        value = rendition.slice(split + 1)

        settings[property] = value
      }
    })
    return settings
  }

  /**
   * Get a CFI from a Range in the Section
   * @param  {range} _range
   * @return {string} cfi an EpubCFI string
   */
  cfiFromRange(_range) {
    return new EpubCFI(_range, this.cfiBase).toString()
  }

  /**
   * Get a CFI from an Element in the Section
   * @param  {element} el
   * @return {string} cfi an EpubCFI string
   */
  cfiFromElement(el) {
    return new EpubCFI(el, this.cfiBase).toString()
  }

  /**
   * Unload the section document
   */
  unload() {
    this.document = undefined
    this.contents = undefined
    this.output = undefined
  }

  destroy() {
    this.unload()
    this.hooks.serialize.clear()
    this.hooks.content.clear()

    this.hooks = undefined
    this.idref = undefined
    this.linear = undefined
    this.properties = undefined
    this.index = undefined
    this.href = undefined
    this.url = undefined
    this.next = undefined
    this.prev = undefined

    this.cfiBase = undefined
  }
}

export default Section

</code>

packages\epubjs\src\spine.js:
<code>
import EpubCFI from './epubcfi'
import Section from './section'
import Hook from './utils/hook'
import {
  replaceBase,
  replaceCanonical,
  replaceMeta,
} from './utils/replacements'

/**
 * A collection of Spine Items
 */
class Spine {
  constructor() {
    this.spineItems = []
    this.spineByHref = {}
    this.spineById = {}

    this.hooks = {}
    this.hooks.serialize = new Hook()
    this.hooks.content = new Hook()

    // Register replacements
    this.hooks.content.register(replaceBase)
    this.hooks.content.register(replaceCanonical)
    this.hooks.content.register(replaceMeta)

    this.epubcfi = new EpubCFI()

    this.loaded = false

    this.items = undefined
    this.manifest = undefined
    this.spineNodeIndex = undefined
    this.baseUrl = undefined
    this.length = undefined
  }

  /**
   * Unpack items from a opf into spine items
   * @param  {Packaging} _package
   * @param  {method} resolver URL resolver
   * @param  {method} canonical Resolve canonical url
   */
  unpack(_package, resolver, canonical) {
    this.items = _package.spine
    this.manifest = _package.manifest
    this.spineNodeIndex = _package.spineNodeIndex
    this.baseUrl = _package.baseUrl || _package.basePath || ''
    this.length = this.items.length

    this.items.forEach((item, index) => {
      var manifestItem = this.manifest[item.idref]
      var spineItem

      item.index = index
      item.cfiBase = this.epubcfi.generateChapterComponent(
        this.spineNodeIndex,
        item.index,
        item.id,
      )

      if (item.href) {
        item.url = resolver(item.href, true)
        item.canonical = canonical(item.href)
      }

      if (manifestItem) {
        item.href = manifestItem.href
        item.url = resolver(item.href, true)
        item.canonical = canonical(item.href)

        if (manifestItem.properties.length) {
          item.properties.push.apply(item.properties, manifestItem.properties)
        }
      }

      if (item.linear === 'yes') {
        item.prev = function () {
          let prevIndex = item.index
          while (prevIndex > 0) {
            let prev = this.get(prevIndex - 1)
            if (prev && prev.linear) {
              return prev
            }
            prevIndex -= 1
          }
          return
        }.bind(this)
        item.next = function () {
          let nextIndex = item.index
          while (nextIndex < this.spineItems.length - 1) {
            let next = this.get(nextIndex + 1)
            if (next && next.linear) {
              return next
            }
            nextIndex += 1
          }
          return
        }.bind(this)
      } else {
        item.prev = function () {
          return
        }
        item.next = function () {
          return
        }
      }

      spineItem = new Section(item, this.hooks)

      this.append(spineItem)
    })

    this.loaded = true
  }

  /**
   * Get an item from the spine
   * @param  {string|number} [target]
   * @return {Section} section
   * @example spine.get();
   * @example spine.get(1);
   * @example spine.get("chap1.html");
   * @example spine.get("#id1234");
   */
  get(target) {
    var index = 0

    if (typeof target === 'undefined') {
      while (index < this.spineItems.length) {
        let next = this.spineItems[index]
        if (next && next.linear) {
          break
        }
        index += 1
      }
    } else if (this.epubcfi.isCfiString(target)) {
      let cfi = new EpubCFI(target)
      index = cfi.spinePos
    } else if (typeof target === 'number' || isNaN(target) === false) {
      index = target
    } else if (typeof target === 'string' && target.indexOf('#') === 0) {
      index = this.spineById[target.substring(1)]
    } else if (typeof target === 'string') {
      // Remove fragments
      target = target.split('#')[0]
      index = this.spineByHref[target] || this.spineByHref[encodeURI(target)]
    }

    return this.spineItems[index] || null
  }

  /**
   * Append a Section to the Spine
   * @private
   * @param  {Section} section
   */
  append(section) {
    var index = this.spineItems.length
    section.index = index

    this.spineItems.push(section)

    // Encode and Decode href lookups
    // see pr for details: https://github.com/futurepress/epub.js/pull/358
    this.spineByHref[decodeURI(section.href)] = index
    this.spineByHref[encodeURI(section.href)] = index
    this.spineByHref[section.href] = index

    this.spineById[section.idref] = index

    return index
  }

  /**
   * Prepend a Section to the Spine
   * @private
   * @param  {Section} section
   */
  prepend(section) {
    // var index = this.spineItems.unshift(section);
    this.spineByHref[section.href] = 0
    this.spineById[section.idref] = 0

    // Re-index
    this.spineItems.forEach(function (item, index) {
      item.index = index
    })

    return 0
  }

  // insert(section, index) {
  //
  // };

  /**
   * Remove a Section from the Spine
   * @private
   * @param  {Section} section
   */
  remove(section) {
    var index = this.spineItems.indexOf(section)

    if (index > -1) {
      delete this.spineByHref[section.href]
      delete this.spineById[section.idref]

      return this.spineItems.splice(index, 1)
    }
  }

  /**
   * Loop over the Sections in the Spine
   * @return {method} forEach
   */
  each() {
    return this.spineItems.forEach.apply(this.spineItems, arguments)
  }

  /**
   * Find the first Section in the Spine
   * @return {Section} first section
   */
  first() {
    let index = 0

    do {
      let next = this.get(index)

      if (next && next.linear) {
        return next
      }
      index += 1
    } while (index < this.spineItems.length)
  }

  /**
   * Find the last Section in the Spine
   * @return {Section} last section
   */
  last() {
    let index = this.spineItems.length - 1

    do {
      let prev = this.get(index)
      if (prev && prev.linear) {
        return prev
      }
      index -= 1
    } while (index >= 0)
  }

  destroy() {
    this.each((section) => section.destroy())

    this.spineItems = undefined
    this.spineByHref = undefined
    this.spineById = undefined

    this.hooks.serialize.clear()
    this.hooks.content.clear()
    this.hooks = undefined

    this.epubcfi = undefined

    this.loaded = false

    this.items = undefined
    this.manifest = undefined
    this.spineNodeIndex = undefined
    this.baseUrl = undefined
    this.length = undefined
  }
}

export default Spine

</code>

packages\epubjs\src\store.js:
<code>
import EventEmitter from 'event-emitter'
import localforage from 'localforage'

import { defer, isXml, parse } from './utils/core'
import mime from './utils/mime'
import Path from './utils/path'
import httpRequest from './utils/request'

/**
 * Handles saving and requesting files from local storage
 * @class
 * @param {string} name This should be the name of the application for modals
 * @param {function} [requester]
 * @param {function} [resolver]
 */
class Store {
  constructor(name, requester, resolver) {
    this.urlCache = {}

    this.storage = undefined

    this.name = name
    this.requester = requester || httpRequest
    this.resolver = resolver

    this.online = true

    this.checkRequirements()

    this.addListeners()
  }

  /**
   * Checks to see if localForage exists in global namspace,
   * Requires localForage if it isn't there
   * @private
   */
  checkRequirements() {
    try {
      let store
      if (typeof localforage === 'undefined') {
        store = localforage
      }
      this.storage = store.createInstance({
        name: this.name,
      })
    } catch (e) {
      throw new Error('localForage lib not loaded')
    }
  }

  /**
   * Add online and offline event listeners
   * @private
   */
  addListeners() {
    this._status = this.status.bind(this)
    window.addEventListener('online', this._status)
    window.addEventListener('offline', this._status)
  }

  /**
   * Remove online and offline event listeners
   * @private
   */
  removeListeners() {
    window.removeEventListener('online', this._status)
    window.removeEventListener('offline', this._status)
    this._status = undefined
  }

  /**
   * Update the online / offline status
   * @private
   */
  status(event) {
    let online = navigator.onLine
    this.online = online
    if (online) {
      this.emit('online', this)
    } else {
      this.emit('offline', this)
    }
  }

  /**
   * Add all of a book resources to the store
   * @param  {Resources} resources  book resources
   * @param  {boolean} [force] force resaving resources
   * @return {Promise<object>} store objects
   */
  add(resources, force) {
    let mapped = resources.resources.map((item) => {
      let { href } = item
      let url = this.resolver(href)
      let encodedUrl = window.encodeURIComponent(url)

      return this.storage.getItem(encodedUrl).then((item) => {
        if (!item || force) {
          return this.requester(url, 'binary').then((data) => {
            return this.storage.setItem(encodedUrl, data)
          })
        } else {
          return item
        }
      })
    })
    return Promise.all(mapped)
  }

  /**
   * Put binary data from a url to storage
   * @param  {string} url  a url to request from storage
   * @param  {boolean} [withCredentials]
   * @param  {object} [headers]
   * @return {Promise<Blob>}
   */
  put(url, withCredentials, headers) {
    let encodedUrl = window.encodeURIComponent(url)

    return this.storage.getItem(encodedUrl).then((result) => {
      if (!result) {
        return this.requester(url, 'binary', withCredentials, headers).then(
          (data) => {
            return this.storage.setItem(encodedUrl, data)
          },
        )
      }
      return result
    })
  }

  /**
   * Request a url
   * @param  {string} url  a url to request from storage
   * @param  {string} [type] specify the type of the returned result
   * @param  {boolean} [withCredentials]
   * @param  {object} [headers]
   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}
   */
  request(url, type, withCredentials, headers) {
    if (this.online) {
      // From network
      return this.requester(url, type, withCredentials, headers).then(
        (data) => {
          // save to store if not present
          this.put(url)
          return data
        },
      )
    } else {
      // From store
      return this.retrieve(url, type)
    }
  }

  /**
   * Request a url from storage
   * @param  {string} url  a url to request from storage
   * @param  {string} [type] specify the type of the returned result
   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}
   */
  retrieve(url, type) {
    var deferred = new defer()
    var response
    var path = new Path(url)

    // If type isn't set, determine it from the file extension
    if (!type) {
      type = path.extension
    }

    if (type == 'blob') {
      response = this.getBlob(url)
    } else {
      response = this.getText(url)
    }

    return response.then((r) => {
      var deferred = new defer()
      var result
      if (r) {
        result = this.handleResponse(r, type)
        deferred.resolve(result)
      } else {
        deferred.reject({
          message: 'File not found in storage: ' + url,
          stack: new Error().stack,
        })
      }
      return deferred.promise
    })
  }

  /**
   * Handle the response from request
   * @private
   * @param  {any} response
   * @param  {string} [type]
   * @return {any} the parsed result
   */
  handleResponse(response, type) {
    var r

    if (type == 'json') {
      r = JSON.parse(response)
    } else if (isXml(type)) {
      r = parse(response, 'text/xml')
    } else if (type == 'xhtml') {
      r = parse(response, 'application/xhtml+xml')
    } else if (type == 'html' || type == 'htm') {
      r = parse(response, 'text/html')
    } else {
      r = response
    }

    return r
  }

  /**
   * Get a Blob from Storage by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {Blob}
   */
  getBlob(url, mimeType) {
    let encodedUrl = window.encodeURIComponent(url)

    return this.storage.getItem(encodedUrl).then(function (uint8array) {
      if (!uint8array) return

      mimeType = mimeType || mime.lookup(url)

      return new Blob([uint8array], { type: mimeType })
    })
  }

  /**
   * Get Text from Storage by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {string}
   */
  getText(url, mimeType) {
    let encodedUrl = window.encodeURIComponent(url)

    mimeType = mimeType || mime.lookup(url)

    return this.storage.getItem(encodedUrl).then(function (uint8array) {
      var deferred = new defer()
      var reader = new FileReader()
      var blob

      if (!uint8array) return

      blob = new Blob([uint8array], { type: mimeType })

      reader.addEventListener('loadend', () => {
        deferred.resolve(reader.result)
      })

      reader.readAsText(blob, mimeType)

      return deferred.promise
    })
  }

  /**
   * Get a base64 encoded result from Storage by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {string} base64 encoded
   */
  getBase64(url, mimeType) {
    let encodedUrl = window.encodeURIComponent(url)

    mimeType = mimeType || mime.lookup(url)

    return this.storage.getItem(encodedUrl).then((uint8array) => {
      var deferred = new defer()
      var reader = new FileReader()
      var blob

      if (!uint8array) return

      blob = new Blob([uint8array], { type: mimeType })

      reader.addEventListener('loadend', () => {
        deferred.resolve(reader.result)
      })
      reader.readAsDataURL(blob, mimeType)

      return deferred.promise
    })
  }

  /**
   * Create a Url from a stored item
   * @param  {string} url
   * @param  {object} [options.base64] use base64 encoding or blob url
   * @return {Promise} url promise with Url string
   */
  createUrl(url, options) {
    var deferred = new defer()
    var _URL = window.URL || window.webkitURL || window.mozURL
    var tempUrl
    var response
    var useBase64 = options && options.base64

    if (url in this.urlCache) {
      deferred.resolve(this.urlCache[url])
      return deferred.promise
    }

    if (useBase64) {
      response = this.getBase64(url)

      if (response) {
        response.then(
          function (tempUrl) {
            this.urlCache[url] = tempUrl
            deferred.resolve(tempUrl)
          }.bind(this),
        )
      }
    } else {
      response = this.getBlob(url)

      if (response) {
        response.then(
          function (blob) {
            tempUrl = _URL.createObjectURL(blob)
            this.urlCache[url] = tempUrl
            deferred.resolve(tempUrl)
          }.bind(this),
        )
      }
    }

    if (!response) {
      deferred.reject({
        message: 'File not found in storage: ' + url,
        stack: new Error().stack,
      })
    }

    return deferred.promise
  }

  /**
   * Revoke Temp Url for a archive item
   * @param  {string} url url of the item in the store
   */
  revokeUrl(url) {
    var _URL = window.URL || window.webkitURL || window.mozURL
    var fromCache = this.urlCache[url]
    if (fromCache) _URL.revokeObjectURL(fromCache)
  }

  destroy() {
    var _URL = window.URL || window.webkitURL || window.mozURL
    for (let fromCache in this.urlCache) {
      _URL.revokeObjectURL(fromCache)
    }
    this.urlCache = {}
    this.removeListeners()
  }
}

EventEmitter(Store.prototype)

export default Store

</code>

packages\epubjs\src\themes.js:
<code>
import Url from './utils/url'

/**
 * Themes to apply to displayed content
 * @class
 * @param {Rendition} rendition
 */
class Themes {
  constructor(rendition) {
    this.rendition = rendition
    this._themes = {
      default: {
        rules: {},
        url: '',
        serialized: '',
      },
    }
    this._overrides = {}
    this._current = 'default'
    this._injected = []
    this.rendition.hooks.content.register(this.inject.bind(this))
    this.rendition.hooks.content.register(this.overrides.bind(this))
  }

  /**
   * Add themes to be used by a rendition
   * @param {object | Array<object> | string}
   * @example themes.register("light", "http://example.com/light.css")
   * @example themes.register("light", { "body": { "color": "purple"}})
   * @example themes.register({ "light" : {...}, "dark" : {...}})
   */
  register() {
    if (arguments.length === 0) {
      return
    }
    if (arguments.length === 1 && typeof arguments[0] === 'object') {
      return this.registerThemes(arguments[0])
    }
    if (arguments.length === 1 && typeof arguments[0] === 'string') {
      return this.default(arguments[0])
    }
    if (arguments.length === 2 && typeof arguments[1] === 'string') {
      return this.registerUrl(arguments[0], arguments[1])
    }
    if (arguments.length === 2 && typeof arguments[1] === 'object') {
      return this.registerRules(arguments[0], arguments[1])
    }
  }

  /**
   * Add a default theme to be used by a rendition
   * @param {object | string} theme
   * @example themes.register("http://example.com/default.css")
   * @example themes.register({ "body": { "color": "purple"}})
   */
  default(theme) {
    if (!theme) {
      return
    }
    if (typeof theme === 'string') {
      return this.registerUrl('default', theme)
    }
    if (typeof theme === 'object') {
      return this.registerRules('default', theme)
    }
  }

  /**
   * Register themes object
   * @param {object} themes
   */
  registerThemes(themes) {
    for (var theme in themes) {
      if (themes.hasOwnProperty(theme)) {
        if (typeof themes[theme] === 'string') {
          this.registerUrl(theme, themes[theme])
        } else {
          this.registerRules(theme, themes[theme])
        }
      }
    }
  }

  /**
   * Register a theme by passing its css as string
   * @param {string} name
   * @param {string} css
   */
  registerCss(name, css) {
    this._themes[name] = { serialized: css }
    if (this._injected[name] || name == 'default') {
      this.update(name)
    }
  }

  /**
   * Register a url
   * @param {string} name
   * @param {string} input
   */
  registerUrl(name, input) {
    var url = new Url(input)
    this._themes[name] = { url: url.toString() }
    if (this._injected[name] || name == 'default') {
      this.update(name)
    }
  }

  /**
   * Register rule
   * @param {string} name
   * @param {object} rules
   */
  registerRules(name, rules) {
    this._themes[name] = { rules: rules }
    // TODO: serialize css rules
    if (this._injected[name] || name == 'default') {
      this.update(name)
    }
  }

  /**
   * Select a theme
   * @param {string} name
   */
  select(name) {
    var prev = this._current
    var contents

    this._current = name
    this.update(name)

    contents = this.rendition.getContents()
    contents.forEach((content) => {
      content.removeClass(prev)
      content.addClass(name)
    })
  }

  /**
   * Update a theme
   * @param {string} name
   */
  update(name) {
    var contents = this.rendition.getContents()
    contents.forEach((content) => {
      this.add(name, content)
    })
  }

  /**
   * Inject all themes into contents
   * @param {Contents} contents
   */
  inject(contents) {
    var links = []
    var themes = this._themes
    var theme

    for (var name in themes) {
      if (
        themes.hasOwnProperty(name) &&
        (name === this._current || name === 'default')
      ) {
        theme = themes[name]
        if (
          (theme.rules && Object.keys(theme.rules).length > 0) ||
          (theme.url && links.indexOf(theme.url) === -1)
        ) {
          this.add(name, contents)
        }
        this._injected.push(name)
      }
    }

    if (this._current != 'default') {
      contents.addClass(this._current)
    }
  }

  /**
   * Add Theme to contents
   * @param {string} name
   * @param {Contents} contents
   */
  add(name, contents) {
    var theme = this._themes[name]

    if (!theme || !contents) {
      return
    }

    if (theme.url) {
      contents.addStylesheet(theme.url)
    } else if (theme.serialized) {
      contents.addStylesheetCss(theme.serialized, name)
      theme.injected = true
    } else if (theme.rules) {
      contents.addStylesheetRules(theme.rules, name)
      theme.injected = true
    }
  }

  /**
   * Add override
   * @param {string} name
   * @param {string} value
   * @param {boolean} priority
   */
  override(name, value, priority) {
    var contents = this.rendition.getContents()

    this._overrides[name] = {
      value: value,
      priority: priority === true,
    }

    contents.forEach((content) => {
      content.css(
        name,
        this._overrides[name].value,
        this._overrides[name].priority,
      )
    })
  }

  removeOverride(name) {
    var contents = this.rendition.getContents()

    delete this._overrides[name]

    contents.forEach((content) => {
      content.css(name)
    })
  }

  /**
   * Add all overrides
   * @param {Content} content
   */
  overrides(contents) {
    var overrides = this._overrides

    for (var rule in overrides) {
      if (overrides.hasOwnProperty(rule)) {
        contents.css(rule, overrides[rule].value, overrides[rule].priority)
      }
    }
  }

  /**
   * Adjust the font size of a rendition
   * @param {number} size
   */
  fontSize(size) {
    this.override('font-size', size)
  }

  /**
   * Adjust the font-family of a rendition
   * @param {string} f
   */
  font(f) {
    this.override('font-family', f, true)
  }

  destroy() {
    this.rendition = undefined
    this._themes = undefined
    this._overrides = undefined
    this._current = undefined
    this._injected = undefined
  }
}

export default Themes

</code>

packages\epubjs\src\managers\continuous\index.js:
<code>
import debounce from 'lodash/debounce'

import { EVENTS } from '../../utils/constants'
import { extend, defer, requestAnimationFrame } from '../../utils/core'
import DefaultViewManager from '../default'
import Snap from '../helpers/snap'

class ContinuousViewManager extends DefaultViewManager {
  constructor(options) {
    super(options)

    this.name = 'continuous'

    this.settings = extend(this.settings || {}, {
      infinite: true,
      overflow: undefined,
      axis: undefined,
      writingMode: undefined,
      flow: 'scrolled',
      offset: 500,
      offsetDelta: 250,
      width: undefined,
      height: undefined,
      snap: false,
      afterScrolledTimeout: 10,
      allowScriptedContent: false,
      allowPopups: false,
    })

    extend(this.settings, options.settings || {})

    // Gap can be 0, but defaults doesn't handle that
    if (options.settings.gap != 'undefined' && options.settings.gap === 0) {
      this.settings.gap = options.settings.gap
    }

    this.viewSettings = {
      ignoreClass: this.settings.ignoreClass,
      axis: this.settings.axis,
      flow: this.settings.flow,
      layout: this.layout,
      width: 0,
      height: 0,
      forceEvenPages: false,
      allowScriptedContent: this.settings.allowScriptedContent,
      allowPopups: this.settings.allowPopups,
    }

    this.scrollTop = 0
    this.scrollLeft = 0
  }

  display(section, target) {
    return DefaultViewManager.prototype.display
      .call(this, section, target)
      .then(
        function () {
          return this.fill()
        }.bind(this),
      )
  }

  fill(_full) {
    var full = _full || new defer()

    this.q
      .enqueue(() => {
        return this.check()
      })
      .then((result) => {
        if (result) {
          this.fill(full)
        } else {
          full.resolve()
        }
      })

    return full.promise
  }

  moveTo(offset) {
    // var bounds = this.stage.bounds();
    // var dist = Math.floor(offset.top / bounds.height) * bounds.height;
    var distX = 0,
      distY = 0

    var offsetX = 0,
      offsetY = 0

    if (!this.isPaginated) {
      distY = offset.top
      offsetY = offset.top + this.settings.offsetDelta
    } else {
      distX = Math.floor(offset.left / this.layout.delta) * this.layout.delta
      offsetX = distX + this.settings.offsetDelta
    }

    if (distX > 0 || distY > 0) {
      this.scrollBy(distX, distY, true)
    }
  }

  afterResized(view) {
    this.emit(EVENTS.MANAGERS.RESIZE, view.section)
  }

  // Remove Previous Listeners if present
  removeShownListeners(view) {
    // view.off("shown", this.afterDisplayed);
    // view.off("shown", this.afterDisplayedAbove);
    view.onDisplayed = function () {}
  }

  add(section) {
    var view = this.createView(section)

    this.views.append(view)

    view.on(EVENTS.VIEWS.RESIZED, (bounds) => {
      view.expanded = true
    })

    view.on(EVENTS.VIEWS.AXIS, (axis) => {
      this.updateAxis(axis)
    })

    view.on(EVENTS.VIEWS.WRITING_MODE, (mode) => {
      this.updateWritingMode(mode)
    })

    // view.on(EVENTS.VIEWS.SHOWN, this.afterDisplayed.bind(this));
    view.onDisplayed = this.afterDisplayed.bind(this)
    view.onResize = this.afterResized.bind(this)

    return view.display(this.request)
  }

  append(section) {
    var view = this.createView(section)

    view.on(EVENTS.VIEWS.RESIZED, (bounds) => {
      view.expanded = true
    })

    view.on(EVENTS.VIEWS.AXIS, (axis) => {
      this.updateAxis(axis)
    })

    view.on(EVENTS.VIEWS.WRITING_MODE, (mode) => {
      this.updateWritingMode(mode)
    })

    this.views.append(view)

    view.onDisplayed = this.afterDisplayed.bind(this)

    return view
  }

  prepend(section) {
    var view = this.createView(section)

    view.on(EVENTS.VIEWS.RESIZED, (bounds) => {
      this.counter(bounds)
      view.expanded = true
    })

    view.on(EVENTS.VIEWS.AXIS, (axis) => {
      this.updateAxis(axis)
    })

    view.on(EVENTS.VIEWS.WRITING_MODE, (mode) => {
      this.updateWritingMode(mode)
    })

    this.views.prepend(view)

    view.onDisplayed = this.afterDisplayed.bind(this)

    return view
  }

  counter(bounds) {
    if (this.settings.axis === 'vertical') {
      this.scrollBy(0, bounds.heightDelta, true)
    } else {
      this.scrollBy(bounds.widthDelta, 0, true)
    }
  }

  update(_offset) {
    var container = this.bounds()
    var views = this.views.all()
    var viewsLength = views.length
    var visible = []
    var offset =
      typeof _offset != 'undefined' ? _offset : this.settings.offset || 0
    var isVisible
    var view

    var updating = new defer()
    var promises = []
    for (var i = 0; i < viewsLength; i++) {
      view = views[i]

      isVisible = this.isVisible(view, offset, offset, container)

      if (isVisible === true) {
        // console.log("visible " + view.index, view.displayed);

        if (!view.displayed) {
          let displayed = view.display(this.request).then(
            function (view) {
              view.show()
            },
            (err) => {
              view.hide()
            },
          )
          promises.push(displayed)
        } else {
          view.show()
        }
        visible.push(view)
      } else {
        this.q.enqueue(view.destroy.bind(view))
        // console.log("hidden " + view.index, view.displayed);

        clearTimeout(this.trimTimeout)
        this.trimTimeout = setTimeout(
          function () {
            this.q.enqueue(this.trim.bind(this))
          }.bind(this),
          250,
        )
      }
    }

    if (promises.length) {
      return Promise.all(promises).catch((err) => {
        updating.reject(err)
      })
    } else {
      updating.resolve()
      return updating.promise
    }
  }

  check(_offsetLeft, _offsetTop) {
    var checking = new defer()
    var newViews = []

    var horizontal = this.settings.axis === 'horizontal'
    var delta = this.settings.offset || 0

    if (_offsetLeft && horizontal) {
      delta = _offsetLeft
    }

    if (_offsetTop && !horizontal) {
      delta = _offsetTop
    }

    var bounds = this._bounds // bounds saved this until resize

    let offset = horizontal ? this.scrollLeft : this.scrollTop
    let visibleLength = horizontal ? Math.floor(bounds.width) : bounds.height
    let contentLength = horizontal
      ? this.container.scrollWidth
      : this.container.scrollHeight
    let writingMode =
      this.writingMode && this.writingMode.indexOf('vertical') === 0
        ? 'vertical'
        : 'horizontal'
    let rtlScrollType = this.settings.rtlScrollType
    let rtl = this.settings.direction === 'rtl'

    if (!this.settings.fullsize) {
      // Scroll offset starts at width of element
      if (rtl && rtlScrollType === 'default' && writingMode === 'horizontal') {
        offset = contentLength - visibleLength - offset
      }
      // Scroll offset starts at 0 and goes negative
      if (rtl && rtlScrollType === 'negative' && writingMode === 'horizontal') {
        offset = offset * -1
      }
    } else {
      // Scroll offset starts at 0 and goes negative
      if (
        (horizontal && rtl && rtlScrollType === 'negative') ||
        (!horizontal && rtl && rtlScrollType === 'default')
      ) {
        offset = offset * -1
      }
    }

    let prepend = () => {
      let first = this.views.first()
      let prev = first && first.section.prev()

      if (prev) {
        newViews.push(this.prepend(prev))
      }
    }

    let append = () => {
      let last = this.views.last()
      let next = last && last.section.next()

      if (next) {
        newViews.push(this.append(next))
      }
    }

    let end = offset + visibleLength + delta
    let start = offset - delta

    if (end >= contentLength) {
      append()
    }

    if (start < 0) {
      prepend()
    }

    let promises = newViews.map((view) => {
      return view.display(this.request)
    })

    if (newViews.length) {
      return Promise.all(promises)
        .then(() => {
          return this.check()
        })
        .then(
          () => {
            // Check to see if anything new is on screen after rendering
            return this.update(delta)
          },
          (err) => {
            return err
          },
        )
    } else {
      this.q.enqueue(
        function () {
          this.update()
        }.bind(this),
      )
      checking.resolve(false)
      return checking.promise
    }
  }

  trim() {
    var task = new defer()
    var displayed = this.views.displayed()
    var first = displayed[0]
    var last = displayed[displayed.length - 1]
    var firstIndex = this.views.indexOf(first)
    var lastIndex = this.views.indexOf(last)
    var above = this.views.slice(0, firstIndex)
    var below = this.views.slice(lastIndex + 1)

    // Erase all but last above
    for (var i = 0; i < above.length - 1; i++) {
      this.erase(above[i], above)
    }

    // Erase all except first below
    for (var j = 1; j < below.length; j++) {
      this.erase(below[j])
    }

    task.resolve()
    return task.promise
  }

  erase(view, above) {
    //Trim

    var prevTop
    var prevLeft

    if (!this.settings.fullsize) {
      prevTop = this.container.scrollTop
      prevLeft = this.container.scrollLeft
    } else {
      prevTop = window.scrollY
      prevLeft = window.scrollX
    }

    var bounds = view.bounds()

    this.views.remove(view)

    if (above) {
      if (this.settings.axis === 'vertical') {
        this.scrollTo(0, prevTop - bounds.height, true)
      } else {
        if (this.settings.direction === 'rtl') {
          if (!this.settings.fullsize) {
            this.scrollTo(prevLeft, 0, true)
          } else {
            this.scrollTo(prevLeft + Math.floor(bounds.width), 0, true)
          }
        } else {
          this.scrollTo(prevLeft - Math.floor(bounds.width), 0, true)
        }
      }
    }
  }

  addEventListeners(stage) {
    window.addEventListener(
      'unload',
      function (e) {
        this.ignore = true
        // this.scrollTo(0,0);
        this.destroy()
      }.bind(this),
    )

    this.addScrollListeners()

    if (this.isPaginated && this.settings.snap) {
      this.snapper = new Snap(
        this,
        this.settings.snap &&
          typeof this.settings.snap === 'object' &&
          this.settings.snap,
      )
    }
  }

  addScrollListeners() {
    var scroller

    this.tick = requestAnimationFrame

    let dir =
      this.settings.direction === 'rtl' &&
      this.settings.rtlScrollType === 'default'
        ? -1
        : 1

    this.scrollDeltaVert = 0
    this.scrollDeltaHorz = 0

    if (!this.settings.fullsize) {
      scroller = this.container
      this.scrollTop = this.container.scrollTop
      this.scrollLeft = this.container.scrollLeft
    } else {
      scroller = window
      this.scrollTop = window.scrollY * dir
      this.scrollLeft = window.scrollX * dir
    }

    this._onScroll = this.onScroll.bind(this)
    scroller.addEventListener('scroll', this._onScroll)
    this._scrolled = debounce(this.scrolled.bind(this), 30)
    // this.tick.call(window, this.onScroll.bind(this));

    this.didScroll = false
  }

  removeEventListeners() {
    var scroller

    if (!this.settings.fullsize) {
      scroller = this.container
    } else {
      scroller = window
    }

    scroller.removeEventListener('scroll', this._onScroll)
    this._onScroll = undefined
  }

  onScroll() {
    let scrollTop
    let scrollLeft
    let dir =
      this.settings.direction === 'rtl' &&
      this.settings.rtlScrollType === 'default'
        ? -1
        : 1

    if (!this.settings.fullsize) {
      scrollTop = this.container.scrollTop
      scrollLeft = this.container.scrollLeft
    } else {
      scrollTop = window.scrollY * dir
      scrollLeft = window.scrollX * dir
    }

    this.scrollTop = scrollTop
    this.scrollLeft = scrollLeft

    if (!this.ignore) {
      this._scrolled()
    } else {
      this.ignore = false
    }

    this.scrollDeltaVert += Math.abs(scrollTop - this.prevScrollTop)
    this.scrollDeltaHorz += Math.abs(scrollLeft - this.prevScrollLeft)

    this.prevScrollTop = scrollTop
    this.prevScrollLeft = scrollLeft

    clearTimeout(this.scrollTimeout)
    this.scrollTimeout = setTimeout(
      function () {
        this.scrollDeltaVert = 0
        this.scrollDeltaHorz = 0
      }.bind(this),
      150,
    )

    clearTimeout(this.afterScrolled)

    this.didScroll = false
  }

  scrolled() {
    this.q.enqueue(
      function () {
        return this.check()
      }.bind(this),
    )

    this.emit(EVENTS.MANAGERS.SCROLL, {
      top: this.scrollTop,
      left: this.scrollLeft,
    })

    clearTimeout(this.afterScrolled)
    this.afterScrolled = setTimeout(
      function () {
        // Don't report scroll if we are about the snap
        if (
          this.snapper &&
          this.snapper.supportsTouch &&
          this.snapper.needsSnap()
        ) {
          return
        }

        this.emit(EVENTS.MANAGERS.SCROLLED, {
          top: this.scrollTop,
          left: this.scrollLeft,
        })
      }.bind(this),
      this.settings.afterScrolledTimeout,
    )
  }

  next() {
    let delta =
      this.layout.props.name === 'pre-paginated' && this.layout.props.spread
        ? this.layout.props.delta * 2
        : this.layout.props.delta

    if (!this.views.length) return

    if (this.isPaginated && this.settings.axis === 'horizontal') {
      this.scrollBy(delta, 0, true)
    } else {
      this.scrollBy(0, this.layout.height, true)
    }

    this.q.enqueue(
      function () {
        return this.check()
      }.bind(this),
    )
  }

  prev() {
    let delta =
      this.layout.props.name === 'pre-paginated' && this.layout.props.spread
        ? this.layout.props.delta * 2
        : this.layout.props.delta

    if (!this.views.length) return

    if (this.isPaginated && this.settings.axis === 'horizontal') {
      this.scrollBy(-delta, 0, true)
    } else {
      this.scrollBy(0, -this.layout.height, true)
    }

    this.q.enqueue(
      function () {
        return this.check()
      }.bind(this),
    )
  }

  updateFlow(flow) {
    if (this.rendered && this.snapper) {
      this.snapper.destroy()
      this.snapper = undefined
    }

    super.updateFlow(flow, 'scroll')

    if (this.rendered && this.isPaginated && this.settings.snap) {
      this.snapper = new Snap(
        this,
        this.settings.snap &&
          typeof this.settings.snap === 'object' &&
          this.settings.snap,
      )
    }
  }

  destroy() {
    super.destroy()

    if (this.snapper) {
      this.snapper.destroy()
    }
  }
}

export default ContinuousViewManager

</code>

packages\epubjs\src\managers\default\index.js:
<code>
import EventEmitter from 'event-emitter'

import Mapping from '../../mapping'
import { EVENTS } from '../../utils/constants'
import { extend, defer, windowBounds, isNumber } from '../../utils/core'
import Queue from '../../utils/queue'
import scrollType from '../../utils/scrolltype'
import Stage from '../helpers/stage'
import Views from '../helpers/views'

class DefaultViewManager {
  constructor(options) {
    this.name = 'default'
    this.optsSettings = options.settings
    this.View = options.view
    this.request = options.request
    this.renditionQueue = options.queue
    this.q = new Queue(this)

    this.settings = extend(this.settings || {}, {
      infinite: true,
      hidden: false,
      width: undefined,
      height: undefined,
      axis: undefined,
      writingMode: undefined,
      flow: 'scrolled',
      ignoreClass: '',
      fullsize: undefined,
      allowScriptedContent: false,
      allowPopups: false,
    })

    extend(this.settings, options.settings || {})

    this.viewSettings = {
      ignoreClass: this.settings.ignoreClass,
      axis: this.settings.axis,
      flow: this.settings.flow,
      layout: this.layout,
      method: this.settings.method, // srcdoc, blobUrl, write
      width: 0,
      height: 0,
      forceEvenPages: true,
      allowScriptedContent: this.settings.allowScriptedContent,
      allowPopups: this.settings.allowPopups,
    }

    this.rendered = false
  }

  render(element, size) {
    let tag = element.tagName

    if (
      typeof this.settings.fullsize === 'undefined' &&
      tag &&
      (tag.toLowerCase() == 'body' || tag.toLowerCase() == 'html')
    ) {
      this.settings.fullsize = true
    }

    if (this.settings.fullsize) {
      this.settings.overflow = 'visible'
      this.overflow = this.settings.overflow
    }

    this.settings.size = size

    this.settings.rtlScrollType = scrollType()

    // Save the stage
    this.stage = new Stage({
      width: size.width,
      height: size.height,
      overflow: this.overflow,
      hidden: this.settings.hidden,
      axis: this.settings.axis,
      fullsize: this.settings.fullsize,
      direction: this.settings.direction,
    })

    this.stage.attachTo(element)

    // Get this stage container div
    this.container = this.stage.getContainer()

    // Views array methods
    this.views = new Views(this.container)

    // Calculate Stage Size
    this._bounds = this.bounds()
    this._stageSize = this.stage.size()

    // Set the dimensions for views
    this.viewSettings.width = this._stageSize.width
    this.viewSettings.height = this._stageSize.height

    // Function to handle a resize event.
    // Will only attach if width and height are both fixed.
    this.stage.onResize(this.onResized.bind(this))

    this.stage.onOrientationChange(this.onOrientationChange.bind(this))

    // Add Event Listeners
    this.addEventListeners()

    // Add Layout method
    // this.applyLayoutMethod();
    if (this.layout) {
      this.updateLayout()
    }

    this.rendered = true
  }

  addEventListeners() {
    var scroller

    window.addEventListener(
      'unload',
      function (e) {
        this.destroy()
      }.bind(this),
    )

    if (!this.settings.fullsize) {
      scroller = this.container
    } else {
      scroller = window
    }

    this._onScroll = this.onScroll.bind(this)
    scroller.addEventListener('scroll', this._onScroll)
  }

  removeEventListeners() {
    var scroller

    if (!this.settings.fullsize) {
      scroller = this.container
    } else {
      scroller = window
    }

    scroller.removeEventListener('scroll', this._onScroll)
    this._onScroll = undefined
  }

  destroy() {
    clearTimeout(this.orientationTimeout)
    clearTimeout(this.resizeTimeout)
    clearTimeout(this.afterScrolled)

    this.clear()

    this.removeEventListeners()

    this.stage.destroy()

    this.rendered = false

    /*

			clearTimeout(this.trimTimeout);
			if(this.settings.hidden) {
				this.element.removeChild(this.wrapper);
			} else {
				this.element.removeChild(this.container);
			}
		*/
  }

  onOrientationChange(e) {
    let { orientation } = window

    if (this.optsSettings.resizeOnOrientationChange) {
      this.resize()
    }

    // Per ampproject:
    // In IOS 10.3, the measured size of an element is incorrect if the
    // element size depends on window size directly and the measurement
    // happens in window.resize event. Adding a timeout for correct
    // measurement. See https://github.com/ampproject/amphtml/issues/8479
    clearTimeout(this.orientationTimeout)
    this.orientationTimeout = setTimeout(
      function () {
        this.orientationTimeout = undefined

        if (this.optsSettings.resizeOnOrientationChange) {
          this.resize()
        }

        this.emit(EVENTS.MANAGERS.ORIENTATION_CHANGE, orientation)
      }.bind(this),
      500,
    )
  }

  onResized(e) {
    this.resize()
  }

  resize(width, height, epubcfi) {
    let stageSize = this.stage.size(width, height)

    // For Safari, wait for orientation to catch up
    // if the window is a square
    this.winBounds = windowBounds()
    if (
      this.orientationTimeout &&
      this.winBounds.width === this.winBounds.height
    ) {
      // reset the stage size for next resize
      this._stageSize = undefined
      return
    }

    if (
      this._stageSize &&
      this._stageSize.width === stageSize.width &&
      this._stageSize.height === stageSize.height
    ) {
      // Size is the same, no need to resize
      return
    }

    this._stageSize = stageSize

    this._bounds = this.bounds()

    // Clear current views
    this.clear()

    // Update for new views
    this.viewSettings.width = this._stageSize.width
    this.viewSettings.height = this._stageSize.height

    this.updateLayout()

    this.emit(
      EVENTS.MANAGERS.RESIZED,
      {
        width: this._stageSize.width,
        height: this._stageSize.height,
      },
      epubcfi,
    )
  }

  createView(section, forceRight) {
    return new this.View(section, extend(this.viewSettings, { forceRight }))
  }

  handleNextPrePaginated(forceRight, section, action) {
    let next

    if (this.layout.name === 'pre-paginated' && this.layout.divisor > 1) {
      if (forceRight || section.index === 0) {
        // First page (cover) should stand alone for pre-paginated books
        return
      }
      next = section.next()
      if (next && !next.properties.includes('page-spread-left')) {
        return action.call(this, next)
      }
    }
  }

  display(section, target) {
    var displaying = new defer()
    var displayed = displaying.promise

    // Check if moving to target is needed
    if (target === section.href || isNumber(target)) {
      target = undefined
    }

    // Check to make sure the section we want isn't already shown
    var visible = this.views.find(section)

    // View is already shown, just move to correct location in view
    if (visible && section && this.layout.name !== 'pre-paginated') {
      let offset = visible.offset()

      if (this.settings.direction === 'ltr') {
        this.scrollTo(offset.left, offset.top, true)
      } else {
        let width = visible.width()
        this.scrollTo(offset.left + width, offset.top, true)
      }

      if (target) {
        let offset = visible.locationOf(target)
        let width = visible.width()
        this.moveTo(offset, width)
      }

      displaying.resolve()
      return displayed
    }

    // Hide all current views
    this.clear()

    let forceRight = false
    if (
      this.layout.name === 'pre-paginated' &&
      this.layout.divisor === 2 &&
      section.properties.includes('page-spread-right')
    ) {
      forceRight = true
    }

    this.add(section, forceRight)
      .then(
        function (view) {
          // Move to correct place within the section, if needed
          if (target) {
            let offset = view.locationOf(target)
            let width = view.width()
            this.moveTo(offset, width)
          }
        }.bind(this),
        (err) => {
          displaying.reject(err)
        },
      )
      .then(
        function () {
          return this.handleNextPrePaginated(forceRight, section, this.add)
        }.bind(this),
      )
      .then(
        function () {
          this.views.show()

          displaying.resolve()
        }.bind(this),
      )
    // .then(function(){
    // 	return this.hooks.display.trigger(view);
    // }.bind(this))
    // .then(function(){
    // 	this.views.show();
    // }.bind(this));
    return displayed
  }

  afterDisplayed(view) {
    this.emit(EVENTS.MANAGERS.ADDED, view)
  }

  afterResized(view) {
    this.emit(EVENTS.MANAGERS.RESIZE, view.section)
  }

  moveTo(offset, width) {
    var distX = 0,
      distY = 0

    if (!this.isPaginated) {
      distY = offset.top
    } else {
      distX = Math.floor(offset.left / this.layout.delta) * this.layout.delta

      if (distX + this.layout.delta > this.container.scrollWidth) {
        distX = this.container.scrollWidth - this.layout.delta
      }

      distY = Math.floor(offset.top / this.layout.delta) * this.layout.delta

      if (distY + this.layout.delta > this.container.scrollHeight) {
        distY = this.container.scrollHeight - this.layout.delta
      }
    }
    if (this.settings.direction === 'rtl') {
      /***
				the `floor` function above (L343) is on positive values, so we should add one `layout.delta`
				to distX or use `Math.ceil` function, or multiply offset.left by -1
				before `Math.floor`
			*/
      distX = distX + this.layout.delta
      distX = distX - width
    }
    this.scrollTo(distX, distY, true)
  }

  add(section, forceRight) {
    var view = this.createView(section, forceRight)

    this.views.append(view)

    // view.on(EVENTS.VIEWS.SHOWN, this.afterDisplayed.bind(this));
    view.onDisplayed = this.afterDisplayed.bind(this)
    view.onResize = this.afterResized.bind(this)

    view.on(EVENTS.VIEWS.AXIS, (axis) => {
      this.updateAxis(axis)
    })

    view.on(EVENTS.VIEWS.WRITING_MODE, (mode) => {
      this.updateWritingMode(mode)
    })

    return view.display(this.request)
  }

  append(section, forceRight) {
    var view = this.createView(section, forceRight)
    this.views.append(view)

    view.onDisplayed = this.afterDisplayed.bind(this)
    view.onResize = this.afterResized.bind(this)

    view.on(EVENTS.VIEWS.AXIS, (axis) => {
      this.updateAxis(axis)
    })

    view.on(EVENTS.VIEWS.WRITING_MODE, (mode) => {
      this.updateWritingMode(mode)
    })

    return view.display(this.request)
  }

  prepend(section, forceRight) {
    var view = this.createView(section, forceRight)

    view.on(EVENTS.VIEWS.RESIZED, (bounds) => {
      this.counter(bounds)
    })

    this.views.prepend(view)

    view.onDisplayed = this.afterDisplayed.bind(this)
    view.onResize = this.afterResized.bind(this)

    view.on(EVENTS.VIEWS.AXIS, (axis) => {
      this.updateAxis(axis)
    })

    view.on(EVENTS.VIEWS.WRITING_MODE, (mode) => {
      this.updateWritingMode(mode)
    })

    return view.display(this.request)
  }

  counter(bounds) {
    if (this.settings.axis === 'vertical') {
      this.scrollBy(0, bounds.heightDelta, true)
    } else {
      this.scrollBy(bounds.widthDelta, 0, true)
    }
  }

  // resizeView(view) {
  //
  // 	if(this.settings.globalLayoutProperties.layout === "pre-paginated") {
  // 		view.lock("both", this.bounds.width, this.bounds.height);
  // 	} else {
  // 		view.lock("width", this.bounds.width, this.bounds.height);
  // 	}
  //
  // };

  next() {
    var next
    var left

    let dir = this.settings.direction

    if (!this.views.length) return

    if (
      this.isPaginated &&
      this.settings.axis === 'horizontal' &&
      (!dir || dir === 'ltr')
    ) {
      this.scrollLeft = this.container.scrollLeft

      left =
        this.container.scrollLeft +
        this.container.offsetWidth +
        this.layout.delta

      if (left <= this.container.scrollWidth) {
        this.scrollBy(this.layout.delta, 0, true)
      } else {
        next = this.views.last().section.next()
      }
    } else if (
      this.isPaginated &&
      this.settings.axis === 'horizontal' &&
      dir === 'rtl'
    ) {
      this.scrollLeft = this.container.scrollLeft

      if (this.settings.rtlScrollType === 'default') {
        left = this.container.scrollLeft

        if (left > 0) {
          this.scrollBy(this.layout.delta, 0, true)
        } else {
          next = this.views.last().section.next()
        }
      } else {
        left = this.container.scrollLeft + this.layout.delta * -1

        if (left > this.container.scrollWidth * -1) {
          this.scrollBy(this.layout.delta, 0, true)
        } else {
          next = this.views.last().section.next()
        }
      }
    } else if (this.isPaginated && this.settings.axis === 'vertical') {
      this.scrollTop = this.container.scrollTop

      let top = this.container.scrollTop + this.container.offsetHeight

      if (top < this.container.scrollHeight) {
        this.scrollBy(0, this.layout.height, true)
      } else {
        next = this.views.last().section.next()
      }
    } else {
      next = this.views.last().section.next()
    }

    if (next) {
      this.clear()
      // The new section may have a different writing-mode from the old section. Thus, we need to update layout.
      this.updateLayout()

      let forceRight = false
      if (
        this.layout.name === 'pre-paginated' &&
        this.layout.divisor === 2 &&
        next.properties.includes('page-spread-right')
      ) {
        forceRight = true
      }

      return this.append(next, forceRight)
        .then(
          function () {
            return this.handleNextPrePaginated(forceRight, next, this.append)
          }.bind(this),
          (err) => {
            return err
          },
        )
        .then(
          function () {
            // Reset position to start for scrolled-doc vertical-rl in default mode
            if (
              !this.isPaginated &&
              this.settings.axis === 'horizontal' &&
              this.settings.direction === 'rtl' &&
              this.settings.rtlScrollType === 'default'
            ) {
              this.scrollTo(this.container.scrollWidth, 0, true)
            }
            this.views.show()
          }.bind(this),
        )
    }
  }

  prev() {
    var prev
    var left
    let dir = this.settings.direction

    if (!this.views.length) return

    if (
      this.isPaginated &&
      this.settings.axis === 'horizontal' &&
      (!dir || dir === 'ltr')
    ) {
      this.scrollLeft = this.container.scrollLeft

      left = this.container.scrollLeft

      if (left > 0) {
        this.scrollBy(-this.layout.delta, 0, true)
      } else {
        prev = this.views.first().section.prev()
      }
    } else if (
      this.isPaginated &&
      this.settings.axis === 'horizontal' &&
      dir === 'rtl'
    ) {
      this.scrollLeft = this.container.scrollLeft

      if (this.settings.rtlScrollType === 'default') {
        left = this.container.scrollLeft + this.container.offsetWidth

        if (left < this.container.scrollWidth) {
          this.scrollBy(-this.layout.delta, 0, true)
        } else {
          prev = this.views.first().section.prev()
        }
      } else {
        left = this.container.scrollLeft

        if (left < 0) {
          this.scrollBy(-this.layout.delta, 0, true)
        } else {
          prev = this.views.first().section.prev()
        }
      }
    } else if (this.isPaginated && this.settings.axis === 'vertical') {
      this.scrollTop = this.container.scrollTop

      let top = this.container.scrollTop

      if (top > 0) {
        this.scrollBy(0, -this.layout.height, true)
      } else {
        prev = this.views.first().section.prev()
      }
    } else {
      prev = this.views.first().section.prev()
    }

    if (prev) {
      this.clear()
      // The new section may have a different writing-mode from the old section. Thus, we need to update layout.
      this.updateLayout()

      let forceRight = false
      if (
        this.layout.name === 'pre-paginated' &&
        this.layout.divisor === 2 &&
        typeof prev.prev() !== 'object'
      ) {
        forceRight = true
      }

      return this.prepend(prev, forceRight)
        .then(
          function () {
            var left
            if (
              this.layout.name === 'pre-paginated' &&
              this.layout.divisor > 1
            ) {
              left = prev.prev()
              if (left) {
                return this.prepend(left)
              }
            }
          }.bind(this),
          (err) => {
            return err
          },
        )
        .then(
          function () {
            if (this.isPaginated && this.settings.axis === 'horizontal') {
              if (this.settings.direction === 'rtl') {
                if (this.settings.rtlScrollType === 'default') {
                  this.scrollTo(0, 0, true)
                } else {
                  this.scrollTo(
                    this.container.scrollWidth * -1 + this.layout.delta,
                    0,
                    true,
                  )
                }
              } else {
                this.scrollTo(
                  this.container.scrollWidth - this.layout.delta,
                  0,
                  true,
                )
              }
            }
            this.views.show()
          }.bind(this),
        )
    }
  }

  current() {
    var visible = this.visible()
    if (visible.length) {
      // Current is the last visible view
      return visible[visible.length - 1]
    }
    return null
  }

  clear() {
    // this.q.clear();

    if (this.views) {
      this.views.hide()
      this.scrollTo(0, 0, true)
      this.views.clear()
    }
  }

  currentLocation() {
    this.updateLayout()
    if (this.isPaginated && this.settings.axis === 'horizontal') {
      this.location = this.paginatedLocation()
    } else {
      this.location = this.scrolledLocation()
    }
    return this.location
  }

  scrolledLocation() {
    let visible = this.visible()
    let container = this.container.getBoundingClientRect()
    let pageHeight =
      container.height < window.innerHeight
        ? container.height
        : window.innerHeight
    let pageWidth =
      container.width < window.innerWidth ? container.width : window.innerWidth
    let vertical = this.settings.axis === 'vertical'
    let rtl = this.settings.direction === 'rtl'

    let offset = 0
    let used = 0

    if (this.settings.fullsize) {
      offset = vertical ? window.scrollY : window.scrollX
    }

    let sections = visible.map((view) => {
      let { index, href } = view.section
      let position = view.position()
      let width = view.width()
      let height = view.height()

      let startPos
      let endPos
      let stopPos
      let totalPages

      if (vertical) {
        startPos = offset + container.top - position.top + used
        endPos = startPos + pageHeight - used
        totalPages = this.layout.count(height, pageHeight).pages
        stopPos = pageHeight
      } else {
        startPos = offset + container.left - position.left + used
        endPos = startPos + pageWidth - used
        totalPages = this.layout.count(width, pageWidth).pages
        stopPos = pageWidth
      }

      let currPage = Math.ceil(startPos / stopPos)
      let pages = []
      let endPage = Math.ceil(endPos / stopPos)

      // Reverse page counts for horizontal rtl
      if (this.settings.direction === 'rtl' && !vertical) {
        let tempStartPage = currPage
        currPage = totalPages - endPage
        endPage = totalPages - tempStartPage
      }

      pages = []
      for (var i = currPage; i <= endPage; i++) {
        let pg = i + 1
        pages.push(pg)
      }

      let mapping = this.mapping.page(
        view.contents,
        view.section.cfiBase,
        startPos,
        endPos,
      )

      return {
        index,
        href,
        pages,
        totalPages,
        mapping,
      }
    })

    return sections
  }

  paginatedLocation() {
    let visible = this.visible()
    let container = this.container.getBoundingClientRect()

    let left = 0
    let used = 0

    if (this.settings.fullsize) {
      left = window.scrollX
    }

    let sections = visible.map((view) => {
      let { index, href } = view.section
      let offset
      let position = view.position()
      let width = view.width()

      // Find mapping
      let start
      let end
      let pageWidth

      if (this.settings.direction === 'rtl') {
        offset = container.right - left
        pageWidth =
          Math.min(Math.abs(offset - position.left), this.layout.width) - used
        end = position.width - (position.right - offset) - used
        start = end - pageWidth
      } else {
        offset = container.left + left
        pageWidth = Math.min(position.right - offset, this.layout.width) - used
        start = offset - position.left + used
        end = start + pageWidth
      }

      used += pageWidth

      let mapping = this.mapping.page(
        view.contents,
        view.section.cfiBase,
        start,
        end,
      )

      let totalPages = this.layout.count(width).pages
      let startPage = Math.floor(start / this.layout.pageWidth)
      let pages = []
      let endPage = Math.floor(end / this.layout.pageWidth)

      // start page should not be negative
      if (startPage < 0) {
        startPage = 0
        endPage = endPage + 1
      }

      // Reverse page counts for rtl
      if (this.settings.direction === 'rtl') {
        let tempStartPage = startPage
        startPage = totalPages - endPage
        endPage = totalPages - tempStartPage
      }

      for (var i = startPage + 1; i <= endPage; i++) {
        let pg = i
        pages.push(pg)
      }

      return {
        index,
        href,
        pages,
        totalPages,
        mapping,
      }
    })

    return sections
  }

  isVisible(view, offsetPrev, offsetNext, _container) {
    var position = view.position()
    var container = _container || this.bounds()

    if (
      this.settings.axis === 'horizontal' &&
      position.right > container.left - offsetPrev &&
      position.left < container.right + offsetNext
    ) {
      return true
    } else if (
      this.settings.axis === 'vertical' &&
      position.bottom > container.top - offsetPrev &&
      position.top < container.bottom + offsetNext
    ) {
      return true
    }

    return false
  }

  visible() {
    var container = this.bounds()
    var views = this.views.displayed()
    var viewsLength = views.length
    var visible = []
    var isVisible
    var view

    for (var i = 0; i < viewsLength; i++) {
      view = views[i]
      isVisible = this.isVisible(view, 0, 0, container)

      if (isVisible === true) {
        visible.push(view)
      }
    }
    return visible
  }

  scrollBy(x, y, silent) {
    let dir = this.settings.direction === 'rtl' ? -1 : 1

    if (silent) {
      this.ignore = true
    }

    if (!this.settings.fullsize) {
      if (x) this.container.scrollLeft += x * dir
      if (y) this.container.scrollTop += y
    } else {
      window.scrollBy(x * dir, y * dir)
    }
    this.scrolled = true
  }

  scrollTo(x, y, silent) {
    if (silent) {
      this.ignore = true
    }

    if (!this.settings.fullsize) {
      this.container.scrollLeft = x
      this.container.scrollTop = y
    } else {
      window.scrollTo(x, y)
    }
    this.scrolled = true
  }

  onScroll() {
    let scrollTop
    let scrollLeft

    if (!this.settings.fullsize) {
      scrollTop = this.container.scrollTop
      scrollLeft = this.container.scrollLeft
    } else {
      scrollTop = window.scrollY
      scrollLeft = window.scrollX
    }

    this.scrollTop = scrollTop
    this.scrollLeft = scrollLeft

    if (!this.ignore) {
      this.emit(EVENTS.MANAGERS.SCROLL, {
        top: scrollTop,
        left: scrollLeft,
      })

      clearTimeout(this.afterScrolled)
      this.afterScrolled = setTimeout(
        function () {
          this.emit(EVENTS.MANAGERS.SCROLLED, {
            top: this.scrollTop,
            left: this.scrollLeft,
          })
        }.bind(this),
        20,
      )
    } else {
      this.ignore = false
    }
  }

  bounds() {
    var bounds

    bounds = this.stage.bounds()

    return bounds
  }

  applyLayout(layout) {
    this.layout = layout
    this.updateLayout()
    if (
      this.views &&
      this.views.length > 0 &&
      this.layout.name === 'pre-paginated'
    ) {
      this.display(this.views.first().section)
    }
    // this.manager.layout(this.layout.format);
  }

  updateLayout() {
    if (!this.stage) {
      return
    }

    this._stageSize = this.stage.size()

    if (!this.isPaginated) {
      this.layout.calculate(this._stageSize.width, this._stageSize.height)
    } else {
      this.layout.calculate(
        this._stageSize.width,
        this._stageSize.height,
        this.settings.gap,
      )

      // Set the look ahead offset for what is visible
      this.settings.offset = this.layout.delta / this.layout.divisor

      // this.stage.addStyleRules("iframe", [{"margin-right" : this.layout.gap + "px"}]);
    }

    // Set the dimensions for views
    this.viewSettings.width = this.layout.width
    this.viewSettings.height = this.layout.height

    this.setLayout(this.layout)
  }

  setLayout(layout) {
    this.viewSettings.layout = layout

    this.mapping = new Mapping(
      layout.props,
      this.settings.direction,
      this.settings.axis,
    )

    if (this.views) {
      this.views.forEach(function (view) {
        if (view) {
          view.setLayout(layout)
        }
      })
    }
  }

  updateWritingMode(mode) {
    this.writingMode = mode
  }

  updateAxis(axis, forceUpdate) {
    if (!forceUpdate && axis === this.settings.axis) {
      return
    }

    this.settings.axis = axis

    this.stage && this.stage.axis(axis)

    this.viewSettings.axis = axis

    if (this.mapping) {
      this.mapping = new Mapping(
        this.layout.props,
        this.settings.direction,
        this.settings.axis,
      )
    }

    if (this.layout) {
      if (axis === 'vertical') {
        this.layout.spread('none')
      } else {
        this.layout.spread(this.layout.settings.spread)
      }
    }
  }

  updateFlow(flow, defaultScrolledOverflow = 'auto') {
    let isPaginated = flow === 'paginated' || flow === 'auto'

    this.isPaginated = isPaginated

    if (
      flow === 'scrolled-doc' ||
      flow === 'scrolled-continuous' ||
      flow === 'scrolled'
    ) {
      this.updateAxis('vertical')
    } else {
      this.updateAxis('horizontal')
    }

    this.viewSettings.flow = flow

    if (!this.settings.overflow) {
      this.overflow = isPaginated ? 'hidden' : defaultScrolledOverflow
    } else {
      this.overflow = this.settings.overflow
    }

    this.stage && this.stage.overflow(this.overflow)

    this.updateLayout()
  }

  getContents() {
    var contents = []
    if (!this.views) {
      return contents
    }
    this.views.forEach(function (view) {
      const viewContents = view && view.contents
      if (viewContents) {
        contents.push(viewContents)
      }
    })
    return contents
  }

  direction(dir = 'ltr') {
    this.settings.direction = dir

    this.stage && this.stage.direction(dir)

    this.viewSettings.direction = dir

    this.updateLayout()
  }

  isRendered() {
    return this.rendered
  }
}

//-- Enable binding events to Manager
EventEmitter(DefaultViewManager.prototype)

export default DefaultViewManager

</code>

packages\epubjs\src\managers\helpers\snap.js:
<code>
import EventEmitter from 'event-emitter'

import { EVENTS, DOM_EVENTS } from '../../utils/constants'
import {
  extend,
  defer,
  requestAnimationFrame,
  prefixed,
} from '../../utils/core'

// easing equations from https://github.com/danro/easing-js/blob/master/easing.js
const PI_D2 = Math.PI / 2
const EASING_EQUATIONS = {
  easeOutSine: function (pos) {
    return Math.sin(pos * PI_D2)
  },
  easeInOutSine: function (pos) {
    return -0.5 * (Math.cos(Math.PI * pos) - 1)
  },
  easeInOutQuint: function (pos) {
    if ((pos /= 0.5) < 1) {
      return 0.5 * Math.pow(pos, 5)
    }
    return 0.5 * (Math.pow(pos - 2, 5) + 2)
  },
  easeInCubic: function (pos) {
    return Math.pow(pos, 3)
  },
}

class Snap {
  constructor(manager, options) {
    this.settings = extend(
      {
        duration: 80,
        minVelocity: 0.2,
        minDistance: 10,
        easing: EASING_EQUATIONS['easeInCubic'],
      },
      options || {},
    )

    this.supportsTouch = this.supportsTouch()

    if (this.supportsTouch) {
      this.setup(manager)
    }
  }

  setup(manager) {
    this.manager = manager

    this.layout = this.manager.layout

    this.fullsize = this.manager.settings.fullsize
    if (this.fullsize) {
      this.element = this.manager.stage.element
      this.scroller = window
      this.disableScroll()
    } else {
      this.element = this.manager.stage.container
      this.scroller = this.element
      this.element.style['WebkitOverflowScrolling'] = 'touch'
    }

    // this.overflow = this.manager.overflow;

    // set lookahead offset to page width
    this.manager.settings.offset = this.layout.width
    this.manager.settings.afterScrolledTimeout = this.settings.duration * 2

    this.isVertical = this.manager.settings.axis === 'vertical'

    // disable snapping if not paginated or axis in not horizontal
    if (!this.manager.isPaginated || this.isVertical) {
      return
    }

    this.touchCanceler = false
    this.resizeCanceler = false
    this.snapping = false

    this.scrollLeft
    this.scrollTop

    this.startTouchX = undefined
    this.startTouchY = undefined
    this.startTime = undefined
    this.endTouchX = undefined
    this.endTouchY = undefined
    this.endTime = undefined

    this.addListeners()
  }

  supportsTouch() {
    if (
      'ontouchstart' in window ||
      (window.DocumentTouch && document instanceof DocumentTouch)
    ) {
      return true
    }

    return false
  }

  disableScroll() {
    this.element.style.overflow = 'hidden'
  }

  enableScroll() {
    this.element.style.overflow = ''
  }

  addListeners() {
    this._onResize = this.onResize.bind(this)
    window.addEventListener('resize', this._onResize)

    this._onScroll = this.onScroll.bind(this)
    this.scroller.addEventListener('scroll', this._onScroll)

    this._onTouchStart = this.onTouchStart.bind(this)
    this.scroller.addEventListener('touchstart', this._onTouchStart, {
      passive: true,
    })
    this.on('touchstart', this._onTouchStart)

    this._onTouchMove = this.onTouchMove.bind(this)
    this.scroller.addEventListener('touchmove', this._onTouchMove, {
      passive: true,
    })
    this.on('touchmove', this._onTouchMove)

    this._onTouchEnd = this.onTouchEnd.bind(this)
    this.scroller.addEventListener('touchend', this._onTouchEnd, {
      passive: true,
    })
    this.on('touchend', this._onTouchEnd)

    this._afterDisplayed = this.afterDisplayed.bind(this)
    this.manager.on(EVENTS.MANAGERS.ADDED, this._afterDisplayed)
  }

  removeListeners() {
    window.removeEventListener('resize', this._onResize)
    this._onResize = undefined

    this.scroller.removeEventListener('scroll', this._onScroll)
    this._onScroll = undefined

    this.scroller.removeEventListener('touchstart', this._onTouchStart, {
      passive: true,
    })
    this.off('touchstart', this._onTouchStart)
    this._onTouchStart = undefined

    this.scroller.removeEventListener('touchmove', this._onTouchMove, {
      passive: true,
    })
    this.off('touchmove', this._onTouchMove)
    this._onTouchMove = undefined

    this.scroller.removeEventListener('touchend', this._onTouchEnd, {
      passive: true,
    })
    this.off('touchend', this._onTouchEnd)
    this._onTouchEnd = undefined

    this.manager.off(EVENTS.MANAGERS.ADDED, this._afterDisplayed)
    this._afterDisplayed = undefined
  }

  afterDisplayed(view) {
    let contents = view.contents
    ;['touchstart', 'touchmove', 'touchend'].forEach((e) => {
      contents.on(e, (ev) => this.triggerViewEvent(ev, contents))
    })
  }

  triggerViewEvent(e, contents) {
    this.emit(e.type, e, contents)
  }

  onScroll(e) {
    this.scrollLeft = this.fullsize ? window.scrollX : this.scroller.scrollLeft
    this.scrollTop = this.fullsize ? window.scrollY : this.scroller.scrollTop
  }

  onResize(e) {
    this.resizeCanceler = true
  }

  onTouchStart(e) {
    let { screenX, screenY } = e.touches[0]

    if (this.fullsize) {
      this.enableScroll()
    }

    this.touchCanceler = true

    if (!this.startTouchX) {
      this.startTouchX = screenX
      this.startTouchY = screenY
      this.startTime = this.now()
    }

    this.endTouchX = screenX
    this.endTouchY = screenY
    this.endTime = this.now()
  }

  onTouchMove(e) {
    let { screenX, screenY } = e.touches[0]
    let deltaY = Math.abs(screenY - this.endTouchY)

    this.touchCanceler = true

    if (!this.fullsize && deltaY < 10) {
      this.element.scrollLeft -= screenX - this.endTouchX
    }

    this.endTouchX = screenX
    this.endTouchY = screenY
    this.endTime = this.now()
  }

  onTouchEnd(e) {
    if (this.fullsize) {
      this.disableScroll()
    }

    this.touchCanceler = false

    let swipped = this.wasSwiped()

    if (swipped !== 0) {
      this.snap(swipped)
    } else {
      this.snap()
    }

    this.startTouchX = undefined
    this.startTouchY = undefined
    this.startTime = undefined
    this.endTouchX = undefined
    this.endTouchY = undefined
    this.endTime = undefined
  }

  wasSwiped() {
    let snapWidth = this.layout.pageWidth * this.layout.divisor
    let distance = this.endTouchX - this.startTouchX
    let absolute = Math.abs(distance)
    let time = this.endTime - this.startTime
    let velocity = distance / time
    let minVelocity = this.settings.minVelocity

    if (absolute <= this.settings.minDistance || absolute >= snapWidth) {
      return 0
    }

    if (velocity > minVelocity) {
      // previous
      return -1
    } else if (velocity < -minVelocity) {
      // next
      return 1
    }
  }

  needsSnap() {
    let left = this.scrollLeft
    let snapWidth = this.layout.pageWidth * this.layout.divisor
    return left % snapWidth !== 0
  }

  snap(howMany = 0) {
    let left = this.scrollLeft
    let snapWidth = this.layout.pageWidth * this.layout.divisor
    let snapTo = Math.round(left / snapWidth) * snapWidth

    if (howMany) {
      snapTo += howMany * snapWidth
    }

    return this.smoothScrollTo(snapTo)
  }

  smoothScrollTo(destination) {
    const deferred = new defer()
    const start = this.scrollLeft
    const startTime = this.now()

    const duration = this.settings.duration
    const easing = this.settings.easing

    this.snapping = true

    // add animation loop
    function tick() {
      const now = this.now()
      const time = Math.min(1, (now - startTime) / duration)
      const timeFunction = easing(time)

      if (this.touchCanceler || this.resizeCanceler) {
        this.resizeCanceler = false
        this.snapping = false
        deferred.resolve()
        return
      }

      if (time < 1) {
        window.requestAnimationFrame(tick.bind(this))
        this.scrollTo(start + (destination - start) * time, 0)
      } else {
        this.scrollTo(destination, 0)
        this.snapping = false
        deferred.resolve()
      }
    }

    tick.call(this)

    return deferred.promise
  }

  scrollTo(left = 0, top = 0) {
    if (this.fullsize) {
      window.scroll(left, top)
    } else {
      this.scroller.scrollLeft = left
      this.scroller.scrollTop = top
    }
  }

  now() {
    return 'now' in window.performance
      ? performance.now()
      : new Date().getTime()
  }

  destroy() {
    if (!this.scroller) {
      return
    }

    if (this.fullsize) {
      this.enableScroll()
    }

    this.removeListeners()

    this.scroller = undefined
  }
}

EventEmitter(Snap.prototype)

export default Snap

</code>

packages\epubjs\src\managers\helpers\stage.js:
<code>
import throttle from 'lodash/throttle'

import {
  uuid,
  isNumber,
  isElement,
  windowBounds,
  extend,
} from '../../utils/core'

class Stage {
  constructor(_options) {
    this.settings = _options || {}
    this.id = 'epubjs-container-' + uuid()

    this.container = this.create(this.settings)

    if (this.settings.hidden) {
      this.wrapper = this.wrap(this.container)
    }
  }

  /*
   * Creates an element to render to.
   * Resizes to passed width and height or to the elements size
   */
  create(options) {
    let height = options.height // !== false ? options.height : "100%";
    let width = options.width // !== false ? options.width : "100%";
    let overflow = options.overflow || false
    let axis = options.axis || 'vertical'
    let direction = options.direction

    extend(this.settings, options)

    if (options.height && isNumber(options.height)) {
      height = options.height + 'px'
    }

    if (options.width && isNumber(options.width)) {
      width = options.width + 'px'
    }

    // Create new container element
    let container = document.createElement('div')

    container.id = this.id
    container.classList.add('epub-container')

    // Style Element
    // container.style.fontSize = "0";
    container.style.wordSpacing = '0'
    container.style.lineHeight = '0'
    container.style.verticalAlign = 'top'
    container.style.position = 'relative'

    if (axis === 'horizontal') {
      // container.style.whiteSpace = "nowrap";
      container.style.display = 'flex'
      container.style.flexDirection = 'row'
      container.style.flexWrap = 'nowrap'
    }

    if (width) {
      container.style.width = width
    }

    if (height) {
      container.style.height = height
    }

    if (overflow) {
      if (overflow === 'scroll' && axis === 'vertical') {
        container.style['overflow-y'] = overflow
        container.style['overflow-x'] = 'hidden'
      } else if (overflow === 'scroll' && axis === 'horizontal') {
        container.style['overflow-y'] = 'hidden'
        container.style['overflow-x'] = overflow
      } else {
        container.style['overflow'] = overflow
      }
    }

    if (direction) {
      container.dir = direction
      container.style['direction'] = direction
    }

    if (direction && this.settings.fullsize) {
      document.body.style['direction'] = direction
    }

    return container
  }

  wrap(container) {
    var wrapper = document.createElement('div')

    wrapper.style.visibility = 'hidden'
    wrapper.style.overflow = 'hidden'
    wrapper.style.width = '0'
    wrapper.style.height = '0'

    wrapper.appendChild(container)
    return wrapper
  }

  getElement(_element) {
    var element

    if (isElement(_element)) {
      element = _element
    } else if (typeof _element === 'string') {
      element = document.getElementById(_element)
    }

    if (!element) {
      throw new Error('Not an Element')
    }

    return element
  }

  attachTo(what) {
    var element = this.getElement(what)
    var base

    if (!element) {
      return
    }

    if (this.settings.hidden) {
      base = this.wrapper
    } else {
      base = this.container
    }

    element.appendChild(base)

    this.element = element

    return element
  }

  getContainer() {
    return this.container
  }

  onResize(func) {
    // Only listen to window for resize event if width and height are not fixed.
    // This applies if it is set to a percent or auto.
    if (!isNumber(this.settings.width) || !isNumber(this.settings.height)) {
      this.resizeFunc = throttle(func, 50)
      window.addEventListener('resize', this.resizeFunc, false)
    }
  }

  onOrientationChange(func) {
    this.orientationChangeFunc = func
    window.addEventListener(
      'orientationchange',
      this.orientationChangeFunc,
      false,
    )
  }

  size(width, height) {
    var bounds
    let _width = width || this.settings.width
    let _height = height || this.settings.height

    // If width or height are set to false, inherit them from containing element
    if (width === null) {
      bounds = this.element.getBoundingClientRect()

      if (bounds.width) {
        width = Math.floor(bounds.width)
        this.container.style.width = width + 'px'
      }
    } else {
      if (isNumber(width)) {
        this.container.style.width = width + 'px'
      } else {
        this.container.style.width = width
      }
    }

    if (height === null) {
      bounds = bounds || this.element.getBoundingClientRect()

      if (bounds.height) {
        height = bounds.height
        this.container.style.height = height + 'px'
      }
    } else {
      if (isNumber(height)) {
        this.container.style.height = height + 'px'
      } else {
        this.container.style.height = height
      }
    }

    if (!isNumber(width)) {
      width = this.container.clientWidth
    }

    if (!isNumber(height)) {
      height = this.container.clientHeight
    }

    this.containerStyles = window.getComputedStyle(this.container)

    this.containerPadding = {
      left: parseFloat(this.containerStyles['padding-left']) || 0,
      right: parseFloat(this.containerStyles['padding-right']) || 0,
      top: parseFloat(this.containerStyles['padding-top']) || 0,
      bottom: parseFloat(this.containerStyles['padding-bottom']) || 0,
    }

    // Bounds not set, get them from window
    let _windowBounds = windowBounds()
    let bodyStyles = window.getComputedStyle(document.body)
    let bodyPadding = {
      left: parseFloat(bodyStyles['padding-left']) || 0,
      right: parseFloat(bodyStyles['padding-right']) || 0,
      top: parseFloat(bodyStyles['padding-top']) || 0,
      bottom: parseFloat(bodyStyles['padding-bottom']) || 0,
    }

    if (!_width) {
      width = _windowBounds.width - bodyPadding.left - bodyPadding.right
    }

    if ((this.settings.fullsize && !_height) || !_height) {
      height = _windowBounds.height - bodyPadding.top - bodyPadding.bottom
    }

    return {
      width: width - this.containerPadding.left - this.containerPadding.right,
      height: height - this.containerPadding.top - this.containerPadding.bottom,
    }
  }

  bounds() {
    let box
    if (this.container.style.overflow !== 'visible') {
      box = this.container && this.container.getBoundingClientRect()
    }

    if (!box || !box.width || !box.height) {
      return windowBounds()
    } else {
      return box
    }
  }

  getSheet() {
    var style = document.createElement('style')

    // WebKit hack --> https://davidwalsh.name/add-rules-stylesheets
    style.appendChild(document.createTextNode(''))

    document.head.appendChild(style)

    return style.sheet
  }

  addStyleRules(selector, rulesArray) {
    var scope = '#' + this.id + ' '
    var rules = ''

    if (!this.sheet) {
      this.sheet = this.getSheet()
    }

    rulesArray.forEach(function (set) {
      for (var prop in set) {
        if (set.hasOwnProperty(prop)) {
          rules += prop + ':' + set[prop] + ';'
        }
      }
    })

    this.sheet.insertRule(scope + selector + ' {' + rules + '}', 0)
  }

  axis(axis) {
    if (axis === 'horizontal') {
      this.container.style.display = 'flex'
      this.container.style.flexDirection = 'row'
      this.container.style.flexWrap = 'nowrap'
    } else {
      this.container.style.display = 'block'
    }
    this.settings.axis = axis
  }

  // orientation(orientation) {
  // 	if (orientation === "landscape") {
  //
  // 	} else {
  //
  // 	}
  //
  // 	this.orientation = orientation;
  // }

  direction(dir) {
    if (this.container) {
      this.container.dir = dir
      this.container.style['direction'] = dir
    }

    if (this.settings.fullsize) {
      document.body.style['direction'] = dir
    }
    this.settings.dir = dir
  }

  overflow(overflow) {
    if (this.container) {
      if (overflow === 'scroll' && this.settings.axis === 'vertical') {
        this.container.style['overflow-y'] = overflow
        this.container.style['overflow-x'] = 'hidden'
      } else if (overflow === 'scroll' && this.settings.axis === 'horizontal') {
        this.container.style['overflow-y'] = 'hidden'
        this.container.style['overflow-x'] = overflow
      } else {
        this.container.style['overflow'] = overflow
      }
    }
    this.settings.overflow = overflow
  }

  destroy() {
    var base

    if (this.element) {
      if (this.settings.hidden) {
        base = this.wrapper
      } else {
        base = this.container
      }

      if (this.element.contains(this.container)) {
        this.element.removeChild(this.container)
      }

      window.removeEventListener('resize', this.resizeFunc)
      window.removeEventListener(
        'orientationChange',
        this.orientationChangeFunc,
      )
    }
  }
}

export default Stage

</code>

packages\epubjs\src\managers\helpers\views.js:
<code>
class Views {
  constructor(container) {
    this.container = container
    this._views = []
    this.length = 0
    this.hidden = false
  }

  all() {
    return this._views
  }

  first() {
    return this._views[0]
  }

  last() {
    return this._views[this._views.length - 1]
  }

  indexOf(view) {
    return this._views.indexOf(view)
  }

  slice() {
    return this._views.slice.apply(this._views, arguments)
  }

  get(i) {
    return this._views[i]
  }

  append(view) {
    this._views.push(view)
    if (this.container) {
      this.container.appendChild(view.element)
    }
    this.length++
    return view
  }

  prepend(view) {
    this._views.unshift(view)
    if (this.container) {
      this.container.insertBefore(view.element, this.container.firstChild)
    }
    this.length++
    return view
  }

  insert(view, index) {
    this._views.splice(index, 0, view)

    if (this.container) {
      if (index < this.container.children.length) {
        this.container.insertBefore(
          view.element,
          this.container.children[index],
        )
      } else {
        this.container.appendChild(view.element)
      }
    }

    this.length++
    return view
  }

  remove(view) {
    var index = this._views.indexOf(view)

    if (index > -1) {
      this._views.splice(index, 1)
    }

    this.destroy(view)

    this.length--
  }

  destroy(view) {
    if (view.displayed) {
      view.destroy()
    }

    if (this.container) {
      this.container.removeChild(view.element)
    }
    view = null
  }

  // Iterators

  forEach() {
    return this._views.forEach.apply(this._views, arguments)
  }

  clear() {
    // Remove all views
    var view
    var len = this.length

    if (!this.length) return

    for (var i = 0; i < len; i++) {
      view = this._views[i]
      this.destroy(view)
    }

    this._views = []
    this.length = 0
  }

  find(section) {
    var view
    var len = this.length

    for (var i = 0; i < len; i++) {
      view = this._views[i]
      if (view.displayed && view.section.index == section.index) {
        return view
      }
    }
  }

  displayed() {
    var displayed = []
    var view
    var len = this.length

    for (var i = 0; i < len; i++) {
      view = this._views[i]
      if (view.displayed) {
        displayed.push(view)
      }
    }
    return displayed
  }

  show() {
    var view
    var len = this.length

    for (var i = 0; i < len; i++) {
      view = this._views[i]
      if (view.displayed) {
        view.show()
      }
    }
    this.hidden = false
  }

  hide() {
    var view
    var len = this.length

    for (var i = 0; i < len; i++) {
      view = this._views[i]
      if (view.displayed) {
        view.hide()
      }
    }
    this.hidden = true
  }
}

export default Views

</code>

packages\epubjs\src\managers\views\iframe.js:
<code>
import EventEmitter from 'event-emitter'
import { Pane, Highlight, Underline } from 'marks-pane'

import Contents from '../../contents'
import EpubCFI from '../../epubcfi'
import { EVENTS } from '../../utils/constants'
import {
  extend,
  borders,
  uuid,
  isNumber,
  bounds,
  defer,
  createBlobUrl,
  revokeBlobUrl,
} from '../../utils/core'

class IframeView {
  constructor(section, options) {
    this.settings = extend(
      {
        ignoreClass: '',
        axis: undefined, //options.layout && options.layout.props.flow === "scrolled" ? "vertical" : "horizontal",
        direction: undefined,
        width: 0,
        height: 0,
        layout: undefined,
        globalLayoutProperties: {},
        method: undefined,
        forceRight: false,
        allowScriptedContent: false,
        allowPopups: false,
      },
      options || {},
    )

    this.id = 'epubjs-view-' + uuid()
    this.section = section
    this.index = section.index

    this.element = this.container(this.settings.axis)

    this.added = false
    this.displayed = false
    this.rendered = false

    // this.width  = this.settings.width;
    // this.height = this.settings.height;

    this.fixedWidth = 0
    this.fixedHeight = 0

    // Blank Cfi for Parsing
    this.epubcfi = new EpubCFI()

    this.layout = this.settings.layout
    // Dom events to listen for
    // this.listenedEvents = ["keydown", "keyup", "keypressed", "mouseup", "mousedown", "click", "touchend", "touchstart"];

    this.pane = undefined
    this.highlights = {}
    this.underlines = {}
    this.marks = {}
  }

  container(axis) {
    var element = document.createElement('div')

    element.classList.add('epub-view')

    // this.element.style.minHeight = "100px";
    element.style.height = '0px'
    element.style.width = '0px'
    element.style.overflow = 'hidden'
    element.style.position = 'relative'
    element.style.display = 'block'

    if (axis && axis == 'horizontal') {
      element.style.flex = 'none'
    } else {
      element.style.flex = 'initial'
    }

    return element
  }

  create() {
    if (this.iframe) {
      return this.iframe
    }

    if (!this.element) {
      this.element = this.createContainer()
    }

    this.iframe = document.createElement('iframe')
    this.iframe.id = this.id
    this.iframe.scrolling = 'no' // Might need to be removed: breaks ios width calculations
    this.iframe.style.overflow = 'hidden'
    this.iframe.seamless = 'seamless'
    // Back up if seamless isn't supported
    this.iframe.style.border = 'none'

    // sandbox
    this.iframe.sandbox = 'allow-same-origin'
    if (this.settings.allowScriptedContent) {
      this.iframe.sandbox += ' allow-scripts'
    }
    if (this.settings.allowPopups) {
      this.iframe.sandbox += ' allow-popups'
    }

    this.iframe.setAttribute('enable-annotation', 'true')

    this.resizing = true

    // this.iframe.style.display = "none";
    this.element.style.visibility = 'hidden'
    this.iframe.style.visibility = 'hidden'

    this.iframe.style.width = '0'
    this.iframe.style.height = '0'
    this._width = 0
    this._height = 0

    this.element.setAttribute('ref', this.index)

    this.added = true

    this.elementBounds = bounds(this.element)

    // if(width || height){
    //   this.resize(width, height);
    // } else if(this.width && this.height){
    //   this.resize(this.width, this.height);
    // } else {
    //   this.iframeBounds = bounds(this.iframe);
    // }

    if ('srcdoc' in this.iframe) {
      this.supportsSrcdoc = true
    } else {
      this.supportsSrcdoc = false
    }

    if (!this.settings.method) {
      this.settings.method = this.supportsSrcdoc ? 'srcdoc' : 'write'
    }

    return this.iframe
  }

  render(request, show) {
    // view.onLayout = this.layout.format.bind(this.layout);
    this.create()

    // Fit to size of the container, apply padding
    this.size()

    if (!this.sectionRender) {
      this.sectionRender = this.section.render(request)
    }

    // Render Chain
    return this.sectionRender
      .then(
        function (contents) {
          return this.load(contents)
        }.bind(this),
      )
      .then(
        function () {
          // find and report the writingMode axis
          let writingMode = this.contents.writingMode()

          // Set the axis based on the flow and writing mode
          let axis
          if (this.settings.flow === 'scrolled') {
            axis =
              writingMode.indexOf('vertical') === 0 ? 'horizontal' : 'vertical'
          } else {
            axis =
              writingMode.indexOf('vertical') === 0 ? 'vertical' : 'horizontal'
          }

          if (
            writingMode.indexOf('vertical') === 0 &&
            this.settings.flow === 'paginated'
          ) {
            this.layout.delta = this.layout.height
          }

          this.setAxis(axis)
          this.emit(EVENTS.VIEWS.AXIS, axis)

          this.setWritingMode(writingMode)
          this.emit(EVENTS.VIEWS.WRITING_MODE, writingMode)

          // apply the layout function to the contents
          this.layout.format(this.contents, this.section, this.axis)

          // Listen for events that require an expansion of the iframe
          this.addListeners()

          return new Promise((resolve, reject) => {
            // Expand the iframe to the full size of the content
            this.expand()

            if (this.settings.forceRight) {
              this.element.style.marginLeft = this.width() + 'px'
            }
            resolve()
          })
        }.bind(this),
        function (e) {
          this.emit(EVENTS.VIEWS.LOAD_ERROR, e)
          return new Promise((resolve, reject) => {
            reject(e)
          })
        }.bind(this),
      )
      .then(
        function () {
          this.emit(EVENTS.VIEWS.RENDERED, this.section)
        }.bind(this),
      )
  }

  reset() {
    if (this.iframe) {
      this.iframe.style.width = '0'
      this.iframe.style.height = '0'
      this._width = 0
      this._height = 0
      this._textWidth = undefined
      this._contentWidth = undefined
      this._textHeight = undefined
      this._contentHeight = undefined
    }
    this._needsReframe = true
  }

  // Determine locks base on settings
  size(_width, _height) {
    var width = _width || this.settings.width
    var height = _height || this.settings.height

    if (this.layout.name === 'pre-paginated') {
      this.lock('both', width, height)
    } else if (this.settings.axis === 'horizontal') {
      this.lock('height', width, height)
    } else {
      this.lock('width', width, height)
    }

    this.settings.width = width
    this.settings.height = height
  }

  // Lock an axis to element dimensions, taking borders into account
  lock(what, width, height) {
    var elBorders = borders(this.element)
    var iframeBorders

    if (this.iframe) {
      iframeBorders = borders(this.iframe)
    } else {
      iframeBorders = { width: 0, height: 0 }
    }

    if (what == 'width' && isNumber(width)) {
      this.lockedWidth = width - elBorders.width - iframeBorders.width
      // this.resize(this.lockedWidth, width); //  width keeps ratio correct
    }

    if (what == 'height' && isNumber(height)) {
      this.lockedHeight = height - elBorders.height - iframeBorders.height
      // this.resize(width, this.lockedHeight);
    }

    if (what === 'both' && isNumber(width) && isNumber(height)) {
      this.lockedWidth = width - elBorders.width - iframeBorders.width
      this.lockedHeight = height - elBorders.height - iframeBorders.height
      // this.resize(this.lockedWidth, this.lockedHeight);
    }

    if (this.displayed && this.iframe) {
      // this.contents.layout();
      this.expand()
    }
  }

  // Resize a single axis based on content dimensions
  expand(force) {
    var width = this.lockedWidth
    var height = this.lockedHeight
    var columns

    var textWidth, textHeight

    if (!this.iframe || this._expanding) return

    this._expanding = true

    if (this.layout.name === 'pre-paginated') {
      width = this.layout.columnWidth
      height = this.layout.height
    }
    // Expand Horizontally
    else if (this.settings.axis === 'horizontal') {
      // Get the width of the text
      width = this.contents.textWidth()

      if (width % this.layout.pageWidth > 0) {
        width = Math.ceil(width / this.layout.pageWidth) * this.layout.pageWidth
      }

      if (this.settings.forceEvenPages) {
        columns = width / this.layout.pageWidth
        if (
          this.layout.divisor > 1 &&
          this.layout.name === 'reflowable' &&
          columns % 2 > 0
        ) {
          // add a blank page
          width += this.layout.pageWidth
        }
      }
    } // Expand Vertically
    else if (this.settings.axis === 'vertical') {
      height = this.contents.textHeight()
      if (
        this.settings.flow === 'paginated' &&
        height % this.layout.height > 0
      ) {
        height = Math.ceil(height / this.layout.height) * this.layout.height
      }
    }

    // Only Resize if dimensions have changed or
    // if Frame is still hidden, so needs reframing
    if (this._needsReframe || width != this._width || height != this._height) {
      this.reframe(width, height)
    }

    this._expanding = false
  }

  reframe(width, height) {
    var size

    if (isNumber(width)) {
      this.element.style.width = width + 'px'
      this.iframe.style.width = width + 'px'
      this._width = width
    }

    if (isNumber(height)) {
      this.element.style.height = height + 'px'
      this.iframe.style.height = height + 'px'
      this._height = height
    }

    let widthDelta = this.prevBounds ? width - this.prevBounds.width : width
    let heightDelta = this.prevBounds ? height - this.prevBounds.height : height

    size = {
      width: width,
      height: height,
      widthDelta: widthDelta,
      heightDelta: heightDelta,
    }

    this.pane && this.pane.render()

    requestAnimationFrame(() => {
      let mark
      for (let m in this.marks) {
        if (this.marks.hasOwnProperty(m)) {
          mark = this.marks[m]
          this.placeMark(mark.element, mark.range)
        }
      }
    })

    this.onResize(this, size)

    this.emit(EVENTS.VIEWS.RESIZED, size)

    this.prevBounds = size

    this.elementBounds = bounds(this.element)
  }

  load(contents) {
    var loading = new defer()
    var loaded = loading.promise

    if (!this.iframe) {
      loading.reject(new Error('No Iframe Available'))
      return loaded
    }

    this.iframe.onload = function (event) {
      this.onLoad(event, loading)
    }.bind(this)

    if (this.settings.method === 'blobUrl') {
      this.blobUrl = createBlobUrl(contents, 'application/xhtml+xml')
      this.iframe.src = this.blobUrl
      this.element.appendChild(this.iframe)
    } else if (this.settings.method === 'srcdoc') {
      this.iframe.srcdoc = contents
      this.element.appendChild(this.iframe)
    } else {
      this.element.appendChild(this.iframe)

      this.document = this.iframe.contentDocument

      if (!this.document) {
        loading.reject(new Error('No Document Available'))
        return loaded
      }

      this.iframe.contentDocument.open()
      // For Cordova windows platform
      if (window.MSApp && MSApp.execUnsafeLocalFunction) {
        var outerThis = this
        MSApp.execUnsafeLocalFunction(function () {
          outerThis.iframe.contentDocument.write(contents)
        })
      } else {
        this.iframe.contentDocument.write(contents)
      }
      this.iframe.contentDocument.close()
    }

    return loaded
  }

  onLoad(event, promise) {
    this.window = this.iframe.contentWindow
    this.document = this.iframe.contentDocument

    this.contents = new Contents(
      this.document,
      this.document.body,
      this.section.cfiBase,
      this.section.index,
    )

    this.rendering = false

    var link = this.document.querySelector("link[rel='canonical']")
    if (link) {
      link.setAttribute('href', this.section.canonical)
    } else {
      link = this.document.createElement('link')
      link.setAttribute('rel', 'canonical')
      link.setAttribute('href', this.section.canonical)
      this.document.querySelector('head').appendChild(link)
    }

    this.contents.on(EVENTS.CONTENTS.EXPAND, () => {
      if (this.displayed && this.iframe) {
        this.expand()
        if (this.contents) {
          this.layout.format(this.contents)
        }
      }
    })

    this.contents.on(EVENTS.CONTENTS.RESIZE, (e) => {
      if (this.displayed && this.iframe) {
        this.expand()
        if (this.contents) {
          this.layout.format(this.contents)
        }
      }
    })

    promise.resolve(this.contents)
  }

  setLayout(layout) {
    this.layout = layout

    if (this.contents) {
      this.layout.format(this.contents)
      this.expand()
    }
  }

  setAxis(axis) {
    this.settings.axis = axis

    if (axis == 'horizontal') {
      this.element.style.flex = 'none'
    } else {
      this.element.style.flex = 'initial'
    }

    this.size()
  }

  setWritingMode(mode) {
    // this.element.style.writingMode = writingMode;
    this.writingMode = mode
  }

  addListeners() {
    //TODO: Add content listeners for expanding
  }

  removeListeners(layoutFunc) {
    //TODO: remove content listeners for expanding
  }

  display(request) {
    var displayed = new defer()

    if (!this.displayed) {
      this.render(request).then(
        function () {
          this.emit(EVENTS.VIEWS.DISPLAYED, this)
          this.onDisplayed(this)

          this.displayed = true
          displayed.resolve(this)
        }.bind(this),
        function (err) {
          displayed.reject(err, this)
        },
      )
    } else {
      displayed.resolve(this)
    }

    return displayed.promise
  }

  show() {
    this.element.style.visibility = 'visible'

    if (this.iframe) {
      this.iframe.style.visibility = 'visible'

      // Remind Safari to redraw the iframe
      this.iframe.style.transform = 'translateZ(0)'
      this.iframe.offsetWidth
      this.iframe.style.transform = null
    }

    this.emit(EVENTS.VIEWS.SHOWN, this)
  }

  hide() {
    // this.iframe.style.display = "none";
    this.element.style.visibility = 'hidden'
    this.iframe.style.visibility = 'hidden'

    this.stopExpanding = true
    this.emit(EVENTS.VIEWS.HIDDEN, this)
  }

  offset() {
    return {
      top: this.element.offsetTop,
      left: this.element.offsetLeft,
    }
  }

  width() {
    return this._width
  }

  height() {
    return this._height
  }

  position() {
    return this.element.getBoundingClientRect()
  }

  locationOf(target) {
    var parentPos = this.iframe.getBoundingClientRect()
    var targetPos = this.contents.locationOf(target, this.settings.ignoreClass)

    return {
      left: targetPos.left,
      top: targetPos.top,
    }
  }

  onDisplayed(view) {
    // Stub, override with a custom functions
  }

  onResize(view, e) {
    // Stub, override with a custom functions
  }

  bounds(force) {
    if (force || !this.elementBounds) {
      this.elementBounds = bounds(this.element)
    }

    return this.elementBounds
  }

  highlight(cfiRange, data = {}, cb, className = 'epubjs-hl', styles = {}) {
    if (!this.contents) {
      return
    }
    const attributes = Object.assign(
      { fill: 'yellow', 'fill-opacity': '0.3', 'mix-blend-mode': 'multiply' },
      styles,
    )
    let range = this.contents.range(cfiRange)

    let emitter = () => {
      this.emit(EVENTS.VIEWS.MARK_CLICKED, cfiRange, data)
    }

    data['epubcfi'] = cfiRange

    if (!this.pane) {
      this.pane = new Pane(this.iframe, this.element)
    }

    let m = new Highlight(range, className, data, attributes)
    let h = this.pane.addMark(m)

    this.highlights[cfiRange] = {
      mark: h,
      element: h.element,
      listeners: [emitter, cb],
    }

    h.element.setAttribute('ref', className)
    h.element.addEventListener('click', emitter)
    h.element.addEventListener('touchstart', emitter)

    if (cb) {
      h.element.addEventListener('click', cb)
      h.element.addEventListener('touchstart', cb)
    }
    return h
  }

  underline(cfiRange, data = {}, cb, className = 'epubjs-ul', styles = {}) {
    if (!this.contents) {
      return
    }
    const attributes = Object.assign(
      {
        stroke: 'black',
        'stroke-opacity': '0.3',
        'mix-blend-mode': 'multiply',
      },
      styles,
    )
    let range = this.contents.range(cfiRange)
    let emitter = () => {
      this.emit(EVENTS.VIEWS.MARK_CLICKED, cfiRange, data)
    }

    data['epubcfi'] = cfiRange

    if (!this.pane) {
      this.pane = new Pane(this.iframe, this.element)
    }

    let m = new Underline(range, className, data, attributes)
    let h = this.pane.addMark(m)

    this.underlines[cfiRange] = {
      mark: h,
      element: h.element,
      listeners: [emitter, cb],
    }

    h.element.setAttribute('ref', className)
    h.element.addEventListener('click', emitter)
    h.element.addEventListener('touchstart', emitter)

    if (cb) {
      h.element.addEventListener('click', cb)
      h.element.addEventListener('touchstart', cb)
    }
    return h
  }

  mark(cfiRange, data = {}, cb) {
    if (!this.contents) {
      return
    }

    if (cfiRange in this.marks) {
      let item = this.marks[cfiRange]
      return item
    }

    let range = this.contents.range(cfiRange)
    if (!range) {
      return
    }
    let container = range.commonAncestorContainer
    let parent = container.nodeType === 1 ? container : container.parentNode

    let emitter = (e) => {
      this.emit(EVENTS.VIEWS.MARK_CLICKED, cfiRange, data)
    }

    if (range.collapsed && container.nodeType === 1) {
      range = new Range()
      range.selectNodeContents(container)
    } else if (range.collapsed) {
      // Webkit doesn't like collapsed ranges
      range = new Range()
      range.selectNodeContents(parent)
    }

    let mark = this.document.createElement('a')
    mark.setAttribute('ref', 'epubjs-mk')
    mark.style.position = 'absolute'

    mark.dataset['epubcfi'] = cfiRange

    if (data) {
      Object.keys(data).forEach((key) => {
        mark.dataset[key] = data[key]
      })
    }

    if (cb) {
      mark.addEventListener('click', cb)
      mark.addEventListener('touchstart', cb)
    }

    mark.addEventListener('click', emitter)
    mark.addEventListener('touchstart', emitter)

    this.placeMark(mark, range)

    this.element.appendChild(mark)

    this.marks[cfiRange] = {
      element: mark,
      range: range,
      listeners: [emitter, cb],
    }

    return parent
  }

  placeMark(element, range) {
    let top, right, left

    if (
      this.layout.name === 'pre-paginated' ||
      this.settings.axis !== 'horizontal'
    ) {
      let pos = range.getBoundingClientRect()
      top = pos.top
      right = pos.right
    } else {
      // Element might break columns, so find the left most element
      let rects = range.getClientRects()

      let rect
      for (var i = 0; i != rects.length; i++) {
        rect = rects[i]
        if (!left || rect.left < left) {
          left = rect.left
          // right = rect.right;
          right =
            Math.ceil(left / this.layout.props.pageWidth) *
              this.layout.props.pageWidth -
            this.layout.gap / 2
          top = rect.top
        }
      }
    }

    element.style.top = `${top}px`
    element.style.left = `${right}px`
  }

  unhighlight(cfiRange) {
    let item
    if (cfiRange in this.highlights) {
      item = this.highlights[cfiRange]

      this.pane.removeMark(item.mark)
      item.listeners.forEach((l) => {
        if (l) {
          item.element.removeEventListener('click', l)
          item.element.removeEventListener('touchstart', l)
        }
      })
      delete this.highlights[cfiRange]
    }
  }

  ununderline(cfiRange) {
    let item
    if (cfiRange in this.underlines) {
      item = this.underlines[cfiRange]
      this.pane.removeMark(item.mark)
      item.listeners.forEach((l) => {
        if (l) {
          item.element.removeEventListener('click', l)
          item.element.removeEventListener('touchstart', l)
        }
      })
      delete this.underlines[cfiRange]
    }
  }

  unmark(cfiRange) {
    let item
    if (cfiRange in this.marks) {
      item = this.marks[cfiRange]
      this.element.removeChild(item.element)
      item.listeners.forEach((l) => {
        if (l) {
          item.element.removeEventListener('click', l)
          item.element.removeEventListener('touchstart', l)
        }
      })
      delete this.marks[cfiRange]
    }
  }

  destroy() {
    for (let cfiRange in this.highlights) {
      this.unhighlight(cfiRange)
    }

    for (let cfiRange in this.underlines) {
      this.ununderline(cfiRange)
    }

    for (let cfiRange in this.marks) {
      this.unmark(cfiRange)
    }

    if (this.blobUrl) {
      revokeBlobUrl(this.blobUrl)
    }

    if (this.displayed) {
      this.displayed = false

      this.removeListeners()
      this.contents.destroy()

      this.stopExpanding = true
      this.element.removeChild(this.iframe)

      if (this.pane) {
        this.pane.element.remove()
        this.pane = undefined
      }

      this.iframe = undefined
      this.contents = undefined

      this._textWidth = null
      this._textHeight = null
      this._width = null
      this._height = null
    }

    // this.element.style.height = "0px";
    // this.element.style.width = "0px";
  }
}

EventEmitter(IframeView.prototype)

export default IframeView

</code>

packages\epubjs\src\managers\views\inline.js:
<code>
import EventEmitter from 'event-emitter'

import Contents from '../../contents'
import EpubCFI from '../../epubcfi'
import { EVENTS } from '../../utils/constants'
import {
  extend,
  borders,
  uuid,
  isNumber,
  bounds,
  defer,
  qs,
  parse,
} from '../../utils/core'

class InlineView {
  constructor(section, options) {
    this.settings = extend(
      {
        ignoreClass: '',
        axis: 'vertical',
        width: 0,
        height: 0,
        layout: undefined,
        globalLayoutProperties: {},
      },
      options || {},
    )

    this.id = 'epubjs-view:' + uuid()
    this.section = section
    this.index = section.index

    this.element = this.container(this.settings.axis)

    this.added = false
    this.displayed = false
    this.rendered = false

    this.width = this.settings.width
    this.height = this.settings.height

    this.fixedWidth = 0
    this.fixedHeight = 0

    // Blank Cfi for Parsing
    this.epubcfi = new EpubCFI()

    this.layout = this.settings.layout
    // Dom events to listen for
    // this.listenedEvents = ["keydown", "keyup", "keypressed", "mouseup", "mousedown", "click", "touchend", "touchstart"];
  }

  container(axis) {
    var element = document.createElement('div')

    element.classList.add('epub-view')

    // if(this.settings.axis === "horizontal") {
    //   element.style.width = "auto";
    //   element.style.height = "0";
    // } else {
    //   element.style.width = "0";
    //   element.style.height = "auto";
    // }

    element.style.overflow = 'hidden'

    if (axis && axis == 'horizontal') {
      element.style.display = 'inline-block'
    } else {
      element.style.display = 'block'
    }

    return element
  }

  create() {
    if (this.frame) {
      return this.frame
    }

    if (!this.element) {
      this.element = this.createContainer()
    }

    this.frame = document.createElement('div')
    this.frame.id = this.id
    this.frame.style.overflow = 'hidden'
    this.frame.style.wordSpacing = 'initial'
    this.frame.style.lineHeight = 'initial'

    this.resizing = true

    // this.frame.style.display = "none";
    this.element.style.visibility = 'hidden'
    this.frame.style.visibility = 'hidden'

    if (this.settings.axis === 'horizontal') {
      this.frame.style.width = 'auto'
      this.frame.style.height = '0'
    } else {
      this.frame.style.width = '0'
      this.frame.style.height = 'auto'
    }

    this._width = 0
    this._height = 0

    this.element.appendChild(this.frame)
    this.added = true

    this.elementBounds = bounds(this.element)

    return this.frame
  }

  render(request, show) {
    // view.onLayout = this.layout.format.bind(this.layout);
    this.create()

    // Fit to size of the container, apply padding
    this.size()

    // Render Chain
    return (
      this.section
        .render(request)
        .then(
          function (contents) {
            return this.load(contents)
          }.bind(this),
        )
        // .then(function(doc){
        // 	return this.hooks.content.trigger(view, this);
        // }.bind(this))
        .then(
          function () {
            // this.settings.layout.format(view.contents);
            // return this.hooks.layout.trigger(view, this);
          }.bind(this),
        )
        // .then(function(){
        // 	return this.display();
        // }.bind(this))
        // .then(function(){
        // 	return this.hooks.render.trigger(view, this);
        // }.bind(this))
        .then(
          function () {
            // apply the layout function to the contents
            this.settings.layout.format(this.contents)

            // Expand the iframe to the full size of the content
            // this.expand();

            // Listen for events that require an expansion of the iframe
            this.addListeners()

            if (show !== false) {
              //this.q.enqueue(function(view){
              this.show()
              //}, view);
            }
            // this.map = new Map(view, this.layout);
            //this.hooks.show.trigger(view, this);
            this.emit(EVENTS.VIEWS.RENDERED, this.section)
          }.bind(this),
        )
        .catch(
          function (e) {
            this.emit(EVENTS.VIEWS.LOAD_ERROR, e)
          }.bind(this),
        )
    )
  }

  // Determine locks base on settings
  size(_width, _height) {
    var width = _width || this.settings.width
    var height = _height || this.settings.height

    if (this.layout.name === 'pre-paginated') {
      // TODO: check if these are different than the size set in chapter
      this.lock('both', width, height)
    } else if (this.settings.axis === 'horizontal') {
      this.lock('height', width, height)
    } else {
      this.lock('width', width, height)
    }
  }

  // Lock an axis to element dimensions, taking borders into account
  lock(what, width, height) {
    var elBorders = borders(this.element)
    var iframeBorders

    if (this.frame) {
      iframeBorders = borders(this.frame)
    } else {
      iframeBorders = { width: 0, height: 0 }
    }

    if (what == 'width' && isNumber(width)) {
      this.lockedWidth = width - elBorders.width - iframeBorders.width
      this.resize(this.lockedWidth, false) //  width keeps ratio correct
    }

    if (what == 'height' && isNumber(height)) {
      this.lockedHeight = height - elBorders.height - iframeBorders.height
      this.resize(false, this.lockedHeight)
    }

    if (what === 'both' && isNumber(width) && isNumber(height)) {
      this.lockedWidth = width - elBorders.width - iframeBorders.width
      this.lockedHeight = height - elBorders.height - iframeBorders.height

      this.resize(this.lockedWidth, this.lockedHeight)
    }
  }

  // Resize a single axis based on content dimensions
  expand(force) {
    var width = this.lockedWidth
    var height = this.lockedHeight

    var textWidth, textHeight

    if (!this.frame || this._expanding) return

    this._expanding = true

    // Expand Horizontally
    if (this.settings.axis === 'horizontal') {
      width = this.contentWidth(textWidth)
    } // Expand Vertically
    else if (this.settings.axis === 'vertical') {
      height = this.contentHeight(textHeight)
    }

    // Only Resize if dimensions have changed or
    // if Frame is still hidden, so needs reframing
    if (this._needsReframe || width != this._width || height != this._height) {
      this.resize(width, height)
    }

    this._expanding = false
  }

  contentWidth(min) {
    return this.frame.scrollWidth
  }

  contentHeight(min) {
    return this.frame.scrollHeight
  }

  resize(width, height) {
    if (!this.frame) return

    if (isNumber(width)) {
      this.frame.style.width = width + 'px'
      this._width = width
    }

    if (isNumber(height)) {
      this.frame.style.height = height + 'px'
      this._height = height
    }

    this.prevBounds = this.elementBounds

    this.elementBounds = bounds(this.element)

    let size = {
      width: this.elementBounds.width,
      height: this.elementBounds.height,
      widthDelta: this.elementBounds.width - this.prevBounds.width,
      heightDelta: this.elementBounds.height - this.prevBounds.height,
    }

    this.onResize(this, size)

    this.emit(EVENTS.VIEWS.RESIZED, size)
  }

  load(contents) {
    var loading = new defer()
    var loaded = loading.promise
    var doc = parse(contents, 'text/html')
    var body = qs(doc, 'body')

    /*
		var srcs = doc.querySelectorAll("[src]");

		Array.prototype.slice.call(srcs)
			.forEach(function(item) {
				var src = item.getAttribute("src");
				var assetUri = URI(src);
				var origin = assetUri.origin();
				var absoluteUri;

				if (!origin) {
					absoluteUri = assetUri.absoluteTo(this.section.url);
					item.src = absoluteUri;
				}
			}.bind(this));
		*/
    this.frame.innerHTML = body.innerHTML

    this.document = this.frame.ownerDocument
    this.window = this.document.defaultView

    this.contents = new Contents(this.document, this.frame)

    this.rendering = false

    loading.resolve(this.contents)

    return loaded
  }

  setLayout(layout) {
    this.layout = layout
  }

  resizeListenters() {
    // Test size again
    // clearTimeout(this.expanding);
    // this.expanding = setTimeout(this.expand.bind(this), 350);
  }

  addListeners() {
    //TODO: Add content listeners for expanding
  }

  removeListeners(layoutFunc) {
    //TODO: remove content listeners for expanding
  }

  display(request) {
    var displayed = new defer()

    if (!this.displayed) {
      this.render(request).then(
        function () {
          this.emit(EVENTS.VIEWS.DISPLAYED, this)
          this.onDisplayed(this)

          this.displayed = true

          displayed.resolve(this)
        }.bind(this),
      )
    } else {
      displayed.resolve(this)
    }

    return displayed.promise
  }

  show() {
    this.element.style.visibility = 'visible'

    if (this.frame) {
      this.frame.style.visibility = 'visible'
    }

    this.emit(EVENTS.VIEWS.SHOWN, this)
  }

  hide() {
    // this.frame.style.display = "none";
    this.element.style.visibility = 'hidden'
    this.frame.style.visibility = 'hidden'

    this.stopExpanding = true
    this.emit(EVENTS.VIEWS.HIDDEN, this)
  }

  position() {
    return this.element.getBoundingClientRect()
  }

  locationOf(target) {
    var parentPos = this.frame.getBoundingClientRect()
    var targetPos = this.contents.locationOf(target, this.settings.ignoreClass)

    return {
      left: window.scrollX + parentPos.left + targetPos.left,
      top: window.scrollY + parentPos.top + targetPos.top,
    }
  }

  onDisplayed(view) {
    // Stub, override with a custom functions
  }

  onResize(view, e) {
    // Stub, override with a custom functions
  }

  bounds() {
    if (!this.elementBounds) {
      this.elementBounds = bounds(this.element)
    }
    return this.elementBounds
  }

  destroy() {
    if (this.displayed) {
      this.displayed = false

      this.removeListeners()

      this.stopExpanding = true
      this.element.removeChild(this.frame)
      this.displayed = false
      this.frame = null

      this._textWidth = null
      this._textHeight = null
      this._width = null
      this._height = null
    }
    // this.element.style.height = "0px";
    // this.element.style.width = "0px";
  }
}

EventEmitter(InlineView.prototype)

export default InlineView

</code>

packages\epubjs\src\utils\constants.js:
<code>
export const EPUBJS_VERSION = '0.3'

// Dom events to listen for
export const DOM_EVENTS = [
  'keydown',
  'keyup',
  'keypressed',
  'mouseup',
  'mousedown',
  'mousemove',
  'click',
  'touchend',
  'touchstart',
  'touchmove',
]

export const EVENTS = {
  BOOK: {
    OPEN_FAILED: 'openFailed',
  },
  CONTENTS: {
    EXPAND: 'expand',
    RESIZE: 'resize',
    SELECTED: 'selected',
    SELECTED_RANGE: 'selectedRange',
    LINK_CLICKED: 'linkClicked',
  },
  LOCATIONS: {
    CHANGED: 'changed',
  },
  MANAGERS: {
    RESIZE: 'resize',
    RESIZED: 'resized',
    ORIENTATION_CHANGE: 'orientationchange',
    ADDED: 'added',
    SCROLL: 'scroll',
    SCROLLED: 'scrolled',
    REMOVED: 'removed',
  },
  VIEWS: {
    AXIS: 'axis',
    WRITING_MODE: 'writingMode',
    LOAD_ERROR: 'loaderror',
    RENDERED: 'rendered',
    RESIZED: 'resized',
    DISPLAYED: 'displayed',
    SHOWN: 'shown',
    HIDDEN: 'hidden',
    MARK_CLICKED: 'markClicked',
  },
  RENDITION: {
    STARTED: 'started',
    ATTACHED: 'attached',
    DISPLAYED: 'displayed',
    DISPLAY_ERROR: 'displayerror',
    RENDERED: 'rendered',
    REMOVED: 'removed',
    RESIZED: 'resized',
    ORIENTATION_CHANGE: 'orientationchange',
    LOCATION_CHANGED: 'locationChanged',
    RELOCATED: 'relocated',
    MARK_CLICKED: 'markClicked',
    SELECTED: 'selected',
    LAYOUT: 'layout',
  },
  LAYOUT: {
    UPDATED: 'updated',
  },
  ANNOTATION: {
    ATTACH: 'attach',
    DETACH: 'detach',
  },
}

</code>

packages\epubjs\src\utils\core.js:
<code>
/**
 * Core Utilities and Helpers
 * @module Core
 */
import { DOMParser as XMLDOMParser } from '@xmldom/xmldom'

/**
 * Vendor prefixed requestAnimationFrame
 * @returns {function} requestAnimationFrame
 * @memberof Core
 */
export const requestAnimationFrame =
  typeof window != 'undefined'
    ? window.requestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      window.msRequestAnimationFrame
    : false
const ELEMENT_NODE = 1
const TEXT_NODE = 3
const COMMENT_NODE = 8
const DOCUMENT_NODE = 9
const _URL =
  typeof URL != 'undefined'
    ? URL
    : typeof window != 'undefined'
    ? window.URL || window.webkitURL || window.mozURL
    : undefined

/**
 * Generates a UUID
 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
 * @returns {string} uuid
 * @memberof Core
 */
export function uuid() {
  var d = new Date().getTime()
  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(
    /[xy]/g,
    function (c) {
      var r = (d + Math.random() * 16) % 16 | 0
      d = Math.floor(d / 16)
      return (c == 'x' ? r : (r & 0x7) | 0x8).toString(16)
    },
  )
  return uuid
}

/**
 * Gets the height of a document
 * @returns {number} height
 * @memberof Core
 */
export function documentHeight() {
  return Math.max(
    document.documentElement.clientHeight,
    document.body.scrollHeight,
    document.documentElement.scrollHeight,
    document.body.offsetHeight,
    document.documentElement.offsetHeight,
  )
}

/**
 * Checks if a node is an element
 * @param {object} obj
 * @returns {boolean}
 * @memberof Core
 */
export function isElement(obj) {
  return !!(obj && obj.nodeType == 1)
}

/**
 * @param {any} n
 * @returns {boolean}
 * @memberof Core
 */
export function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n)
}

/**
 * @param {any} n
 * @returns {boolean}
 * @memberof Core
 */
export function isFloat(n) {
  let f = parseFloat(n)

  if (isNumber(n) === false) {
    return false
  }

  if (typeof n === 'string' && n.indexOf('.') > -1) {
    return true
  }

  return Math.floor(f) !== f
}

/**
 * Get a prefixed css property
 * @param {string} unprefixed
 * @returns {string}
 * @memberof Core
 */
export function prefixed(unprefixed) {
  var vendors = ['Webkit', 'webkit', 'Moz', 'O', 'ms']
  var prefixes = ['-webkit-', '-webkit-', '-moz-', '-o-', '-ms-']
  var lower = unprefixed.toLowerCase()
  var length = vendors.length

  if (
    typeof document === 'undefined' ||
    typeof document.body.style[lower] != 'undefined'
  ) {
    return unprefixed
  }

  for (var i = 0; i < length; i++) {
    if (typeof document.body.style[prefixes[i] + lower] != 'undefined') {
      return prefixes[i] + lower
    }
  }

  return unprefixed
}

/**
 * Apply defaults to an object
 * @param {object} obj
 * @returns {object}
 * @memberof Core
 */
export function defaults(obj) {
  for (var i = 1, length = arguments.length; i < length; i++) {
    var source = arguments[i]
    for (var prop in source) {
      if (obj[prop] === void 0) obj[prop] = source[prop]
    }
  }
  return obj
}

/**
 * Extend properties of an object
 * @param {object} target
 * @returns {object}
 * @memberof Core
 */
export function extend(target) {
  var sources = [].slice.call(arguments, 1)
  sources.forEach(function (source) {
    if (!source) return
    Object.getOwnPropertyNames(source).forEach(function (propName) {
      Object.defineProperty(
        target,
        propName,
        Object.getOwnPropertyDescriptor(source, propName),
      )
    })
  })
  return target
}

/**
 * Fast quicksort insert for sorted array -- based on:
 *  http://stackoverflow.com/questions/1344500/efficient-way-to-insert-a-number-into-a-sorted-array-of-numbers
 * @param {any} item
 * @param {array} array
 * @param {function} [compareFunction]
 * @returns {number} location (in array)
 * @memberof Core
 */
export function insert(item, array, compareFunction) {
  var location = locationOf(item, array, compareFunction)
  array.splice(location, 0, item)

  return location
}

/**
 * Finds where something would fit into a sorted array
 * @param {any} item
 * @param {array} array
 * @param {function} [compareFunction]
 * @param {function} [_start]
 * @param {function} [_end]
 * @returns {number} location (in array)
 * @memberof Core
 */
export function locationOf(item, array, compareFunction, _start, _end) {
  var start = _start || 0
  var end = _end || array.length
  var pivot = parseInt(start + (end - start) / 2)
  var compared
  if (!compareFunction) {
    compareFunction = function (a, b) {
      if (a > b) return 1
      if (a < b) return -1
      if (a == b) return 0
    }
  }
  if (end - start <= 0) {
    return pivot
  }

  compared = compareFunction(array[pivot], item)
  if (end - start === 1) {
    return compared >= 0 ? pivot : pivot + 1
  }
  if (compared === 0) {
    return pivot
  }
  if (compared === -1) {
    return locationOf(item, array, compareFunction, pivot, end)
  } else {
    return locationOf(item, array, compareFunction, start, pivot)
  }
}

/**
 * Finds index of something in a sorted array
 * Returns -1 if not found
 * @param {any} item
 * @param {array} array
 * @param {function} [compareFunction]
 * @param {function} [_start]
 * @param {function} [_end]
 * @returns {number} index (in array) or -1
 * @memberof Core
 */
export function indexOfSorted(item, array, compareFunction, _start, _end) {
  var start = _start || 0
  var end = _end || array.length
  var pivot = parseInt(start + (end - start) / 2)
  var compared
  if (!compareFunction) {
    compareFunction = function (a, b) {
      if (a > b) return 1
      if (a < b) return -1
      if (a == b) return 0
    }
  }
  if (end - start <= 0) {
    return -1 // Not found
  }

  compared = compareFunction(array[pivot], item)
  if (end - start === 1) {
    return compared === 0 ? pivot : -1
  }
  if (compared === 0) {
    return pivot // Found
  }
  if (compared === -1) {
    return indexOfSorted(item, array, compareFunction, pivot, end)
  } else {
    return indexOfSorted(item, array, compareFunction, start, pivot)
  }
}
/**
 * Find the bounds of an element
 * taking padding and margin into account
 * @param {element} el
 * @returns {{ width: Number, height: Number}}
 * @memberof Core
 */
export function bounds(el) {
  var style = window.getComputedStyle(el)
  var widthProps = [
    'width',
    'paddingRight',
    'paddingLeft',
    'marginRight',
    'marginLeft',
    'borderRightWidth',
    'borderLeftWidth',
  ]
  var heightProps = [
    'height',
    'paddingTop',
    'paddingBottom',
    'marginTop',
    'marginBottom',
    'borderTopWidth',
    'borderBottomWidth',
  ]

  var width = 0
  var height = 0

  widthProps.forEach(function (prop) {
    width += parseFloat(style[prop]) || 0
  })

  heightProps.forEach(function (prop) {
    height += parseFloat(style[prop]) || 0
  })

  return {
    height: height,
    width: width,
  }
}

/**
 * Find the bounds of an element
 * taking padding, margin and borders into account
 * @param {element} el
 * @returns {{ width: Number, height: Number}}
 * @memberof Core
 */
export function borders(el) {
  var style = window.getComputedStyle(el)
  var widthProps = [
    'paddingRight',
    'paddingLeft',
    'marginRight',
    'marginLeft',
    'borderRightWidth',
    'borderLeftWidth',
  ]
  var heightProps = [
    'paddingTop',
    'paddingBottom',
    'marginTop',
    'marginBottom',
    'borderTopWidth',
    'borderBottomWidth',
  ]

  var width = 0
  var height = 0

  widthProps.forEach(function (prop) {
    width += parseFloat(style[prop]) || 0
  })

  heightProps.forEach(function (prop) {
    height += parseFloat(style[prop]) || 0
  })

  return {
    height: height,
    width: width,
  }
}

/**
 * Find the bounds of any node
 * allows for getting bounds of text nodes by wrapping them in a range
 * @param {node} node
 * @returns {BoundingClientRect}
 * @memberof Core
 */
export function nodeBounds(node) {
  let elPos
  let doc = node.ownerDocument
  if (node.nodeType == Node.TEXT_NODE) {
    let elRange = doc.createRange()
    elRange.selectNodeContents(node)
    elPos = elRange.getBoundingClientRect()
  } else {
    elPos = node.getBoundingClientRect()
  }
  return elPos
}

/**
 * Find the equivalent of getBoundingClientRect of a browser window
 * @returns {{ width: Number, height: Number, top: Number, left: Number, right: Number, bottom: Number }}
 * @memberof Core
 */
export function windowBounds() {
  var width = window.innerWidth
  var height = window.innerHeight

  return {
    top: 0,
    left: 0,
    right: width,
    bottom: height,
    width: width,
    height: height,
  }
}

/**
 * Gets the index of a node in its parent
 * @param {Node} node
 * @param {string} typeId
 * @return {number} index
 * @memberof Core
 */
export function indexOfNode(node, typeId) {
  var parent = node.parentNode
  var children = parent.childNodes
  var sib
  var index = -1
  for (var i = 0; i < children.length; i++) {
    sib = children[i]
    if (sib.nodeType === typeId) {
      index++
    }
    if (sib == node) break
  }

  return index
}

/**
 * Gets the index of a text node in its parent
 * @param {node} textNode
 * @returns {number} index
 * @memberof Core
 */
export function indexOfTextNode(textNode) {
  return indexOfNode(textNode, TEXT_NODE)
}

/**
 * Gets the index of an element node in its parent
 * @param {element} elementNode
 * @returns {number} index
 * @memberof Core
 */
export function indexOfElementNode(elementNode) {
  return indexOfNode(elementNode, ELEMENT_NODE)
}

/**
 * Check if extension is xml
 * @param {string} ext
 * @returns {boolean}
 * @memberof Core
 */
export function isXml(ext) {
  return ['xml', 'opf', 'ncx'].indexOf(ext) > -1
}

/**
 * Create a new blob
 * @param {any} content
 * @param {string} mime
 * @returns {Blob}
 * @memberof Core
 */
export function createBlob(content, mime) {
  return new Blob([content], { type: mime })
}

/**
 * Create a new blob url
 * @param {any} content
 * @param {string} mime
 * @returns {string} url
 * @memberof Core
 */
export function createBlobUrl(content, mime) {
  var tempUrl
  var blob = createBlob(content, mime)

  tempUrl = _URL.createObjectURL(blob)

  return tempUrl
}

/**
 * Remove a blob url
 * @param {string} url
 * @memberof Core
 */
export function revokeBlobUrl(url) {
  return _URL.revokeObjectURL(url)
}

/**
 * Create a new base64 encoded url
 * @param {any} content
 * @param {string} mime
 * @returns {string} url
 * @memberof Core
 */
export function createBase64Url(content, mime) {
  var data
  var datauri

  if (typeof content !== 'string') {
    // Only handles strings
    return
  }

  data = btoa(content)

  datauri = 'data:' + mime + ';base64,' + data

  return datauri
}

/**
 * Get type of an object
 * @param {object} obj
 * @returns {string} type
 * @memberof Core
 */
export function type(obj) {
  return Object.prototype.toString.call(obj).slice(8, -1)
}

/**
 * Parse xml (or html) markup
 * @param {string} markup
 * @param {string} mime
 * @param {boolean} forceXMLDom force using xmlDom to parse instead of native parser
 * @returns {document} document
 * @memberof Core
 */
export function parse(markup, mime, forceXMLDom) {
  var doc
  var Parser

  if (typeof DOMParser === 'undefined' || forceXMLDom) {
    Parser = XMLDOMParser
  } else {
    Parser = DOMParser
  }

  // Remove byte order mark before parsing
  // https://www.w3.org/International/questions/qa-byte-order-mark
  if (markup.charCodeAt(0) === 0xfeff) {
    markup = markup.slice(1)
  }

  doc = new Parser().parseFromString(markup, mime)

  return doc
}

/**
 * querySelector polyfill
 * @param {element} el
 * @param {string} sel selector string
 * @returns {element} element
 * @memberof Core
 */
export function qs(el, sel) {
  var elements
  if (!el) {
    throw new Error('No Element Provided')
  }

  if (typeof el.querySelector != 'undefined') {
    return el.querySelector(sel)
  } else {
    elements = el.getElementsByTagName(sel)
    if (elements.length) {
      return elements[0]
    }
  }
}

/**
 * querySelectorAll polyfill
 * @param {element} el
 * @param {string} sel selector string
 * @returns {element[]} elements
 * @memberof Core
 */
export function qsa(el, sel) {
  if (typeof el.querySelector != 'undefined') {
    return el.querySelectorAll(sel)
  } else {
    return el.getElementsByTagName(sel)
  }
}

/**
 * querySelector by property
 * @param {element} el
 * @param {string} sel selector string
 * @param {object[]} props
 * @returns {element[]} elements
 * @memberof Core
 */
export function qsp(el, sel, props) {
  var q, filtered
  if (typeof el.querySelector != 'undefined') {
    sel += '['
    for (var prop in props) {
      sel += prop + "~='" + props[prop] + "'"
    }
    sel += ']'
    return el.querySelector(sel)
  } else {
    q = el.getElementsByTagName(sel)
    filtered = Array.prototype.slice.call(q, 0).filter(function (el) {
      for (var prop in props) {
        if (el.getAttribute(prop) === props[prop]) {
          return true
        }
      }
      return false
    })

    if (filtered) {
      return filtered[0]
    }
  }
}

/**
 * Sprint through all text nodes in a document
 * @memberof Core
 * @param  {element} root element to start with
 * @param  {function} func function to run on each element
 */
export function sprint(root, func) {
  var doc = root.ownerDocument || root
  if (typeof doc.createTreeWalker !== 'undefined') {
    treeWalker(root, func, NodeFilter.SHOW_TEXT)
  } else {
    walk(
      root,
      function (node) {
        if (node && node.nodeType === 3) {
          // Node.TEXT_NODE
          func(node)
        }
      },
      true,
    )
  }
}

/**
 * Create a treeWalker
 * @memberof Core
 * @param  {element} root element to start with
 * @param  {function} func function to run on each element
 * @param  {function | object} filter function or object to filter with
 */
export function treeWalker(root, func, filter) {
  var treeWalker = document.createTreeWalker(root, filter, null, false)
  let node
  while ((node = treeWalker.nextNode())) {
    func(node)
  }
}

/**
 * @memberof Core
 * @param {node} node
 * @param {callback} return false for continue,true for break inside callback
 */
export function walk(node, callback) {
  if (callback(node)) {
    return true
  }
  node = node.firstChild
  if (node) {
    do {
      let walked = walk(node, callback)
      if (walked) {
        return true
      }
      node = node.nextSibling
    } while (node)
  }
}

/**
 * Convert a blob to a base64 encoded string
 * @param {Blog} blob
 * @returns {string}
 * @memberof Core
 */
export function blob2base64(blob) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader()
    reader.readAsDataURL(blob)
    reader.onloadend = function () {
      resolve(reader.result)
    }
  })
}

/**
 * Creates a new pending promise and provides methods to resolve or reject it.
 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
 * @memberof Core
 */
export function defer() {
  /* A method to resolve the associated Promise with the value passed.
   * If the promise is already settled it does nothing.
   *
   * @param {anything} value : This value is used to resolve the promise
   * If the value is a Promise then the associated promise assumes the state
   * of Promise passed as value.
   */
  this.resolve = null

  /* A method to reject the associated Promise with the value passed.
   * If the promise is already settled it does nothing.
   *
   * @param {anything} reason: The reason for the rejection of the Promise.
   * Generally its an Error object. If however a Promise is passed, then the Promise
   * itself will be the reason for rejection no matter the state of the Promise.
   */
  this.reject = null

  this.id = uuid()

  /* A newly created Pomise object.
   * Initially in pending state.
   */
  this.promise = new Promise((resolve, reject) => {
    this.resolve = resolve
    this.reject = reject
  })
  Object.freeze(this)
}

/**
 * querySelector with filter by epub type
 * @param {element} html
 * @param {string} element element type to find
 * @param {string} type epub type to find
 * @returns {element[]} elements
 * @memberof Core
 */
export function querySelectorByType(html, element, type) {
  var query
  if (typeof html.querySelector != 'undefined') {
    query = html.querySelector(`${element}[*|type="${type}"]`)
  }
  // Handle IE not supporting namespaced epub:type in querySelector
  if (!query || query.length === 0) {
    query = qsa(html, element)
    for (var i = 0; i < query.length; i++) {
      if (
        query[i].getAttributeNS('http://www.idpf.org/2007/ops', 'type') ===
          type ||
        query[i].getAttribute('epub:type') === type
      ) {
        return query[i]
      }
    }
  } else {
    return query
  }
}

/**
 * Find direct descendents of an element
 * @param {element} el
 * @returns {element[]} children
 * @memberof Core
 */
export function findChildren(el) {
  var result = []
  var childNodes = el.childNodes
  for (var i = 0; i < childNodes.length; i++) {
    let node = childNodes[i]
    if (node.nodeType === 1) {
      result.push(node)
    }
  }
  return result
}

/**
 * Find all parents (ancestors) of an element
 * @param {element} node
 * @returns {element[]} parents
 * @memberof Core
 */
export function parents(node) {
  var nodes = [node]
  for (; node; node = node.parentNode) {
    nodes.unshift(node)
  }
  return nodes
}

/**
 * Find all direct descendents of a specific type
 * @param {element} el
 * @param {string} nodeName
 * @param {boolean} [single]
 * @returns {element[]} children
 * @memberof Core
 */
export function filterChildren(el, nodeName, single) {
  var result = []
  var childNodes = el.childNodes
  for (var i = 0; i < childNodes.length; i++) {
    let node = childNodes[i]
    if (node.nodeType === 1 && node.nodeName.toLowerCase() === nodeName) {
      if (single) {
        return node
      } else {
        result.push(node)
      }
    }
  }
  if (!single) {
    return result
  }
}

/**
 * Filter all parents (ancestors) with tag name
 * @param {element} node
 * @param {string} tagname
 * @returns {element[]} parents
 * @memberof Core
 */
export function getParentByTagName(node, tagname) {
  let parent
  if (node === null || tagname === '') return
  parent = node.parentNode
  while (parent.nodeType === 1) {
    if (parent.tagName.toLowerCase() === tagname) {
      return parent
    }
    parent = parent.parentNode
  }
}

/**
 * Lightweight Polyfill for DOM Range
 * @class
 * @memberof Core
 */
export class RangeObject {
  constructor() {
    this.collapsed = false
    this.commonAncestorContainer = undefined
    this.endContainer = undefined
    this.endOffset = undefined
    this.startContainer = undefined
    this.startOffset = undefined
  }

  setStart(startNode, startOffset) {
    this.startContainer = startNode
    this.startOffset = startOffset

    if (!this.endContainer) {
      this.collapse(true)
    } else {
      this.commonAncestorContainer = this._commonAncestorContainer()
    }

    this._checkCollapsed()
  }

  setEnd(endNode, endOffset) {
    this.endContainer = endNode
    this.endOffset = endOffset

    if (!this.startContainer) {
      this.collapse(false)
    } else {
      this.collapsed = false
      this.commonAncestorContainer = this._commonAncestorContainer()
    }

    this._checkCollapsed()
  }

  collapse(toStart) {
    this.collapsed = true
    if (toStart) {
      this.endContainer = this.startContainer
      this.endOffset = this.startOffset
      this.commonAncestorContainer = this.startContainer.parentNode
    } else {
      this.startContainer = this.endContainer
      this.startOffset = this.endOffset
      this.commonAncestorContainer = this.endOffset.parentNode
    }
  }

  selectNode(referenceNode) {
    let parent = referenceNode.parentNode
    let index = Array.prototype.indexOf.call(parent.childNodes, referenceNode)
    this.setStart(parent, index)
    this.setEnd(parent, index + 1)
  }

  selectNodeContents(referenceNode) {
    let end = referenceNode.childNodes[referenceNode.childNodes - 1]
    let endIndex =
      referenceNode.nodeType === 3
        ? referenceNode.textContent.length
        : parent.childNodes.length
    this.setStart(referenceNode, 0)
    this.setEnd(referenceNode, endIndex)
  }

  _commonAncestorContainer(startContainer, endContainer) {
    var startParents = parents(startContainer || this.startContainer)
    var endParents = parents(endContainer || this.endContainer)

    if (startParents[0] != endParents[0]) return undefined

    for (var i = 0; i < startParents.length; i++) {
      if (startParents[i] != endParents[i]) {
        return startParents[i - 1]
      }
    }
  }

  _checkCollapsed() {
    if (
      this.startContainer === this.endContainer &&
      this.startOffset === this.endOffset
    ) {
      this.collapsed = true
    } else {
      this.collapsed = false
    }
  }

  toString() {
    // TODO: implement walking between start and end to find text
  }
}

</code>

packages\epubjs\src\utils\hook.js:
<code>
/**
 * Hooks allow for injecting functions that must all complete in order before finishing
 * They will execute in parallel but all must finish before continuing
 * Functions may return a promise if they are async.
 * @param {any} context scope of this
 * @example this.content = new EPUBJS.Hook(this);
 */
class Hook {
  constructor(context) {
    this.context = context || this
    this.hooks = []
  }

  /**
   * Adds a function to be run before a hook completes
   * @example this.content.register(function(){...});
   */
  register() {
    for (var i = 0; i < arguments.length; ++i) {
      if (typeof arguments[i] === 'function') {
        this.hooks.push(arguments[i])
      } else {
        // unpack array
        for (var j = 0; j < arguments[i].length; ++j) {
          this.hooks.push(arguments[i][j])
        }
      }
    }
  }

  /**
   * Removes a function
   * @example this.content.deregister(function(){...});
   */
  deregister(func) {
    let hook
    for (let i = 0; i < this.hooks.length; i++) {
      hook = this.hooks[i]
      if (hook === func) {
        this.hooks.splice(i, 1)
        break
      }
    }
  }

  /**
   * Triggers a hook to run all functions
   * @example this.content.trigger(args).then(function(){...});
   */
  trigger() {
    var args = arguments
    var context = this.context
    var promises = []

    this.hooks.forEach(function (task) {
      try {
        var executing = task.apply(context, args)
      } catch (err) {
        console.log(err)
      }

      if (executing && typeof executing['then'] === 'function') {
        // Task is a function that returns a promise
        promises.push(executing)
      }
      // Otherwise Task resolves immediately, continue
    })

    return Promise.all(promises)
  }

  // Adds a function to be run before a hook completes
  list() {
    return this.hooks
  }

  clear() {
    return (this.hooks = [])
  }
}
export default Hook

</code>

packages\epubjs\src\utils\mime.js:
<code>
/*
 From Zip.js, by Gildas Lormeau
edited down
 */

var table = {
  application: {
    ecmascript: ['es', 'ecma'],
    javascript: 'js',
    ogg: 'ogx',
    pdf: 'pdf',
    postscript: ['ps', 'ai', 'eps', 'epsi', 'epsf', 'eps2', 'eps3'],
    'rdf+xml': 'rdf',
    smil: ['smi', 'smil'],
    'xhtml+xml': ['xhtml', 'xht'],
    xml: ['xml', 'xsl', 'xsd', 'opf', 'ncx'],
    zip: 'zip',
    'x-httpd-eruby': 'rhtml',
    'x-latex': 'latex',
    'x-maker': ['frm', 'maker', 'frame', 'fm', 'fb', 'book', 'fbdoc'],
    'x-object': 'o',
    'x-shockwave-flash': ['swf', 'swfl'],
    'x-silverlight': 'scr',
    'epub+zip': 'epub',
    'font-tdpfr': 'pfr',
    'inkml+xml': ['ink', 'inkml'],
    json: 'json',
    'jsonml+json': 'jsonml',
    'mathml+xml': 'mathml',
    'metalink+xml': 'metalink',
    mp4: 'mp4s',
    // "oebps-package+xml" : "opf",
    'omdoc+xml': 'omdoc',
    oxps: 'oxps',
    'vnd.amazon.ebook': 'azw',
    widget: 'wgt',
    // "x-dtbncx+xml" : "ncx",
    'x-dtbook+xml': 'dtb',
    'x-dtbresource+xml': 'res',
    'x-font-bdf': 'bdf',
    'x-font-ghostscript': 'gsf',
    'x-font-linux-psf': 'psf',
    'x-font-otf': 'otf',
    'x-font-pcf': 'pcf',
    'x-font-snf': 'snf',
    'x-font-ttf': ['ttf', 'ttc'],
    'x-font-type1': ['pfa', 'pfb', 'pfm', 'afm'],
    'x-font-woff': 'woff',
    'x-mobipocket-ebook': ['prc', 'mobi'],
    'x-mspublisher': 'pub',
    'x-nzb': 'nzb',
    'x-tgif': 'obj',
    'xaml+xml': 'xaml',
    'xml-dtd': 'dtd',
    'xproc+xml': 'xpl',
    'xslt+xml': 'xslt',
    'internet-property-stream': 'acx',
    'x-compress': 'z',
    'x-compressed': 'tgz',
    'x-gzip': 'gz',
  },
  audio: {
    flac: 'flac',
    midi: ['mid', 'midi', 'kar', 'rmi'],
    mpeg: ['mpga', 'mpega', 'mp2', 'mp3', 'm4a', 'mp2a', 'm2a', 'm3a'],
    mpegurl: 'm3u',
    ogg: ['oga', 'ogg', 'spx'],
    'x-aiff': ['aif', 'aiff', 'aifc'],
    'x-ms-wma': 'wma',
    'x-wav': 'wav',
    adpcm: 'adp',
    mp4: 'mp4a',
    webm: 'weba',
    'x-aac': 'aac',
    'x-caf': 'caf',
    'x-matroska': 'mka',
    'x-pn-realaudio-plugin': 'rmp',
    xm: 'xm',
    mid: ['mid', 'rmi'],
  },
  image: {
    gif: 'gif',
    ief: 'ief',
    jpeg: ['jpeg', 'jpg', 'jpe'],
    pcx: 'pcx',
    png: 'png',
    'svg+xml': ['svg', 'svgz'],
    tiff: ['tiff', 'tif'],
    'x-icon': 'ico',
    bmp: 'bmp',
    webp: 'webp',
    'x-pict': ['pic', 'pct'],
    'x-tga': 'tga',
    'cis-cod': 'cod',
  },
  text: {
    'cache-manifest': ['manifest', 'appcache'],
    css: 'css',
    csv: 'csv',
    html: ['html', 'htm', 'shtml', 'stm'],
    mathml: 'mml',
    plain: ['txt', 'text', 'brf', 'conf', 'def', 'list', 'log', 'in', 'bas'],
    richtext: 'rtx',
    'tab-separated-values': 'tsv',
    'x-bibtex': 'bib',
  },
  video: {
    mpeg: ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v', 'mp2', 'mpa', 'mpv2'],
    mp4: ['mp4', 'mp4v', 'mpg4'],
    quicktime: ['qt', 'mov'],
    ogg: 'ogv',
    'vnd.mpegurl': ['mxu', 'm4u'],
    'x-flv': 'flv',
    'x-la-asf': ['lsf', 'lsx'],
    'x-mng': 'mng',
    'x-ms-asf': ['asf', 'asx', 'asr'],
    'x-ms-wm': 'wm',
    'x-ms-wmv': 'wmv',
    'x-ms-wmx': 'wmx',
    'x-ms-wvx': 'wvx',
    'x-msvideo': 'avi',
    'x-sgi-movie': 'movie',
    'x-matroska': ['mpv', 'mkv', 'mk3d', 'mks'],
    '3gpp2': '3g2',
    h261: 'h261',
    h263: 'h263',
    h264: 'h264',
    jpeg: 'jpgv',
    jpm: ['jpm', 'jpgm'],
    mj2: ['mj2', 'mjp2'],
    'vnd.ms-playready.media.pyv': 'pyv',
    'vnd.uvvu.mp4': ['uvu', 'uvvu'],
    'vnd.vivo': 'viv',
    webm: 'webm',
    'x-f4v': 'f4v',
    'x-m4v': 'm4v',
    'x-ms-vob': 'vob',
    'x-smv': 'smv',
  },
}

var mimeTypes = (function () {
  var type,
    subtype,
    val,
    index,
    mimeTypes = {}
  for (type in table) {
    if (table.hasOwnProperty(type)) {
      for (subtype in table[type]) {
        if (table[type].hasOwnProperty(subtype)) {
          val = table[type][subtype]
          if (typeof val == 'string') {
            mimeTypes[val] = type + '/' + subtype
          } else {
            for (index = 0; index < val.length; index++) {
              mimeTypes[val[index]] = type + '/' + subtype
            }
          }
        }
      }
    }
  }
  return mimeTypes
})()

var defaultValue = 'text/plain' //"application/octet-stream";

function lookup(filename) {
  return (
    (filename && mimeTypes[filename.split('.').pop().toLowerCase()]) ||
    defaultValue
  )
}

export default { lookup }

</code>

packages\epubjs\src\utils\path.js:
<code>
import path from 'path-webpack'

/**
 * Creates a Path object for parsing and manipulation of a path strings
 *
 * Uses a polyfill for Nodejs path: https://nodejs.org/api/path.html
 * @param	{string} pathString	a url string (relative or absolute)
 * @class
 */
class Path {
  constructor(pathString) {
    var protocol
    var parsed

    protocol = pathString.indexOf('://')
    if (protocol > -1) {
      pathString = new URL(pathString).pathname
    }

    parsed = this.parse(pathString)

    this.path = pathString

    if (this.isDirectory(pathString)) {
      this.directory = pathString
    } else {
      this.directory = parsed.dir + '/'
    }

    this.filename = parsed.base
    this.extension = parsed.ext.slice(1)
  }

  /**
   * Parse the path: https://nodejs.org/api/path.html#path_path_parse_path
   * @param	{string} what
   * @returns {object}
   */
  parse(what) {
    return path.parse(what)
  }

  /**
   * @param	{string} what
   * @returns {boolean}
   */
  isAbsolute(what) {
    return path.isAbsolute(what || this.path)
  }

  /**
   * Check if path ends with a directory
   * @param	{string} what
   * @returns {boolean}
   */
  isDirectory(what) {
    return what.charAt(what.length - 1) === '/'
  }

  /**
   * Resolve a path against the directory of the Path
   *
   * https://nodejs.org/api/path.html#path_path_resolve_paths
   * @param	{string} what
   * @returns {string} resolved
   */
  resolve(what) {
    return path.resolve(this.directory, what)
  }

  /**
   * Resolve a path relative to the directory of the Path
   *
   * https://nodejs.org/api/path.html#path_path_relative_from_to
   * @param	{string} what
   * @returns {string} relative
   */
  relative(what) {
    var isAbsolute = what && what.indexOf('://') > -1

    if (isAbsolute) {
      return what
    }

    return path.relative(this.directory, what)
  }

  splitPath(filename) {
    return this.splitPathRe.exec(filename).slice(1)
  }

  /**
   * Return the path string
   * @returns {string} path
   */
  toString() {
    return this.path
  }
}

export default Path

</code>

packages\epubjs\src\utils\queue.js:
<code>
import { defer, requestAnimationFrame } from './core'

/**
 * Queue for handling tasks one at a time
 * @class
 * @param {scope} context what this will resolve to in the tasks
 */
class Queue {
  constructor(context) {
    this._q = []
    this.context = context
    this.tick = requestAnimationFrame
    this.running = false
    this.paused = false
  }

  /**
   * Add an item to the queue
   * @return {Promise}
   */
  enqueue() {
    var deferred, promise
    var queued
    var task = [].shift.call(arguments)
    var args = arguments

    // Handle single args without context
    // if(args && !Array.isArray(args)) {
    //   args = [args];
    // }
    if (!task) {
      throw new Error('No Task Provided')
    }

    if (typeof task === 'function') {
      deferred = new defer()
      promise = deferred.promise

      queued = {
        task: task,
        args: args,
        //"context"  : context,
        deferred: deferred,
        promise: promise,
      }
    } else {
      // Task is a promise
      queued = {
        promise: task,
      }
    }

    this._q.push(queued)

    // Wait to start queue flush
    if (this.paused == false && !this.running) {
      // setTimeout(this.flush.bind(this), 0);
      // this.tick.call(window, this.run.bind(this));
      this.run()
    }

    return queued.promise
  }

  /**
   * Run one item
   * @return {Promise}
   */
  dequeue() {
    var inwait, task, result

    if (this._q.length && !this.paused) {
      inwait = this._q.shift()
      task = inwait.task
      if (task) {
        // console.log(task)

        result = task.apply(this.context, inwait.args)

        if (result && typeof result['then'] === 'function') {
          // Task is a function that returns a promise
          return result.then(
            function () {
              inwait.deferred.resolve.apply(this.context, arguments)
            }.bind(this),
            function () {
              inwait.deferred.reject.apply(this.context, arguments)
            }.bind(this),
          )
        } else {
          // Task resolves immediately
          inwait.deferred.resolve.apply(this.context, result)
          return inwait.promise
        }
      } else if (inwait.promise) {
        // Task is a promise
        return inwait.promise
      }
    } else {
      inwait = new defer()
      inwait.deferred.resolve()
      return inwait.promise
    }
  }

  // Run All Immediately
  dump() {
    while (this._q.length) {
      this.dequeue()
    }
  }

  /**
   * Run all tasks sequentially, at convince
   * @return {Promise}
   */
  run() {
    if (!this.running) {
      this.running = true
      this.defered = new defer()
    }

    this.tick.call(window, () => {
      if (this._q.length) {
        this.dequeue().then(
          function () {
            this.run()
          }.bind(this),
        )
      } else {
        this.defered.resolve()
        this.running = undefined
      }
    })

    // Unpause
    if (this.paused == true) {
      this.paused = false
    }

    return this.defered.promise
  }

  /**
   * Flush all, as quickly as possible
   * @return {Promise}
   */
  flush() {
    if (this.running) {
      return this.running
    }

    if (this._q.length) {
      this.running = this.dequeue().then(
        function () {
          this.running = undefined
          return this.flush()
        }.bind(this),
      )

      return this.running
    }
  }

  /**
   * Clear all items in wait
   */
  clear() {
    this._q = []
  }

  /**
   * Get the number of tasks in the queue
   * @return {number} tasks
   */
  length() {
    return this._q.length
  }

  /**
   * Pause a running queue
   */
  pause() {
    this.paused = true
  }

  /**
   * End the queue
   */
  stop() {
    this._q = []
    this.running = false
    this.paused = true
  }
}

/**
 * Create a new task from a callback
 * @class
 * @private
 * @param {function} task
 * @param {array} args
 * @param {scope} context
 * @return {function} task
 */
class Task {
  constructor(task, args, context) {
    return function () {
      var toApply = arguments || []

      return new Promise((resolve, reject) => {
        var callback = function (value, err) {
          if (!value && err) {
            reject(err)
          } else {
            resolve(value)
          }
        }
        // Add the callback to the arguments list
        toApply.push(callback)

        // Apply all arguments to the functions
        task.apply(context || this, toApply)
      })
    }
  }
}

export default Queue
export { Task }

</code>

packages\epubjs\src\utils\replacements.js:
<code>
import { qs, qsa } from './core'
import Path from './path'
import Url from './url'

export function replaceBase(doc, section) {
  var base
  var head
  var url = section.url
  var absolute = url.indexOf('://') > -1

  if (!doc) {
    return
  }

  head = qs(doc, 'head')
  base = qs(head, 'base')

  if (!base) {
    base = doc.createElement('base')
    head.insertBefore(base, head.firstChild)
  }

  // Fix for Safari crashing if the url doesn't have an origin
  if (!absolute && window && window.location) {
    url = window.location.origin + url
  }

  base.setAttribute('href', url)
}

export function replaceCanonical(doc, section) {
  var head
  var link
  var url = section.canonical

  if (!doc) {
    return
  }

  head = qs(doc, 'head')
  link = qs(head, "link[rel='canonical']")

  if (link) {
    link.setAttribute('href', url)
  } else {
    link = doc.createElement('link')
    link.setAttribute('rel', 'canonical')
    link.setAttribute('href', url)
    head.appendChild(link)
  }
}

export function replaceMeta(doc, section) {
  var head
  var meta
  var id = section.idref
  if (!doc) {
    return
  }

  head = qs(doc, 'head')
  meta = qs(head, "link[property='dc.identifier']")

  if (meta) {
    meta.setAttribute('content', id)
  } else {
    meta = doc.createElement('meta')
    meta.setAttribute('name', 'dc.identifier')
    meta.setAttribute('content', id)
    head.appendChild(meta)
  }
}

// TODO: move me to Contents
export function replaceLinks(contents, fn) {
  var links = contents.querySelectorAll('a[href]')

  if (!links.length) {
    return
  }

  var base = qs(contents.ownerDocument, 'base')
  var location = base ? base.getAttribute('href') : undefined
  var replaceLink = function (link) {
    var href = link.getAttribute('href')

    if (href.indexOf('mailto:') === 0) {
      return
    }

    var absolute = href.indexOf('://') > -1

    if (absolute) {
      link.setAttribute('target', '_blank')
    } else {
      var linkUrl
      try {
        linkUrl = new Url(href, location)
      } catch (error) {
        // NOOP
      }

      link.onclick = function () {
        if (linkUrl && linkUrl.hash) {
          fn(linkUrl.Path.path + linkUrl.hash)
        } else if (linkUrl) {
          fn(linkUrl.Path.path)
        } else {
          fn(href)
        }

        return false
      }
    }
  }.bind(this)

  for (var i = 0; i < links.length; i++) {
    replaceLink(links[i])
  }
}

export function substitute(content, urls, replacements) {
  urls.forEach(function (url, i) {
    if (url && replacements[i]) {
      // Account for special characters in the file name.
      // See https://stackoverflow.com/a/6318729.
      url = url.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
      content = content.replace(new RegExp(url, 'g'), replacements[i])
    }
  })
  return content
}

</code>

packages\epubjs\src\utils\request.js:
<code>
import { defer, isXml, parse } from './core'
import Path from './path'

function request(url, type, withCredentials, headers) {
  var supportsURL = typeof window != 'undefined' ? window.URL : false // TODO: fallback for url if window isn't defined
  var BLOB_RESPONSE = supportsURL ? 'blob' : 'arraybuffer'

  var deferred = new defer()

  var xhr = new XMLHttpRequest()

  //-- Check from PDF.js:
  //   https://github.com/mozilla/pdf.js/blob/master/web/compatibility.js
  var xhrPrototype = XMLHttpRequest.prototype

  var header

  if (!('overrideMimeType' in xhrPrototype)) {
    // IE10 might have response, but not overrideMimeType
    Object.defineProperty(xhrPrototype, 'overrideMimeType', {
      value: function xmlHttpRequestOverrideMimeType() {},
    })
  }

  if (withCredentials) {
    xhr.withCredentials = true
  }

  xhr.onreadystatechange = handler
  xhr.onerror = err

  xhr.open('GET', url, true)

  for (header in headers) {
    xhr.setRequestHeader(header, headers[header])
  }

  if (type == 'json') {
    xhr.setRequestHeader('Accept', 'application/json')
  }

  // If type isn"t set, determine it from the file extension
  if (!type) {
    type = new Path(url).extension
  }

  if (type == 'blob') {
    xhr.responseType = BLOB_RESPONSE
  }

  if (isXml(type)) {
    // xhr.responseType = "document";
    xhr.overrideMimeType('text/xml') // for OPF parsing
  }

  if (type == 'xhtml') {
    // xhr.responseType = "document";
  }

  if (type == 'html' || type == 'htm') {
    // xhr.responseType = "document";
  }

  if (type == 'binary') {
    xhr.responseType = 'arraybuffer'
  }

  xhr.send()

  function err(e) {
    deferred.reject(e)
  }

  function handler() {
    if (this.readyState === XMLHttpRequest.DONE) {
      var responseXML = false

      if (this.responseType === '' || this.responseType === 'document') {
        responseXML = this.responseXML
      }

      if (this.status === 200 || this.status === 0 || responseXML) {
        //-- Firefox is reporting 0 for blob urls
        var r

        if (!this.response && !responseXML) {
          deferred.reject({
            status: this.status,
            message: 'Empty Response',
            stack: new Error().stack,
          })
          return deferred.promise
        }

        if (this.status === 403) {
          deferred.reject({
            status: this.status,
            response: this.response,
            message: 'Forbidden',
            stack: new Error().stack,
          })
          return deferred.promise
        }
        if (responseXML) {
          r = this.responseXML
        } else if (isXml(type)) {
          // xhr.overrideMimeType("text/xml"); // for OPF parsing
          // If this.responseXML wasn't set, try to parse using a DOMParser from text
          r = parse(this.response, 'text/xml')
        } else if (type == 'xhtml') {
          r = parse(this.response, 'application/xhtml+xml')
        } else if (type == 'html' || type == 'htm') {
          r = parse(this.response, 'text/html')
        } else if (type == 'json') {
          r = JSON.parse(this.response)
        } else if (type == 'blob') {
          if (supportsURL) {
            r = this.response
          } else {
            //-- Safari doesn't support responseType blob, so create a blob from arraybuffer
            r = new Blob([this.response])
          }
        } else {
          r = this.response
        }

        deferred.resolve(r)
      } else {
        deferred.reject({
          status: this.status,
          message: this.response,
          stack: new Error().stack,
        })
      }
    }
  }

  return deferred.promise
}

export default request

</code>

packages\epubjs\src\utils\scrolltype.js:
<code>
// Detect RTL scroll type
// Based on https://github.com/othree/jquery.rtl-scroll-type/blob/master/src/jquery.rtl-scroll.js
export default function scrollType() {
  var type = 'reverse'
  var definer = createDefiner()
  document.body.appendChild(definer)

  if (definer.scrollLeft > 0) {
    type = 'default'
  } else {
    if (typeof Element !== 'undefined' && Element.prototype.scrollIntoView) {
      definer.children[0].children[1].scrollIntoView()
      if (definer.scrollLeft < 0) {
        type = 'negative'
      }
    } else {
      definer.scrollLeft = 1
      if (definer.scrollLeft === 0) {
        type = 'negative'
      }
    }
  }

  document.body.removeChild(definer)
  return type
}

export function createDefiner() {
  var definer = document.createElement('div')
  definer.dir = 'rtl'

  definer.style.position = 'fixed'
  definer.style.width = '1px'
  definer.style.height = '1px'
  definer.style.top = '0px'
  definer.style.left = '0px'
  definer.style.overflow = 'hidden'

  var innerDiv = document.createElement('div')
  innerDiv.style.width = '2px'

  var spanA = document.createElement('span')
  spanA.style.width = '1px'
  spanA.style.display = 'inline-block'

  var spanB = document.createElement('span')
  spanB.style.width = '1px'
  spanB.style.display = 'inline-block'

  innerDiv.appendChild(spanA)
  innerDiv.appendChild(spanB)
  definer.appendChild(innerDiv)

  return definer
}

</code>

packages\epubjs\src\utils\url.js:
<code>
import path from 'path-webpack'

import Path from './path'

/**
 * creates a Url object for parsing and manipulation of a url string
 * @param	{string} urlString	a url string (relative or absolute)
 * @param	{string} [baseString] optional base for the url,
 * default to window.location.href
 */
class Url {
  constructor(urlString, baseString) {
    var absolute = urlString.indexOf('://') > -1
    var pathname = urlString
    var basePath

    this.Url = undefined
    this.href = urlString
    this.protocol = ''
    this.origin = ''
    this.hash = ''
    this.hash = ''
    this.search = ''
    this.base = baseString

    if (
      !absolute &&
      baseString !== false &&
      typeof baseString !== 'string' &&
      window &&
      window.location
    ) {
      this.base = window.location.href
    }

    // URL Polyfill doesn't throw an error if base is empty
    if (absolute || this.base) {
      try {
        if (this.base) {
          // Safari doesn't like an undefined base
          this.Url = new URL(urlString, this.base)
        } else {
          this.Url = new URL(urlString)
        }
        this.href = this.Url.href

        this.protocol = this.Url.protocol
        this.origin = this.Url.origin
        this.hash = this.Url.hash
        this.search = this.Url.search

        pathname = this.Url.pathname + (this.Url.search ? this.Url.search : '')
      } catch (e) {
        // Skip URL parsing
        this.Url = undefined
        // resolve the pathname from the base
        if (this.base) {
          basePath = new Path(this.base)
          pathname = basePath.resolve(pathname)
        }
      }
    }

    this.Path = new Path(pathname)

    this.directory = this.Path.directory
    this.filename = this.Path.filename
    this.extension = this.Path.extension
  }

  /**
   * @returns {Path}
   */
  path() {
    return this.Path
  }

  /**
   * Resolves a relative path to a absolute url
   * @param {string} what
   * @returns {string} url
   */
  resolve(what) {
    var isAbsolute = what.indexOf('://') > -1
    var fullpath

    if (isAbsolute) {
      return what
    }

    fullpath = path.resolve(this.directory, what)
    return this.origin + fullpath
  }

  /**
   * Resolve a path relative to the url
   * @param {string} what
   * @returns {string} path
   */
  relative(what) {
    return path.relative(what, this.directory)
  }

  /**
   * @returns {string}
   */
  toString() {
    return this.href
  }
}

export default Url

</code>

packages\epubjs\test\book.js:
<code>
import assert from 'assert'

import Book from '../src/book'

describe('Book', function () {
  describe('Unarchived', function () {
    var book = new Book('/fixtures/alice/OPS/package.opf')
    it('should open a epub', async function () {
      await book.opened
      assert.equal(book.isOpen, true, 'book is opened')
      assert.equal(
        book.url.toString(),
        'http://localhost:9876/fixtures/alice/OPS/package.opf',
        'book url is passed to new Book',
      )
    })
    it('should have a local coverUrl', async function () {
      assert.equal(
        await book.coverUrl(),
        'http://localhost:9876/fixtures/alice/OPS/images/cover_th.jpg',
        'cover url is available',
      )
    })
  })

  describe('Archived epub', function () {
    var book = new Book('/fixtures/alice.epub')

    it('should open a archived epub', async function () {
      await book.opened
      assert.equal(book.isOpen, true, 'book is opened')
      assert(book.archive, 'book is unarchived')
    })
    it('should have a blob coverUrl', async function () {
      let coverUrl = await book.coverUrl()
      assert(
        /^blob:http:\/\/localhost:9876\/[^\/]+$/.test(coverUrl),
        'cover url is available and a blob: url',
      )
    })
  })

  describe('Archived epub in array buffer without options', function () {
    let book

    before(async function () {
      const response = await fetch('/fixtures/alice.epub')
      const buffer = await response.arrayBuffer()
      book = new Book(buffer)
    })

    it('should open a archived epub', async function () {
      await book.opened
      assert.equal(book.isOpen, true, 'book is opened')
      assert(book.archive, 'book is unarchived')
    })

    it('should have a blob coverUrl', async function () {
      let coverUrl = await book.coverUrl()
      assert(
        /^blob:http:\/\/localhost:9876\/[^\/]+$/.test(coverUrl),
        'cover url is available and a blob: url',
      )
    })
  })

  describe('Archived epub without cover', function () {
    var book = new Book('/fixtures/alice_without_cover.epub')

    it('should open a archived epub', async function () {
      await book.opened
      assert.equal(book.isOpen, true, 'book is opened')
      assert(book.archive, 'book is unarchived')
    })
    it('should have a empty coverUrl', async function () {
      let coverUrl = await book.coverUrl()
      assert.equal(coverUrl, null, 'cover url should be null')
    })
  })
})

</code>

packages\epubjs\test\core.js:
<code>
import assert from 'assert'

import Path from '../src/utils/path'
import Url from '../src/utils/url'

describe('Core', function () {
  before(function () {})

  describe('Url', function () {
    it('Url()', function () {
      var url = new Url('http://example.com/fred/chasen/derf.html')

      assert.equal(url.href, 'http://example.com/fred/chasen/derf.html')
      assert.equal(url.directory, '/fred/chasen/')
      assert.equal(url.extension, 'html')
      assert.equal(url.filename, 'derf.html')
      assert.equal(url.origin, 'http://example.com')
      assert.equal(url.protocol, 'http:')
      assert.equal(url.search, '')
    })

    describe('#resolve()', function () {
      it('should join subfolders', function () {
        var a = 'http://example.com/fred/chasen/'
        var b = 'ops/derf.html'

        var resolved = new Url(a).resolve(b)
        assert.equal(resolved, 'http://example.com/fred/chasen/ops/derf.html')
      })

      it('should resolve up a level', function () {
        var a = 'http://example.com/fred/chasen/index.html'
        var b = '../derf.html'

        var resolved = new Url(a).resolve(b)
        assert.equal(resolved, 'http://example.com/fred/derf.html')
      })

      it('should resolve absolute', function () {
        var a = 'http://example.com/fred/chasen/index.html'
        var b = '/derf.html'

        var resolved = new Url(a).resolve(b)
        assert.equal(resolved, 'http://example.com/derf.html')
      })

      it('should resolve with search strings', function () {
        var a = 'http://example.com/fred/chasen/index.html?debug=true'
        var b = '/derf.html'

        var resolved = new Url(a).resolve(b)
        assert.equal(resolved, 'http://example.com/derf.html')
      })

      // Doesn't work with path.parse
      xit('should handle directory with a dot', function () {
        var a = 'http://example.com/fred/chasen/index.epub/'

        var url = new Url(a)
        assert.equal(url.directory, '/fred/chasen/index.epub/')
        assert.equal(url.extension, '')
      })

      it('should handle file urls', function () {
        var url = new Url(
          'file:///var/mobile/Containers/Data/Application/F47E4434-9B98-4654-93F1-702336B08EE6/Documents/books/moby-dick/derf.html',
        )

        assert.equal(
          url.href,
          'file:///var/mobile/Containers/Data/Application/F47E4434-9B98-4654-93F1-702336B08EE6/Documents/books/moby-dick/derf.html',
        )
        assert.equal(
          url.directory,
          '/var/mobile/Containers/Data/Application/F47E4434-9B98-4654-93F1-702336B08EE6/Documents/books/moby-dick/',
        )
        assert.equal(url.extension, 'html')
        assert.equal(url.filename, 'derf.html')
        assert.equal(url.origin, 'file://') // origin should be blank
        assert.equal(url.protocol, 'file:')
        assert.equal(url.search, '')
      })

      it('should resolve with file urls', function () {
        var a = 'file:///var/mobile/Containers/Data/Application/books/'
        var b = 'derf.html'

        var resolved = new Url(a).resolve(b)
        assert.equal(
          resolved,
          'file:///var/mobile/Containers/Data/Application/books/derf.html',
        )
      })
    })
  })

  describe('Path', function () {
    it('Path()', function () {
      var path = new Path('/fred/chasen/derf.html')

      assert.equal(path.path, '/fred/chasen/derf.html')
      assert.equal(path.directory, '/fred/chasen/')
      assert.equal(path.extension, 'html')
      assert.equal(path.filename, 'derf.html')
    })

    it('Strip out url', function () {
      var path = new Path('http://example.com/fred/chasen/derf.html')

      assert.equal(path.path, '/fred/chasen/derf.html')
      assert.equal(path.directory, '/fred/chasen/')
      assert.equal(path.extension, 'html')
      assert.equal(path.filename, 'derf.html')
    })

    describe('#parse()', function () {
      it('should parse a path', function () {
        var path = Path.prototype.parse('/fred/chasen/derf.html')

        assert.equal(path.dir, '/fred/chasen')
        assert.equal(path.base, 'derf.html')
        assert.equal(path.ext, '.html')
      })

      it('should parse a relative path', function () {
        var path = Path.prototype.parse('fred/chasen/derf.html')

        assert.equal(path.dir, 'fred/chasen')
        assert.equal(path.base, 'derf.html')
        assert.equal(path.ext, '.html')
      })
    })

    describe('#isDirectory()', function () {
      it('should recognize a directory', function () {
        var directory = Path.prototype.isDirectory('/fred/chasen/')
        var notDirectory = Path.prototype.isDirectory('/fred/chasen/derf.html')

        assert(directory, '/fred/chasen/ is a directory')
        assert(!notDirectory, '/fred/chasen/derf.html is not directory')
      })
    })

    describe('#resolve()', function () {
      it('should resolve a path', function () {
        var a = '/fred/chasen/index.html'
        var b = 'derf.html'

        var resolved = new Path(a).resolve(b)
        assert.equal(resolved, '/fred/chasen/derf.html')
      })

      it('should resolve a relative path', function () {
        var a = 'fred/chasen/index.html'
        var b = 'derf.html'

        var resolved = new Path(a).resolve(b)
        assert.equal(resolved, '/fred/chasen/derf.html')
      })

      it('should resolve a level up', function () {
        var a = '/fred/chasen/index.html'
        var b = '../derf.html'

        var resolved = new Path(a).resolve(b)
        assert.equal(resolved, '/fred/derf.html')
      })
    })

    describe('#relative()', function () {
      it('should find a relative path at the same level', function () {
        var a = '/fred/chasen/index.html'
        var b = '/fred/chasen/derf.html'

        var relative = new Path(a).relative(b)
        assert.equal(relative, 'derf.html')
      })

      it('should find a relative path down a level', function () {
        var a = '/fred/chasen/index.html'
        var b = '/fred/chasen/ops/derf.html'

        var relative = new Path(a).relative(b)
        assert.equal(relative, 'ops/derf.html')
      })

      it('should resolve a level up', function () {
        var a = '/fred/chasen/index.html'
        var b = '/fred/derf.html'

        var relative = new Path(a).relative(b)
        assert.equal(relative, '../derf.html')
      })
    })
  })
})

</code>

packages\epubjs\test\epub.js:
<code>
import assert from 'assert'

import ePub from '../src/epub'
// var sinon = require('sinon');

describe('ePub', function () {
  var server
  before(function () {
    /*
		// var packageContents = fs.readFileSync(__dirname + '/../books/moby-dick/OPS/package.opf', 'utf8');
		// var tocContents = fs.readFileSync(__dirname + '/../books/moby-dick/OPS/toc.xhtml', 'utf8');
		var packageContents = require('./fixtures/moby-dick/OPS/package.opf');
		var tocContents = require('./fixtures/moby-dick/OPS/toc.xhtml');

		server = sinon.fakeServer.create();
		server.autoRespond = true;

		server.respondWith("moby-dick/OPS/package.opf", [200, {
			"Content-Type": "text/xml"
		}, packageContents]);

		server.respondWith("moby-dick/OPS/toc.xhtml", [200, {
			"Content-Type": "application/xhtml+xml"
		}, tocContents]);
		*/
  })
  after(function () {
    // server.restore();
  })

  it('should open a epub', function () {
    var book = ePub('/fixtures/alice/OPS/package.opf')

    return book.opened.then(function () {
      assert.equal(book.isOpen, true, 'book is opened')
      assert.equal(
        book.url.toString(),
        'http://localhost:9876/fixtures/alice/OPS/package.opf',
        'book url is passed to new Book',
      )
    })
  })

  it('should open a archived epub', function () {
    var book = ePub('/fixtures/alice.epub')

    // assert(typeof (JSZip) !== "undefined", "JSZip is present" );

    return book.opened.then(function () {
      assert.equal(book.isOpen, true, 'book is opened')
      assert(book.archive, 'book is unarchived')
    })
  })
})

</code>

packages\epubjs\test\epubcfi.js:
<code>
import assert from 'assert'

import EpubCFI from '../src/epubcfi.js'
// var fs = require('fs');
if (typeof DOMParser === 'undefined') {
  global.DOMParser = require('xmldom').DOMParser
}

describe('EpubCFI', function () {
  it('parse a cfi on init', function () {
    var cfi = new EpubCFI('epubcfi(/6/2[cover]!/6)')

    assert.equal(cfi.spinePos, 0, 'spinePos is parsed as the first item')
  })

  it('parse a cfi and ignore the base if present', function () {
    var cfi = new EpubCFI('epubcfi(/6/2[cover]!/6)', '/6/6[end]')

    assert.equal(
      cfi.spinePos,
      0,
      'base is ignored and spinePos is parsed as the first item',
    )
  })

  describe('#parse()', function () {
    var cfi = new EpubCFI()

    it('parse a cfi on init', function () {
      var parsed = cfi.parse('epubcfi(/6/2[cover]!/6)')

      assert.equal(parsed.spinePos, 0, 'spinePos is parsed as the first item')
    })

    it('parse a cfi and ignore the base if present', function () {
      var parsed = cfi.parse('epubcfi(/6/2[cover]!/6)', '/6/6[end]')

      assert.equal(
        parsed.spinePos,
        0,
        'base is ignored and spinePos is parsed as the first item',
      )
    })

    it('parse a cfi with a character offset', function () {
      var parsed = cfi.parse(
        'epubcfi(/6/4[chap01ref]!/4[body01]/10[para05]/2/1:3)',
      )

      assert.equal(
        parsed.path.terminal.offset,
        3,
        'Path has a terminal offset of 3',
      )
    })

    it('parse a cfi with a range', function () {
      var parsed = cfi.parse(
        'epubcfi(/6/4[chap01ref]!/4[body01]/10[para05],/2/1:1,/3:4)',
      )

      assert.equal(parsed.range, true, 'Range is true')
      assert.equal(parsed.start.steps.length, 2, 'Start steps are present')
      assert.equal(parsed.end.steps.length, 1, 'End steps are present')
      assert.equal(
        parsed.start.terminal.offset,
        1,
        'Start has a terminal offset of 1',
      )
      assert.equal(
        parsed.end.terminal.offset,
        4,
        'End has a terminal offset of 4',
      )
    })
  })

  describe('#toString()', function () {
    it('parse a cfi and write it back', function () {
      assert.equal(
        new EpubCFI('epubcfi(/6/2[cover]!/6)').toString(),
        'epubcfi(/6/2[cover]!/6)',
        'output cfi string is same as input',
      )
      assert.equal(
        new EpubCFI(
          'epubcfi(/6/4[chap01ref]!/4[body01]/10[para05]/2/1:3)',
        ).toString(),
        'epubcfi(/6/4[chap01ref]!/4[body01]/10[para05]/2/1:3)',
        'output cfi string is same as input',
      )
      assert.equal(
        new EpubCFI(
          'epubcfi(/6/4[chap01ref]!/4[body01]/10[para05],/2/1:1,/3:4)',
        ).toString(),
        'epubcfi(/6/4[chap01ref]!/4[body01]/10[para05],/2/1:1,/3:4)',
        'output cfi string is same as input',
      )
    })
  })

  describe('#checkType()', function () {
    it('determine the type of a cfi string', function () {
      var cfi = new EpubCFI()

      assert.equal(cfi.checkType('epubcfi(/6/2[cover]!/6)'), 'string')
      assert.equal(cfi.checkType('/6/2[cover]!/6'), false)
    })

    it('determine the type of a cfi', function () {
      var ogcfi = new EpubCFI(
        'epubcfi(/6/4[chap01ref]!/4[body01]/10[para05]/2/1:3)',
      )
      var cfi = new EpubCFI()

      assert.equal(cfi.checkType(ogcfi), 'EpubCFI')
    })

    it('determine the type of a node', function () {
      var cfi = new EpubCFI()
      var el = document.createElement('div')

      assert.equal(cfi.checkType(el), 'node')
    })

    it('determine the type of a range', function () {
      var cfi = new EpubCFI()
      var range = document.createRange()

      assert.equal(cfi.checkType(range), 'range')
    })
  })

  describe('#compare()', function () {
    it('compare CFIs', function () {
      var epubcfi = new EpubCFI()

      // Spines
      assert.equal(
        epubcfi.compare('epubcfi(/6/4[cover]!/4)', 'epubcfi(/6/2[cover]!/4)'),
        1,
        'First spine is greater',
      )
      assert.equal(
        epubcfi.compare('epubcfi(/6/4[cover]!/4)', 'epubcfi(/6/6[cover]!/4)'),
        -1,
        'Second spine is greater',
      )

      // First is deeper
      assert.equal(
        epubcfi.compare('epubcfi(/6/2[cover]!/8/2)', 'epubcfi(/6/2[cover]!/6)'),
        1,
        'First Element is after Second',
      )
      assert.equal(
        epubcfi.compare('epubcfi(/6/2[cover]!/4/2)', 'epubcfi(/6/2[cover]!/6)'),
        -1,
        'First Element is before Second',
      )

      // Second is deeper
      assert.equal(
        epubcfi.compare(
          'epubcfi(/6/2[cover]!/8/2)',
          'epubcfi(/6/2[cover]!/6/4/2/2)',
        ),
        1,
        'First Element is after Second',
      )
      assert.equal(
        epubcfi.compare(
          'epubcfi(/6/2[cover]!/4/4)',
          'epubcfi(/6/2[cover]!/6/4/2/2)',
        ),
        -1,
        'First Element is before Second',
      )
      assert.equal(
        epubcfi.compare(
          'epubcfi(/6/2[cover]!/4/6)',
          'epubcfi(/6/2[cover]!/4/6/8/1:0)',
        ),
        -1,
        'First is less specific, so is before Second',
      )

      // Same Depth
      assert.equal(
        epubcfi.compare(
          'epubcfi(/6/2[cover]!/6/8)',
          'epubcfi(/6/2[cover]!/6/2)',
        ),
        1,
        'First Element is after Second',
      )
      assert.equal(
        epubcfi.compare(
          'epubcfi(/6/2[cover]!/4/20)',
          'epubcfi(/6/2[cover]!/6/10)',
        ),
        -1,
        'First Element is before Second',
      )

      // Text nodes
      assert.equal(
        epubcfi.compare(
          'epubcfi(/6/2[cover]!/4/5)',
          'epubcfi(/6/2[cover]!/4/3)',
        ),
        1,
        'First TextNode is after Second',
      )
      assert.equal(
        epubcfi.compare(
          'epubcfi(/6/2[cover]!/4/7)',
          'epubcfi(/6/2[cover]!/4/13)',
        ),
        -1,
        'First TextNode is before Second',
      )

      // Char offset
      assert.equal(
        epubcfi.compare(
          'epubcfi(/6/2[cover]!/4/5:1)',
          'epubcfi(/6/2[cover]!/4/5:0)',
        ),
        1,
        'First Char Offset after Second',
      )
      assert.equal(
        epubcfi.compare(
          'epubcfi(/6/2[cover]!/4/5:2)',
          'epubcfi(/6/2[cover]!/4/5:30)',
        ),
        -1,
        'Second Char Offset before Second',
      )

      // Normal example
      assert.equal(
        epubcfi.compare(
          'epubcfi(/6/2[cover]!/4/8/5:1)',
          'epubcfi(/6/2[cover]!/4/6/15:2)',
        ),
        1,
        'First Element after Second',
      )
      assert.equal(
        epubcfi.compare(
          'epubcfi(/6/2[cover]!/4/8/1:0)',
          'epubcfi(/6/2[cover]!/4/8/1:0)',
        ),
        0,
        'All Equal',
      )

      // Different Lengths
      assert.equal(
        epubcfi.compare(
          'epubcfi(/6/16[id42]!/4[5N3C0-8c483216e03a4ff49927fc1a97dc7b2c]/10/1:317)',
          'epubcfi(/6/16[id42]!/4[5N3C0-8c483216e03a4ff49927fc1a97dc7b2c]/10/2[page18]/1:0)',
        ),
        -1,
        'First CFI is before Second',
      )
      assert.equal(
        epubcfi.compare(
          'epubcfi(/6/16[id42]!/4[5N3C0-8c483216e03a4ff49927fc1a97dc7b2c]/12/1:0)',
          'epubcfi(/6/16[id42]!/4[5N3C0-8c483216e03a4ff49927fc1a97dc7b2c]/12/2/1:9)',
        ),
        -1,
        'First CFI is before Second',
      )
      assert.equal(
        epubcfi.compare(
          'epubcfi(/6/16!/4/12/1:0)',
          'epubcfi(/6/16!/4/12/2/1:9)',
        ),
        -1,
        'First CFI is before Second',
      )
    })
  })

  describe('#fromNode()', function () {
    var base = '/6/4[chap01ref]'
    // var contents = fs.readFileSync(__dirname + '/fixtures/chapter1-highlights.xhtml', 'utf8');
    var contents = require('./fixtures/chapter1-highlights.xhtml').default

    // var serializer = new XMLSerializer();
    // var doc = serializer.serializeToString(contents);
    var doc = new DOMParser().parseFromString(contents, 'application/xhtml+xml')

    it('get a cfi from a p node', function () {
      var span = doc.getElementById('c001p0004')
      var cfi = new EpubCFI(span, base)

      assert.equal(span.nodeType, Node.ELEMENT_NODE, 'provided a element node')
      assert.equal(
        cfi.toString(),
        'epubcfi(/6/4[chap01ref]!/4/2/10/2[c001p0004])',
      )
    })

    it('get a cfi from a text node', function () {
      var t = doc.getElementById('c001p0004').childNodes[0]
      var cfi = new EpubCFI(t, base)

      assert.equal(t.nodeType, Node.TEXT_NODE, 'provided a text node')
      assert.equal(
        cfi.toString(),
        'epubcfi(/6/4[chap01ref]!/4/2/10/2[c001p0004]/1)',
      )
    })

    it('get a cfi from a text node inside a highlight', function () {
      var t = doc.getElementById('highlight-1').childNodes[0]
      var cfi = new EpubCFI(t, base, 'annotator-hl')

      assert.equal(t.nodeType, Node.TEXT_NODE, 'provided a text node')
      assert.equal(
        cfi.toString(),
        'epubcfi(/6/4[chap01ref]!/4/2/32/2[c001p0017]/1)',
      )
    })

    it('get a cfi from a highlight node', function () {
      var t = doc.getElementById('highlight-1')
      var cfi = new EpubCFI(t, base, 'annotator-hl')

      assert.equal(t.nodeType, Node.ELEMENT_NODE, 'provided a highlight node')
      assert.equal(
        cfi.toString(),
        'epubcfi(/6/4[chap01ref]!/4/2/32/2[c001p0017])',
      )
    })
  })

  describe('#fromRange()', function () {
    var base = '/6/4[chap01ref]'

    // var contentsClean = fs.readFileSync(__dirname + '/fixtures/chapter1.xhtml', 'utf8');
    var contentsClean = require('./fixtures/chapter1.xhtml').default

    var doc = new DOMParser().parseFromString(
      contentsClean,
      'application/xhtml+xml',
    )

    // var contentsHighlights = fs.readFileSync(__dirname + '/fixtures/chapter1-highlights.xhtml', 'utf8');
    var contentsHighlights =
      require('./fixtures/chapter1-highlights.xhtml').default
    var docHighlights = new DOMParser().parseFromString(
      contentsHighlights,
      'application/xhtml+xml',
    )

    // var highlightContents = fs.readFileSync(__dirname + '/fixtures/highlight.xhtml', 'utf8');
    var highlightContents = require('./fixtures/highlight.xhtml').default
    var docHighlightsAlice = new DOMParser().parseFromString(
      highlightContents,
      'application/xhtml+xml',
    )

    it('get a cfi from a collapsed range', function () {
      var t1 = doc.getElementById('c001p0004').childNodes[0]
      var t2 = doc.getElementById('c001p0007').childNodes[0]
      var range = doc.createRange()
      var cfi

      range.setStart(t1, 6)

      cfi = new EpubCFI(range, base)

      assert.equal(cfi.range, false)
      assert.equal(
        cfi.toString(),
        'epubcfi(/6/4[chap01ref]!/4/2/10/2[c001p0004]/1:6)',
      )
    })

    it('get a cfi from a range', function () {
      var t1 = doc.getElementById('c001p0004').childNodes[0]
      var t2 = doc.getElementById('c001p0007').childNodes[0]
      var range = doc.createRange()
      var cfi

      range.setStart(t1, 6)
      range.setEnd(t2, 27)

      cfi = new EpubCFI(range, base)

      assert.equal(cfi.range, true)
      assert.equal(
        cfi.toString(),
        'epubcfi(/6/4[chap01ref]!/4/2,/10/2[c001p0004]/1:6,/16/2[c001p0007]/1:27)',
      )
    })

    it('get a cfi from a range with offset 0', function () {
      var t1 = doc.getElementById('c001p0004').childNodes[0]
      var range = doc.createRange()
      var cfi

      range.setStart(t1, 0)
      range.setEnd(t1, 1)

      cfi = new EpubCFI(range, base)

      assert.equal(cfi.range, true)
      assert.equal(
        cfi.toString(),
        'epubcfi(/6/4[chap01ref]!/4/2/10/2[c001p0004],/1:0,/1:1)',
      )
    })

    it('get a cfi from a range inside a highlight', function () {
      var t1 = docHighlights.getElementById('highlight-1').childNodes[0]
      var range = docHighlights.createRange()
      var cfi

      range.setStart(t1, 6)

      cfi = new EpubCFI(range, base, 'annotator-hl')

      assert.equal(
        cfi.toString(),
        'epubcfi(/6/4[chap01ref]!/4/2/32/2[c001p0017]/1:43)',
      )
    })
    // TODO: might need to have double ranges in front
    it('get a cfi from a range past a highlight', function () {
      var t1 = docHighlights.getElementById('c001s0001').childNodes[1]
      var range = docHighlights.createRange()
      var cfi

      range.setStart(t1, 25)

      cfi = new EpubCFI(range, base, 'annotator-hl')

      assert.equal(
        cfi.toString(),
        'epubcfi(/6/4[chap01ref]!/4/2/4/2[c001s0001]/1:41)',
      )
    })

    it('get a cfi from a range in between two highlights', function () {
      var t1 = docHighlightsAlice.getElementById('p2').childNodes[1]
      var range = docHighlightsAlice.createRange()
      var cfi

      range.setStart(t1, 4)

      cfi = new EpubCFI(range, base, 'annotator-hl')

      assert.equal(cfi.toString(), 'epubcfi(/6/4[chap01ref]!/4/4[p2]/1:123)')
    })

    it('correctly count text nodes, independent of any elements present inbetween', function () {
      var t1 = docHighlightsAlice.getElementById('p3').childNodes[2]
      var range = docHighlightsAlice.createRange()
      var cfi

      range.setStart(t1, 4)

      cfi = new EpubCFI(range, base)

      assert.equal(cfi.toString(), 'epubcfi(/6/4[chap01ref]!/4/6[p3]/3:4)')
    })
  })

  describe('#toRange()', function () {
    var base = '/6/4[chap01ref]'
    // var contents = fs.readFileSync(__dirname + '/fixtures/chapter1-highlights.xhtml', 'utf8');
    var contents = require('./fixtures/chapter1-highlights.xhtml').default

    var doc = new DOMParser().parseFromString(contents, 'application/xhtml+xml')

    // var serializer = new XMLSerializer();
    // console.log(serializer.serializeToString(doc));

    it('get a range from a cfi', function () {
      var t1 = doc.getElementById('c001p0004').childNodes[0]
      var t2 = doc.getElementById('c001p0007').childNodes[0]
      var ogRange = doc.createRange()
      var cfi
      var newRange

      ogRange.setStart(t1, 6)

      cfi = new EpubCFI(ogRange, base)

      // Check it was parse correctly
      assert.equal(
        cfi.toString(),
        'epubcfi(/6/4[chap01ref]!/4/2/10/2[c001p0004]/1:6)',
      )

      // Check the range
      newRange = cfi.toRange(doc)

      assert.equal(newRange.startContainer, t1)
      assert.equal(newRange.startOffset, 6)
      assert.equal(newRange.collapsed, true)
    })

    it('get a range from a cfi with a range', function () {
      var t1 = doc.getElementById('c001p0004').childNodes[0]
      var t2 = doc.getElementById('c001p0007').childNodes[0]
      var ogRange = doc.createRange()
      var cfi
      var newRange

      ogRange.setStart(t1, 6)
      ogRange.setEnd(t2, 27)

      cfi = new EpubCFI(ogRange, base)

      // Check it was parse correctly
      assert.equal(
        cfi.toString(),
        'epubcfi(/6/4[chap01ref]!/4/2,/10/2[c001p0004]/1:6,/16/2[c001p0007]/1:27)',
      )

      // Check the range
      newRange = cfi.toRange(doc)

      assert.equal(newRange.startContainer, t1)
      assert.equal(newRange.startOffset, 6)

      assert.equal(newRange.endContainer, t2)
      assert.equal(newRange.endOffset, 27)

      assert.equal(newRange.collapsed, false)
    })

    it('get a cfi from a range inside a highlight', function () {
      var t1 = doc.getElementById('highlight-1').childNodes[0]
      var ogRange = doc.createRange()
      var cfi
      var newRange

      ogRange.setStart(t1, 6)

      cfi = new EpubCFI(ogRange, base, 'annotator-hl')

      assert.equal(
        cfi.toString(),
        'epubcfi(/6/4[chap01ref]!/4/2/32/2[c001p0017]/1:43)',
      )

      // Check the range
      newRange = cfi.toRange(doc, 'annotator-hl')

      assert.ok(newRange.startContainer)

      assert.equal(newRange.startContainer, t1)
      assert.equal(newRange.startOffset, 6)
    })

    it('get a cfi from a range inside a highlight range', function () {
      var t1 = doc.getElementById('highlight-2').childNodes[0]
      var t2 = doc.getElementById('c001s0001').childNodes[1]
      var ogRange = doc.createRange()
      var cfi
      var newRange

      ogRange.setStart(t1, 5)
      ogRange.setEnd(t2, 25)

      cfi = new EpubCFI(ogRange, base, 'annotator-hl')

      assert.equal(
        cfi.toString(),
        'epubcfi(/6/4[chap01ref]!/4/2/4/2[c001s0001],/1:5,/1:41)',
      )

      // Check the range
      newRange = cfi.toRange(doc, 'annotator-hl')

      assert.strictEqual(newRange.startContainer.textContent, t1.textContent)
      // assert.strictEqual( newRange.startContainer, t1);
      // assert.equal( newRange.startOffset, 5);
    })
  })
})

</code>

packages\epubjs\test\index.html:
<code>
<!DOCTYPE html>
<html>
  <head>
    <title>Mocha</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./node_modules/mocha/mocha.css" />
    <script src="/test/test.build.js"></script>
  </head>
  <body>
  </body>
</html>

</code>

packages\epubjs\test\locations.js:
<code>
import assert from 'assert'

import Locations from '../src/locations'
import * as core from '../src/utils/core'

describe('Locations', function () {
  describe('#parse', function () {
    var chapter = require('./fixtures/locations.xhtml').default

    it('parse locations from a document', function () {
      var doc = core.parse(chapter, 'application/xhtml+xml')
      var contents = doc.documentElement
      var locations = new Locations()
      var result = locations.parse(contents, '/6/4[chap01ref]', 100)
      assert.equal(result.length, 15)
    })

    it('parse locations from xmldom', function () {
      var doc = core.parse(chapter, 'application/xhtml+xml', true)
      var contents = doc.documentElement

      var locations = new Locations()
      var result = locations.parse(contents, '/6/4[chap01ref]', 100)
      assert.equal(result.length, 15)
    })
  })
})

</code>

packages\epubjs\test\section.js:
<code>
import assert from 'assert'

import ePub from '../src/epub'

describe('section', function () {
  it('finds a single result in a section', function () {
    var book = ePub('./fixtures/alice/', { width: 400, height: 400 })
    return book.ready.then(function () {
      var section = book.section('chapter_001.xhtml')
      return section.load().then(function () {
        const queryString = 'they were filled with cupboards and book-shelves'
        const findResults = section.find(queryString)
        const searchResults = section.search(queryString)
        ;[findResults, searchResults].forEach((results) => {
          assert.equal(results.length, 1)
          assert.equal(
            results[0].cfi,
            'epubcfi(/6/8[chapter_001]!/4/2/16,/1:275,/1:323)',
          )
          assert.equal(
            results[0].excerpt,
            '... see anything; then she looked at the sides of the well and\n\t\tnoticed that they were filled with cupboards and book-shelves; here and there she saw\n\t\t...',
          )
        })
      })
    })
  })

  it('finds multiple results in a section', function () {
    var book = ePub('./fixtures/alice/', { width: 400, height: 400 })
    return book.ready.then(function () {
      var section = book.section('chapter_001.xhtml')
      return section.load().then(function () {
        const queryString = 'white rabbit'
        const findResults = section.find(queryString)
        const searchResults = section.search(queryString)
        ;[findResults, searchResults].forEach((results) => {
          assert.equal(results.length, 2)
          assert.equal(
            results[0].cfi,
            'epubcfi(/6/8[chapter_001]!/4/2/8,/1:240,/1:252)',
          )
          assert.equal(
            results[0].excerpt,
            '...e worth the trouble of getting up and picking the daisies, when suddenly a White Rabbit with pink eyes ran close by her....',
          )
          assert.equal(
            results[1].cfi,
            'epubcfi(/6/8[chapter_001]!/4/2/20,/1:148,/1:160)',
          )
          assert.equal(
            results[1].excerpt,
            '...ut it was\n\t\tall dark overhead; before her was another long passage and the White Rabbit was still\n\t\tin sight, hurrying down it. There was not a moment...',
          )
        })
      })
    })
  })

  it('finds result that spanning multiple document nodes, tag at ending', function () {
    var book = ePub('./fixtures/alice/', { width: 400, height: 400 })
    return book.ready.then(function () {
      var section = book.section('chapter_010.xhtml')
      return section.load().then(function () {
        const queryString = 'I beg'

        const findResult = section.find(queryString)
        assert.equal(findResult.length, 0)

        const searchResults = section.search(queryString)
        assert.equal(searchResults.length, 1)
        assert.equal(
          searchResults[0].cfi,
          'epubcfi(/6/26[chapter_010]!/4/2/6,/1:5,/2/1:3)',
        )
        assert.equal(searchResults[0].excerpt, '"Oh, I beg')
      })
    })
  })

  it('finds result that spanning multiple document nodes, tag at middle', function () {
    var book = ePub('./fixtures/alice/', { width: 400, height: 400 })
    return book.ready.then(function () {
      var section = book.section('chapter_010.xhtml')
      return section.load().then(function () {
        const queryString = 'I beg your pardon'

        const findResult = section.find(queryString)
        assert.equal(findResult.length, 0)

        const searchResults = section.search(queryString)
        assert.equal(searchResults.length, 1)
        assert.equal(
          searchResults[0].cfi,
          'epubcfi(/6/26[chapter_010]!/4/2/6,/1:5,/3:12)',
        )
        assert.equal(
          searchResults[0].excerpt,
          '"Oh, I beg your pardon!" she exclaimed in a tone of great dismay.',
        )
      })
    })
  })
})

</code>

packages\epubjs\test\old\epub.js:
<code>
var domain = window.location.origin

module('Core')

test('EPUBJS.core.resolveUrl', 1, function () {
  var a = 'http://example.com/fred/chasen/'
  var b = '/chasen/derf.html'

  var resolved = EPUBJS.core.resolveUrl(a, b)

  equal(resolved, 'http://example.com/fred/chasen/derf.html', 'resolved')
})

test('EPUBJS.core.resolveUrl ../', 1, function () {
  var a = 'http://example.com/fred/chasen/'
  var b = '../derf.html'

  var resolved = EPUBJS.core.resolveUrl(a, b)

  equal(resolved, 'http://example.com/fred/derf.html', 'resolved')
})

test('EPUBJS.core.resolveUrl folders', 1, function () {
  var a = '/fred/chasen/'
  var b = '/fred/chasen/derf.html'

  var resolved = EPUBJS.core.resolveUrl(a, b)

  equal(resolved, '/fred/chasen/derf.html', 'resolved')
})

test('EPUBJS.core.resolveUrl ../folders', 1, function () {
  var a = '/fred/chasen/'
  var b = '../../derf.html'

  var resolved = EPUBJS.core.resolveUrl(a, b)

  equal(resolved, '/derf.html', 'resolved')
})

module('Create')

asyncTest('Create new ePub(/path/to/epub/)', 1, function () {
  var book = ePub('../books/moby-dick/')
  book.opened.then(function () {
    equal(
      book.url,
      '../books/moby-dick/OPS/',
      'book url is passed to new EPUBJS.Book',
    )
    start()
  })
})

asyncTest('Create new ePub(/path/to/epub/package.opf)', 1, function () {
  var book = ePub('../books/moby-dick/OPS/package.opf')
  book.opened.then(function () {
    equal(
      book.url,
      domain + '/books/moby-dick/OPS/',
      'bookPath is passed to new EPUBJS.Book',
    )
    start()
  })
})

asyncTest('Open using ePub(/path/to/epub/package.opf)', 1, function () {
  var book = ePub('../books/moby-dick/OPS/package.opf')
  book.opened.then(function () {
    equal(
      book.packageUrl,
      '../books/moby-dick/OPS/package.opf',
      'packageUrl is set',
    )
    start()
  })
})

asyncTest('Open Remote ePub', 1, function () {
  var book = ePub('https://s3.amazonaws.com/moby-dick/')
  book.opened.then(function () {
    equal(
      book.packageUrl,
      'https://s3.amazonaws.com/moby-dick/OPS/package.opf',
      'packageUrl is set',
    )
    start()
  })
})

asyncTest('Open Remote ePub from Package', 1, function () {
  var book = ePub('https://s3.amazonaws.com/moby-dick/OPS/package.opf')
  book.opened.then(function () {
    equal(
      book.packageUrl,
      'https://s3.amazonaws.com/moby-dick/OPS/package.opf',
      'packageUrl is set',
    )
    start()
  })
})

asyncTest('Find Epub Package', 1, function () {
  var book = ePub('../books/moby-dick/OPS/package.opf')
  book.opened.then(function () {
    equal(
      book.packageUrl,
      '../books/moby-dick/OPS/package.opf',
      'packageUrl is set',
    )
    start()
  })
})

module('Parse')

//TODO: add mocked tests for parser

asyncTest('Manifest', 1, function () {
  var book = ePub('../books/moby-dick/OPS/package.opf')
  book.opened.then(function () {
    equal(Object.keys(book.package.manifest).length, 152, 'Manifest is parsed')
    start()
  })
})

asyncTest('Metadata', 3, function () {
  var book = ePub('../books/moby-dick/OPS/package.opf')
  book.opened.then(function () {
    equal(
      book.package.metadata.creator,
      'Herman Melville',
      'Creator metadata is parsed',
    )
    equal(book.package.metadata.title, 'Moby-Dick', 'Title metadata is parsed')
    equal(
      book.package.metadata.identifier,
      'code.google.com.epub-samples.moby-dick-basic',
      'Identifier metadata is parsed',
    )
    start()
  })
})

asyncTest('Spine', 1, function () {
  var book = ePub('../books/moby-dick/OPS/package.opf')
  book.opened.then(function () {
    equal(book.package.spine.length, 144, 'Spine is parsed')
    start()
  })
})

asyncTest('Cover', 1, function () {
  var book = ePub('../books/moby-dick/')
  book.opened.then(function () {
    equal(
      book.cover,
      '../books/moby-dick/OPS/images/9780316000000.jpg',
      'Cover is set',
    )
    start()
  })
})

module('Spine')

asyncTest('Length', 1, function () {
  var book = ePub('../books/moby-dick/OPS/package.opf')
  book.opened.then(function () {
    equal(book.spine.length, 144, 'All spine items present')
    start()
  })
})

asyncTest('Items', 1, function () {
  var book = ePub('../books/moby-dick/OPS/package.opf')
  book.opened.then(function () {
    equal(book.spine.spineItems.length, 144, 'All spine items added')
    start()
  })
})

asyncTest('First Item', 2, function () {
  var book = ePub('../books/moby-dick/OPS/package.opf')
  book.opened.then(function () {
    var section = book.spine.get(0)
    equal(section.href, 'cover.xhtml', 'First spine item href found')
    equal(section.cfiBase, '/6/2[cover]', 'First spine item cfi found')

    start()
  })
})

asyncTest('Find Item by Href', 2, function () {
  var book = ePub('../books/moby-dick/OPS/package.opf')
  book.opened.then(function () {
    var section = book.spine.get('chapter_001.xhtml')
    equal(section.href, 'chapter_001.xhtml', 'chap 1 spine item href found')
    equal(section.cfiBase, '/6/14[xchapter_001]', 'chap 1 spine item cfi found')

    start()
  })
})

asyncTest('Find Item by ID', 2, function () {
  var book = ePub('../books/moby-dick/OPS/package.opf')
  book.opened.then(function () {
    var section = book.spine.get('#xchapter_050')
    equal(section.href, 'chapter_050.xhtml', 'chap 50 spine item href found')
    equal(
      section.cfiBase,
      '/6/112[xchapter_050]',
      'chap 50 spine item cfi found',
    )

    start()
  })
})

asyncTest('Render Spine Item', 1, function () {
  var book = ePub('../books/moby-dick/OPS/package.opf')
  book.opened.then(function () {
    var section = book.spine.get('#xchapter_050')
    section.render().then(function (content) {
      equal(
        content.substring(377, 429),
        '<h1>Chapter 50. Ahab’s Boat and Crew. Fedallah.</h1>',
        'Chapter text rendered as string',
      )
    })

    start()
  })
})

module('Navigation')

asyncTest('NCX & Nav', 2, function () {
  var book = ePub('../books/moby-dick/')
  book.opened.then(function () {
    equal(
      book.navigation.navUrl,
      '../books/moby-dick/OPS/toc.xhtml',
      'Nav URL found',
    )
    equal(
      book.navigation.ncxUrl,
      '../books/moby-dick/OPS/toc.ncx',
      'NCX URL found',
    )

    start()
  })
})

asyncTest('Load TOC Auto Pick', 1, function () {
  var book = ePub('../books/moby-dick/')
  book.opened.then(function () {
    book.navigation.load().then(function (toc) {
      equal(toc.length, 141, 'Full Nav toc parsed')
      start()
    })
  })
})

asyncTest('Load TOC from Nav', 1, function () {
  var book = ePub('../books/moby-dick/OPS/package.opf')
  book.opened.then(function () {
    var nav = book.navigation.nav.load()
    nav.then(function (toc) {
      equal(toc.length, 141, 'Full Nav toc parsed')
      start()
    })
  })
})

asyncTest('Load TOC from NCX', 1, function () {
  var book = ePub('../books/moby-dick/OPS/package.opf')
  book.opened.then(function () {
    var ncx = book.navigation.ncx.load()
    ncx.then(function (toc) {
      equal(toc.length, 14, 'Full NCX toc parsed')
      start()
    })
  })
})

asyncTest('Get all TOC', 1, function () {
  var book = ePub('../books/moby-dick/OPS/package.opf')
  book.loaded.navigation.then(function () {
    equal(book.navigation.get().length, 141, 'Full Nav toc parsed')
    start()
  })
})

asyncTest('Get TOC item by href', 1, function () {
  var book = ePub('../books/moby-dick/OPS/package.opf')
  book.loaded.navigation.then(function () {
    var item = book.navigation.get('chapter_001.xhtml')
    equal(item.id, 'toc-chapter_001', 'Found TOC item')
    start()
  })
})

asyncTest('Get TOC item by ID', 1, function () {
  var book = ePub('../books/moby-dick/OPS/package.opf')
  book.loaded.navigation.then(function () {
    var item = book.navigation.get('#toc-chapter_001')
    equal(item.href, 'chapter_001.xhtml', 'Found TOC item')
    start()
  })
})

module('Hooks')

asyncTest('Register a new hook', 1, function () {
  var beforeDisplay = new EPUBJS.Hook()
  beforeDisplay.register(function (args) {
    var defer = new RSVP.defer()
    console.log('ran', 1)
    defer.resolve()
    return defer.promise
  })
  equal(beforeDisplay.hooks.length, 1, 'Registered a hook')
  start()

  // this.beforeDisplay.trigger(args).then(function(){});
})

asyncTest('Trigger all new hook', 4, function () {
  var beforeDisplay = new EPUBJS.Hook(this)
  this.testerObject = { tester: 1 }

  beforeDisplay.register(function (testerObject) {
    var defer = new RSVP.defer()

    start()
    equal(testerObject.tester, 1, 'tester is 1')
    stop()

    testerObject.tester += 1

    defer.resolve()
    return defer.promise
  })

  beforeDisplay.register(function (testerObject) {
    var defer = new RSVP.defer()

    start()
    equal(testerObject.tester, 2, 'tester is 2')
    stop()

    testerObject.tester += 1

    defer.resolve()
    return defer.promise
  })

  start()
  equal(beforeDisplay.hooks.length, 2, 'Added two hooks')
  stop()

  beforeDisplay.trigger(this.testerObject).then(
    function () {
      start()
      equal(this.testerObject.tester, 3, 'tester is 3')
    }.bind(this),
  )
})

</code>

packages\epubjs\test\old\rendering.js:
<code>
module('Rendering')
/*
asyncTest("Render To", 1, function() {

	var book = ePub("../books/moby-dick/OPS/package.opf");
	var rendition = book.renderTo("qunit-fixture", {width:400, height:600});
	var displayed = rendition.display(0);

	displayed.then(function(){
		equal( $( "iframe", "#qunit-fixture" ).length, 1, "iframe added successfully" );
		start();
	});


});
*/

</code>

packages\epubjs\types\annotations.d.ts:
<code>
import View from './managers/view'
import { Rendition } from './rendition'

export default class Annotations {
  constructor(rendition: Rendition)

  add(
    type: string,
    cfiRange: string,
    data?: object,
    cb?: Function,
    className?: string,
    styles?: object,
  ): Annotation

  remove(cfiRange: string, type: string): void

  highlight(
    cfiRange: string,
    data?: object,
    cb?: Function,
    className?: string,
    styles?: object,
  ): Annotation

  underline(
    cfiRange: string,
    data?: object,
    cb?: Function,
    className?: string,
    styles?: object,
  ): Annotation

  mark(cfiRange: string, data?: object, cb?: Function): void

  each(): Array<Annotation>

  private _removeFromAnnotationBySectionIndex(
    sectionIndex: number,
    hash: string,
  ): void

  private _annotationsAt(index: number): void

  private inject(view: View): void

  private clear(view: View): void
}

declare class Annotation {
  constructor(options: {
    type: string
    cfiRange: string
    data?: object
    sectionIndex?: number
    cb?: Function
    className?: string
    styles?: object
  })

  mark: any

  update(data: object): void

  attach(view: View): any

  detach(view: View): any

  // Event emitters
  emit(type: any, ...args: any[]): void

  off(type: any, listener: any): any

  on(type: any, listener: any): any

  once(type: any, listener: any, ...args: any[]): any
}

</code>

packages\epubjs\types\archive.d.ts:
<code>
import JSZip = require('jszip')

export default class Archive {
  constructor()

  open(input: BinaryType, isBase64?: boolean): Promise<JSZip>

  openUrl(zipUrl: string, isBase64?: boolean): Promise<JSZip>

  request(
    url: string,
    type?: string,
  ): Promise<Blob | string | JSON | Document | XMLDocument>

  getBlob(url: string, mimeType?: string): Promise<Blob>

  getText(url: string): Promise<string>

  getBase64(url: string, mimeType?: string): Promise<string>

  createUrl(url: string, options: { base64: boolean }): Promise<string>

  revokeUrl(url: string): void

  destroy(): void

  private checkRequirements(): void

  private handleResponse(
    response: any,
    type?: string,
  ): Blob | string | JSON | Document | XMLDocument
}

</code>

packages\epubjs\types\book.d.ts:
<code>
import Archive from './archive'
import Container from './container'
import Locations from './locations'
import Navigation from './navigation'
import {
  PackagingManifestObject,
  PackagingMetadataObject,
  PackagingSpineItem,
  PackagingObject,
} from './packaging'
import Packaging from './packaging'
import PageList, { PageListItem } from './pagelist'
import { Rendition, RenditionOptions } from './rendition'
import Resources from './resources'
import Section, { SpineItem } from './section'
import Spine from './spine'
import Store from './store'
import Path from './utils/path'
import Url from './utils/url'

export interface BookOptions {
  requestMethod?: (
    url: string,
    type: string,
    withCredentials: object,
    headers: object,
  ) => Promise<object>
  requestCredentials?: object
  requestHeaders?: object
  encoding?: string
  replacements?: string
  canonical?: (path: string) => string
  openAs?: string
  store?: string
}

export default class Book {
  constructor(url: string, options?: BookOptions)
  constructor(options?: BookOptions)

  settings: BookOptions
  opening: any // should be core.defer
  opened: Promise<Book>
  isOpen: boolean
  loaded: {
    metadata: Promise<PackagingMetadataObject>
    spine: Promise<SpineItem[]>
    manifest: Promise<PackagingManifestObject>
    cover: Promise<string>
    navigation: Promise<Navigation>
    pageList: Promise<PageListItem[]>
    resources: Promise<string[]>
  }
  ready: Promise<void>
  request: Function
  spine: Spine
  locations: Locations
  navigation: Navigation
  pageList: PageList
  url: Url
  path: Path
  archived: boolean
  archive: Archive
  resources: Resources
  rendition: Rendition
  container: Container
  packaging: Packaging
  storage: Store

  canonical(path: string): string

  coverUrl(): Promise<string | null>

  destroy(): void

  determineType(input: string): string

  getRange(cfiRange: string): Promise<Range>

  key(identifier?: string): string

  load(path: string): Promise<object>

  loadNavigation(opf: XMLDocument): Promise<Navigation>

  open(input: string, what?: string): Promise<object>
  open(input: ArrayBuffer, what?: string): Promise<object>

  openContainer(url: string): Promise<string>

  openEpub(data: BinaryType, encoding?: string): Promise<Book>

  openManifest(url: string): Promise<Book>

  openPackaging(url: string): Promise<Book>

  renderTo(element: Element, options?: RenditionOptions): Rendition
  renderTo(element: string, options?: RenditionOptions): Rendition

  private replacements(): Promise<void>

  resolve(path: string, absolute?: boolean): string

  section(target: string): Section
  section(target: number): Section

  setRequestCredentials(credentials: object): void

  setRequestHeaders(headers: object): void

  unarchive(input: BinaryType, encoding?: string): Promise<Archive>

  store(name: string): Store

  unpack(opf: XMLDocument): Promise<Book>

  // Event emitters
  emit(type: any, ...args: any[]): void

  off(type: any, listener: any): any

  on(type: any, listener: any): any

  once(type: any, listener: any, ...args: any[]): any
}

</code>

packages\epubjs\types\container.d.ts:
<code>
export default class Container {
  constructor(containerDocument: Document)

  parse(containerDocument: Document): void

  destroy(): void
}

</code>

packages\epubjs\types\contents.d.ts:
<code>
import EpubCFI from './epubcfi'

export interface ViewportSettings {
  width: string
  height: string
  scale: string
  scalable: string
  minimum: string
  maximum: string
}

export default class Contents {
  constructor(
    doc: Document,
    content: Element,
    cfiBase: string,
    sectionIndex: number,
  )

  epubcfi: EpubCFI
  document: Document
  documentElement: Element
  content: Element
  window: Window
  sectionIndex: number
  cfiBase: string

  static listenedEvents: string[]

  addClass(className: string): void

  addScript(src: string): Promise<boolean>

  addStylesheet(src: string): Promise<boolean>

  addStylesheetRules(
    rules: Array<object> | object,
    key: string,
  ): Promise<boolean>

  addStylesheetCss(serializedCss: string, key: string): Promise<boolean>

  cfiFromNode(node: Node, ignoreClass?: string): string

  cfiFromRange(range: Range, ignoreClass?: string): string

  columns(
    width: number,
    height: number,
    columnWidth: number,
    gap: number,
    dir: string,
  ): void

  contentHeight(h: number): number

  contentWidth(w: number): number

  css(property: string, value: string, priority?: boolean): string

  destroy(): void

  direction(dir: string): void

  fit(width: number, height: number): void

  height(): number
  height(h: number): number

  locationOf(
    target: string | EpubCFI,
    ignoreClass?: string,
  ): Promise<{ top: number; left: number }>

  map(layout: any): any

  mapPage(
    cfiBase: string,
    layout: object,
    start: number,
    end: number,
    dev: boolean,
  ): any

  overflow(overflow: string): string

  overflowX(overflow: string): string

  overflowY(overflow: string): string

  range(cfi: string, ignoreClass?: string): Range

  removeClass(className: any): void

  root(): Element

  scaler(scale: number, offsetX: number, offsetY: number): void

  scrollHeight(): number

  scrollWidth(): number

  size(width: number, height: number): void

  textHeight(): number

  textWidth(): number

  viewport(options: ViewportSettings): ViewportSettings

  width(): number
  width(w: number): number

  writingMode(mode: string): string

  // Event emitters
  emit(type: any, ...args: any[]): void

  off(type: any, listener: any): any

  on(type: any, listener: any): any

  once(type: any, listener: any, ...args: any[]): any

  private addEventListeners(): void

  private addSelectionListeners(): void

  private epubReadingSystem(name: string, version: string): object

  private expand(): void

  private fontLoadListeners(): void

  private imageLoadListeners(): void

  private layoutStyle(style: string): string

  private linksHandler(): void

  private listeners(): void

  private mediaQueryListeners(): void

  private onSelectionChange(e: Event): void

  private removeEventListeners(): void

  private removeListeners(): void

  private removeSelectionListeners(): void

  private resizeCheck(): void

  private resizeListeners(): void

  private resizeObservers(): void

  private transitionListeners(): void

  private triggerEvent(e: Event): void

  private triggerSelectedEvent(selection: Selection): void
}

</code>

packages\epubjs\types\core.d.ts:
<code>
export namespace Core {
  export function uuid(): string

  export function documentHeight(): number

  export function isElement(obj: object): boolean

  export function isNumber(n: any): boolean

  export function isFloat(n: any): boolean

  export function prefixed(unprefixed: string): string

  export function defaults(obj: object): object

  export function extend(target: object): object

  export function insert(
    item: any,
    array: Array<any>,
    compareFunction: Function,
  ): number

  export function locationOf(
    item: any,
    array: Array<any>,
    compareFunction: Function,
    _start: Function,
    _end: Function,
  ): number

  export function indexOfSorted(
    item: any,
    array: Array<any>,
    compareFunction: Function,
    _start: Function,
    _end: Function,
  ): number

  export function bounds(el: Element): { width: number; height: number }

  export function borders(el: Element): { width: number; height: number }

  export function nodeBounds(node: Node): object

  export function windowBounds(): {
    width: number
    height: number
    top: number
    left: number
    right: number
    bottom: number
  }

  export function indexOfNode(node: Node, typeId: string): number

  export function indexOfTextNode(textNode: Node): number

  export function indexOfElementNode(elementNode: Element): number

  export function isXml(ext: string): boolean

  export function createBlob(content: any, mime: string): Blob

  export function createBlobUrl(content: any, mime: string): string

  export function revokeBlobUrl(url: string): void

  export function createBase64Url(content: any, mime: string): string

  export function type(obj: object): string

  export function parse(
    markup: string,
    mime: string,
    forceXMLDom: boolean,
  ): Document

  export function qs(el: Element, sel: string): Element

  export function qsa(el: Element, sel: string): ArrayLike<Element>

  export function qsp(
    el: Element,
    sel: string,
    props: Array<object>,
  ): ArrayLike<Element>

  export function sprint(root: Node, func: Function): void

  export function treeWalker(
    root: Node,
    func: Function,
    filter: object | Function,
  ): void

  export function walk(node: Node, callback: Function): void

  export function blob2base64(blob: Blob): string

  export function defer(): Promise<any>

  export function querySelectorByType(
    html: Element,
    element: string,
    type: string,
  ): Array<Element>

  export function findChildren(el: Element): Array<Element>

  export function parents(node: Element): Array<Element>

  export function filterChildren(
    el: Element,
    nodeName: string,
    single: boolean,
  ): Array<Element>

  export function getParentByTagName(
    node: Element,
    tagname: string,
  ): Array<Element>

  export class RangeObject extends Range {}
}

</code>

packages\epubjs\types\epub.d.ts:
<code>
import Book, { BookOptions } from './book'

export default Epub

declare function Epub(
  urlOrData: string | ArrayBuffer,
  options?: BookOptions,
): Book
declare function Epub(options?: BookOptions): Book

</code>

packages\epubjs\types\epubcfi.d.ts:
<code>
interface EpubCFISegment {
  steps: Array<object>
  terminal: {
    offset: number
    assertion: string
  }
}

interface EpubCFIStep {
  id: string
  tagName: string
  type: number
  index: number
}

interface EpubCFIComponent {
  steps: Array<EpubCFIStep>
  terminal: {
    offset: number
    assertion: string
  }
}

export default class EpubCFI {
  constructor(
    cfiFrom?: string | Range | Node,
    base?: string | object,
    ignoreClass?: string,
  )

  base: EpubCFIComponent
  spinePos: number
  range: boolean

  isCfiString(str: string): boolean

  fromNode(anchor: Node, base: string | object, ignoreClass?: string): EpubCFI

  fromRange(range: Range, base: string | object, ignoreClass?: string): EpubCFI

  parse(cfiStr: string): EpubCFI

  collapse(toStart?: boolean): void

  compare(cfiOne: string | EpubCFI, cfiTwo: string | EpubCFI): number

  equalStep(stepA: object, stepB: object): boolean

  filter(anchor: Element, ignoreClass?: string): Element | false

  toRange(_doc?: Document, ignoreClass?: string): Range

  toString(): string

  private filteredStep(node: Node, ignoreClass?: string): any

  private findNode(
    steps: Array<EpubCFIStep>,
    _doc?: Document,
    ignoreClass?: string,
  ): Node

  private fixMiss(
    steps: Array<EpubCFIStep>,
    offset: number,
    _doc?: Document,
    ignoreClass?: string,
  ): any

  private checkType(cfi: string | Range | Node): string | false

  private generateChapterComponent(
    _spineNodeIndex: number,
    _pos: number,
    id: string,
  ): string

  private getChapterComponent(cfiStr: string): string

  private getCharecterOffsetComponent(cfiStr: string): string

  private getPathComponent(cfiStr: string): string

  private getRange(cfiStr: string): string

  private joinSteps(steps: Array<EpubCFIStep>): Array<EpubCFIStep>

  private normalizedMap(
    children: Array<Node>,
    nodeType: number,
    ignoreClass?: string,
  ): object

  private parseComponent(componentStr: string): object

  private parseStep(stepStr: string): object

  private parseTerminal(termialStr: string): object

  private patchOffset(
    anchor: Node,
    offset: number,
    ignoreClass?: string,
  ): number

  private pathTo(
    node: Node,
    offset: number,
    ignoreClass?: string,
  ): EpubCFISegment

  private position(anchor: Node): number

  private segmentString(segment: EpubCFISegment): string

  private step(node: Node): EpubCFIStep

  private stepsToQuerySelector(steps: Array<EpubCFIStep>): string

  private stepsToXpath(steps: Array<EpubCFIStep>): string

  private textNodes(container: Node, ignoreClass?: string): Array<Node>

  private walkToNode(
    steps: Array<EpubCFIStep>,
    _doc?: Document,
    ignoreClass?: string,
  ): Node
}

</code>

packages\epubjs\types\epubjs-tests.ts:
<code>
import ePub, { Book } from '../'

function testEpub() {
  const epub = ePub('https://s3.amazonaws.com/moby-dick/moby-dick.epub')

  const book = new Book('https://s3.amazonaws.com/moby-dick/moby-dick.epub', {})
}

testEpub()

</code>

packages\epubjs\types\index.d.ts:
<code>
// Type definitions for epubjs 0.3
// Project: https://github.com/futurepress/epub.js#readme
// Definitions by: Fred Chasen <https://github.com/fchasen>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
import Epub from './epub'

export as namespace ePub

export default Epub

export { default as Book } from './book'
export { default as EpubCFI } from './epubcfi'
export { Rendition, Location } from './rendition'
export { default as Contents } from './contents'
export { default as Layout } from './layout'
export { NavItem } from './navigation'

declare namespace ePub {}

</code>

packages\epubjs\types\layout.d.ts:
<code>
import Contents from './contents'

interface LayoutSettings {
  layout: string
  spread: string
  minSpreadWidth: number
  evenSpreads: boolean
}

export default class Layout {
  constructor(settings: LayoutSettings)

  settings: LayoutSettings
  name: string
  props: {
    name: string
    spread: string
    flow: string
    width: number
    height: number
    spreadWidth: number
    delta: number
    columnWidth: number
    gap: number
    divisor: number
  }

  flow(flow: string): string

  spread(spread: string, min: number): boolean

  calculate(_width: number, _height: number, _gap?: number): void

  format(contents: Contents): void | Promise<void>

  count(
    totalLength: number,
    pageLength: number,
  ): { spreads: number; pages: number }

  // Event emitters
  emit(type: any, ...args: any[]): void

  off(type: any, listener: any): any

  on(type: any, listener: any): any

  once(type: any, listener: any, ...args: any[]): any

  private update(props: object): void
}

</code>

packages\epubjs\types\locations.d.ts:
<code>
import EpubCFI from './epubcfi'
import Section from './section'
import Spine from './spine'

export default class Locations {
  constructor(spine: Spine, request?: Function, pause?: number)

  generate(chars: number): Promise<Array<string>>

  process(section: Section): Promise<Array<string>>

  locationFromCfi(cfi: string | EpubCFI): Location

  percentageFromCfi(cfi: string | EpubCFI): number

  percentageFromLocation(loc: number): number

  cfiFromLocation(loc: number): string

  cfiFromPercentage(percentage: number): string

  load(locations: string): Array<string>

  save(): string

  currentLocation(): Location
  currentLocation(curr: string | number): void

  length(): number

  destroy(): void

  private createRange(): {
    startContainer: Element
    startOffset: number
    endContainer: Element
    endOffset: number
  }

  private parse(contents: Node, cfiBase: string, chars: number): Array<string>
}

</code>

packages\epubjs\types\mapping.d.ts:
<code>
import Contents from './contents'
import Layout from './layout'

export interface EpubCFIPair {
  start: string
  end: string
}

export interface RangePair {
  start: Range
  end: Range
}

export default class Mapping {
  constructor(layout: Layout, direction?: string, axis?: string, dev?: boolean)

  page(
    contents: Contents,
    cfiBase: string,
    start: number,
    end: number,
  ): EpubCFIPair

  axis(axis: string): boolean

  private walk(root: Node, func: Function)

  private findStart(root: Node, start: number, end: number): Range

  private findEnd(root: Node, start: number, end: number): Range

  private findTextStartRange(node: Node, start: number, end: number): Range

  private findTextEndRange(node: Node, start: number, end: number): Range

  private splitTextNodeIntoRanges(node: Node, _splitter?: string): Array<Range>

  private rangePairToCfiPair(cfiBase: string, rangePair: RangePair): EpubCFIPair
}

</code>

packages\epubjs\types\navigation.d.ts:
<code>
export interface NavItem {
  id: string
  href: string
  label: string
  subitems?: Array<NavItem>
  parent?: string
}

export interface LandmarkItem {
  href?: string
  label?: string
  type?: string
}

export default class Navigation {
  constructor(xml: XMLDocument)

  toc: Array<NavItem>
  tocByHref: Record<string, number>
  tocById: Record<string, number>
  landmarks: Array<LandmarkItem>

  parse(xml: XMLDocument): void

  get(target: string): NavItem

  landmark(type: string): LandmarkItem

  load(json: string): Array<NavItem>

  forEach(fn: (item: NavItem) => {}): any

  private unpack(toc: Array<NavItem>): void

  private parseNav(navHtml: XMLDocument): Array<NavItem>

  private navItem(item: Element): NavItem

  private parseLandmarks(navHtml: XMLDocument): Array<LandmarkItem>

  private landmarkItem(item: Element): LandmarkItem

  private parseNcx(navHtml: XMLDocument): Array<NavItem>

  private ncxItem(item: Element): NavItem

  getByIndex(target: string, index: number, navItems: NavItem[]): NavItem
}

</code>

packages\epubjs\types\packaging.d.ts:
<code>
import { SpineItem } from './section'

export interface PackagingObject {
  metadata: PackagingMetadataObject
  spine: Array<SpineItem>
  manifest: PackagingManifestObject
  navPath: string
  ncxPath: string
  coverPath: string
  spineNodeIndex: number
}

export interface PackagingMetadataObject {
  title: string
  creator: string
  description: string
  pubdate: string
  publisher: string
  identifier: string
  language: string
  rights: string
  modified_date: string
  layout: string
  orientation: string
  flow: string
  viewport: string
  spread: string
}

export interface PackagingSpineItem {
  idref: string
  properties: Array<string>
  index: number
}

export interface PackagingManifestItem {
  href: string
  type: string
  properties: Array<string>
}

export interface PackagingManifestObject {
  [key: string]: PackagingManifestItem
}

export default class Packaging {
  constructor(packageDocument: XMLDocument)

  manifest: PackagingManifestObject
  navPath: string
  ncxPath: string
  coverPath: string
  spineNodeIndex: number
  spine: Array<PackagingSpineItem>
  metadata: PackagingMetadataObject

  parse(packageDocument: XMLDocument): PackagingObject

  load(json: string): PackagingObject

  destroy(): void

  private parseMetadata(xml: Node): PackagingMetadataObject

  private parseManifest(xml: Node): PackagingManifestObject

  private parseSpine(
    xml: Node,
    manifest: PackagingManifestObject,
  ): Array<PackagingSpineItem>

  private findNavPath(manifestNode: Node): string | false

  private findNcxPath(manifestNode: Node, spineNode: Node): string | false

  private findCoverPath(packageXml: Node): string

  private getElementText(xml: Node, tag: string): string

  private getPropertyText(xml: Node, property: string): string
}

</code>

packages\epubjs\types\pagelist.d.ts:
<code>
export interface PageListItem {
  href: string
  page: string
  cfi?: string
  packageUrl?: string
}

export default class Pagelist {
  constructor(xml: XMLDocument)

  parse(xml: XMLDocument): Array<PageListItem>

  pageFromCfi(cfi: string): number

  cfiFromPage(pg: string | number): string

  pageFromPercentage(percent: number): number

  percentageFromPage(pg: number): number

  destroy(): void

  private parseNav(navHtml: Node): Array<PageListItem>

  private item(item: Node): PageListItem

  private process(pageList: Array<PageListItem>): void
}

</code>

packages\epubjs\types\rendition.ts:
<code>
import Annotations from './annotations'
import Book from './book'
import Contents from './contents'
import EpubCFI from './epubcfi'
import View from './managers/view'
import Section from './section'
import Themes from './themes'
import Hook from './utils/hook'
import Queue from './utils/queue'

export enum RenditionSpread {
  Auto = 'auto',
  None = 'none',
  /* @deprecated */
  Always = 'always',
}

export interface RenditionOptions {
  width?: number | string
  height?: number | string
  ignoreClass?: string
  manager?: 'default' | 'continuous' | Function | object
  view?: 'iframe' | Function | object
  flow?:
    | 'auto'
    | 'paginated'
    | 'scrolled'
    | 'scrolled-continuous'
    | 'scrolled-doc'
  layout?: 'reflowable' | 'pre-paginated'
  spread?: RenditionSpread
  minSpreadWidth?: number
  stylesheet?: string
  resizeOnOrientationChange?: boolean
  script?: string
  infinite?: boolean
  overflow?: string
  snap?: boolean | object
  defaultDirection?: 'ltr'
  allowScriptedContent?: boolean
}

export interface DisplayedLocation {
  index: number
  href: string
  cfi: string
  location: number
  percentage: number
  displayed: {
    page: number
    total: number
  }
}

export interface Location {
  start: DisplayedLocation
  end: DisplayedLocation
  atStart: boolean
  atEnd: boolean
}

export declare class Rendition {
  constructor(book: Book, options: RenditionOptions)

  settings: RenditionOptions
  book: Book
  hooks: {
    display: Hook
    serialize: Hook
    content: Hook
    unloaded: Hook
    layout: Hook
    render: Hook
    show: Hook
  }
  themes: Themes
  annotations: Annotations
  epubcfi: EpubCFI
  q: Queue
  location: Location
  started: Promise<void>

  adjustImages(contents: Contents): Promise<void>

  attachTo(element: Element): Promise<void>

  clear(): void

  currentLocation(): DisplayedLocation
  currentLocation(): Promise<DisplayedLocation>

  destroy(): void

  determineLayoutProperties(metadata: object): object

  direction(dir: string): void

  display(target?: string): Promise<void>
  display(target?: number): Promise<void>

  flow(flow: string): void

  getContents(): Contents[]

  getRange(cfi: string, ignoreClass?: string): Range

  handleLinks(contents: Contents): void

  injectIdentifier(doc: Document, section: Section): void

  injectScript(doc: Document, section: Section): void

  injectStylesheet(doc: Document, section: Section): void

  layout(settings: any): any

  located(location: Location): DisplayedLocation

  moveTo(offset: number): void

  next(): Promise<void>

  onOrientationChange(orientation: string): void

  passEvents(contents: Contents): void

  prev(): Promise<void>

  reportLocation(): Promise<void>

  requireManager(manager: string | Function | object): any

  requireView(view: string | Function | object): any

  resize(width?: number, height?: number): void

  setManager(manager: Function): void

  spread(spread: string, min?: number): void

  start(): void

  views(): Array<View>

  // Event emitters
  emit(type: any, ...args: any[]): void

  off(type: any, listener: any): any

  on(type: any, listener: any): any

  once(type: any, listener: any, ...args: any[]): any

  private triggerMarkEvent(
    cfiRange: string,
    data: object,
    contents: Contents,
  ): void

  private triggerSelectedEvent(cfirange: string, contents: Contents): void

  private triggerViewEvent(e: Event, contents: Contents): void

  private onResized(size: { width: number; height: number }): void

  private afterDisplayed(view: any): void

  private afterRemoved(view: any): void
}

</code>

packages\epubjs\types\resources.d.ts:
<code>
import Archive from './archive'
import { PackagingManifestObject } from './packaging'

export default class Resources {
  constructor(
    manifest: PackagingManifestObject,
    options: {
      replacements?: string
      archive?: Archive
      resolver?: Function
      request?: Function
    },
  )

  process(manifest: PackagingManifestObject): void

  createUrl(url: string): Promise<string>

  replacements(): Promise<Array<string>>

  replacementUrls: string[]
  assets: any[]

  relativeTo(absolute: boolean, resolver?: Function): Array<string>

  get(path: string): string

  substitute(content: string, url?: string): string

  destroy(): void

  private split(): void

  private splitUrls(): void

  private replaceCss(
    archive: Archive,
    resolver?: Function,
  ): Promise<Array<string>>

  private createCssFile(href: string): Promise<string>
}

</code>

packages\epubjs\types\section.d.ts:
<code>
import { HooksObject } from './utils/hook'

export interface GlobalLayout {
  layout: string
  spread: string
  orientation: string
}

export interface LayoutSettings {
  layout: string
  spread: string
  orientation: string
}

export interface SpineItem {
  index: number
  cfiBase: string
  href?: string
  url?: string
  canonical?: string
  properties?: Array<string>
  linear?: string
  next: () => SpineItem
  prev: () => SpineItem
}

export default class Section {
  constructor(item: SpineItem, hooks: HooksObject)

  idref: string
  linear: boolean
  properties: Array<string>
  index: number
  href: string
  url: string
  canonical: string
  next: () => SpineItem
  prev: () => SpineItem
  cfiBase: string

  document: Document
  contents: Element
  output: string

  hooks: HooksObject

  load(_request?: Function): Document

  render(_request?: Function): string

  find(_query: string): Array<Element>

  reconcileLayoutSettings(globalLayout: GlobalLayout): LayoutSettings

  cfiFromRange(_range: Range): string

  cfiFromElement(el: Element): string

  unload(): void

  destroy(): void

  private base(): void
}

</code>

packages\epubjs\types\spine.d.ts:
<code>
import Packaging from './packaging'
import Section from './section'
import Hook from './utils/hook'

export default class Spine {
  constructor()

  hooks: {
    serialize: Hook
    content: Hook
  }

  unpack(_package: Packaging, resolver: Function, canonical: Function): void

  get(target?: string | number): Section

  each(...args: any[]): any

  first(): Section

  last(): Section

  destroy(): void

  private append(section: Section): number

  private prepend(section: Section): number

  private remove(section: Section): number
}

</code>

packages\epubjs\types\store.d.ts:
<code>
import localForage = require('localforage')

import Resources from './resources'

export default class Store {
  constructor(name: string, request?: Function, resolver?: Function)

  add(resources: Resources, force?: boolean): Promise<Array<object>>

  put(url: string, withCredentials?: boolean, headers?: object): Promise<Blob>

  request(
    url: string,
    type?: string,
    withCredentials?: boolean,
    headers?: object,
  ): Promise<Blob | string | JSON | Document | XMLDocument>

  retrieve(
    url: string,
    type?: string,
  ): Promise<Blob | string | JSON | Document | XMLDocument>

  getBlob(url: string, mimeType?: string): Promise<Blob>

  getText(url: string): Promise<string>

  getBase64(url: string, mimeType?: string): Promise<string>

  createUrl(url: string, options: { base64: boolean }): Promise<string>

  revokeUrl(url: string): void

  destroy(): void

  private checkRequirements(): void

  private handleResponse(
    response: any,
    type?: string,
  ): Blob | string | JSON | Document | XMLDocument
}

</code>

packages\epubjs\types\themes.d.ts:
<code>
import Contents from './contents'
import { Rendition } from './rendition'

export default class Themes {
  constructor(rendition: Rendition)

  register(themeObject: object): void

  register(theme: string, url: string): void

  register(theme: string, themeObject: object): void

  default(theme: object | string): void

  registerThemes(themes: object): void

  registerCss(name: string, css: string): void

  registerUrl(name: string, input: string): void

  registerRules(name: string, rules: object): void

  select(name: string): void

  update(name: string): void

  inject(content: Contents): void

  add(name: string, contents: Contents): void

  override(name: string, value: string, priority?: boolean): void

  overrides(contents: Contents): void

  fontSize(size: string): void

  font(f: string): void

  destroy(): void
}

</code>

packages\epubjs\types\tsconfig.json:
<code>
{
  "compilerOptions": {
    "module": "commonjs",
    "lib": ["es6", "dom"],
    "noImplicitAny": true,
    "noImplicitThis": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "baseUrl": "../",
    "typeRoots": ["../"],
    "types": [],
    "noEmit": true,
    "forceConsistentCasingInFileNames": true
  },
  "files": ["index.d.ts", "epubjs-tests.ts"]
}

</code>

packages\epubjs\types\tslint.json:
<code>
{
  "extends": "dtslint/dt.json",
  "rules": {}
}

</code>

packages\epubjs\types\managers\manager.d.ts:
<code>
import Contents from '../contents'
import Layout from '../layout'
import { EpubCFIPair } from '../mapping'
import Section from '../section'

import View, { ViewSettings } from './view'

export interface ViewLocation {
  index: number
  href: string
  pages: number[]
  totalPages: number
  mapping: EpubCFIPair
}

export interface ManagerOptions extends ViewSettings {
  infinite?: boolean
  overflow?: string
  [key: string]: any
}

export default class Manager {
  constructor(options: object)

  render(element: Element, size?: { width: number; height: number }): void

  resize(width: number, height: number): void

  onOrientationChange(e: Event): void

  private createView(section: Section): View

  display(section: Section, target: string | number): Promise<void>

  private afterDisplayed(view: View): void

  private afterResized(view: View): void

  private moveTo(offset: { top: number; left: number }): void

  private append(section: Section): Promise<void>

  private prepend(section: Section): Promise<void>

  next(): Promise<void>

  prev(): Promise<void>

  current(): View

  clear(): void

  currentLocation(): ViewLocation[]

  visible(): View[]

  private scrollBy(x: number, y: number, silent: boolean): void

  private scrollTo(x: number, y: number, silent: boolean): void

  private onScroll(): void

  bounds(): object

  applyLayout(layout: Layout): void

  updateLayout(): void

  setLayout(layout: Layout): void

  updateAxis(axis: string, forceUpdate: boolean): void

  updateFlow(flow: string): void

  getContents(): Contents[]

  direction(dir: string): void

  isRendered(): boolean

  destroy(): void

  // Event emitters
  emit(type: any, ...args: any[]): void

  off(type: any, listener: any): any

  on(type: any, listener: any): any

  once(type: any, listener: any, ...args: any[]): any
}

</code>

packages\epubjs\types\managers\view.d.ts:
<code>
import Contents from '../contents'
import Layout from '../layout'
import Section from '../section'

export interface ViewSettings {
  ignoreClass?: string
  axis?: string
  flow?: string
  layout?: Layout
  method?: string
  width?: number
  height?: number
  forceEvenPages?: boolean
  allowScriptedContent?: boolean
}

export default class View {
  constructor(section: Section, options: ViewSettings)

  create(): any

  render(request?: Function, show?: boolean): Promise<void>

  reset(): void

  size(_width: number, _height: number): void

  load(content: Contents): Promise<any>

  setLayout(layout: Layout): void

  setAxis(axis: string): void

  display(request?: Function): Promise<any>

  show(): void

  hide(): void

  offset(): { top: number; left: number }

  width(): number

  height(): number

  position(): object

  locationOf(target: string): { top: number; left: number }

  onDisplayed(view: View): void

  onResize(view: View): void

  bounds(force?: boolean): object

  highlight(
    cfiRange: string,
    data?: object,
    cb?: Function,
    className?: string,
    styles?: object,
  ): void

  underline(
    cfiRange: string,
    data?: object,
    cb?: Function,
    className?: string,
    styles?: object,
  ): void

  mark(cfiRange: string, data?: object, cb?: Function): void

  unhighlight(cfiRange: string): void

  ununderline(cfiRange: string): void

  unmark(cfiRange: string): void

  destroy(): void

  private onLoad(event: Event, promise: Promise<any>): void

  // Event emitters
  emit(type: any, ...args: any[]): void

  off(type: any, listener: any): any

  on(type: any, listener: any): any

  once(type: any, listener: any, ...args: any[]): any
}

</code>

packages\epubjs\types\utils\constants.d.ts:
<code>
export const EPUBJS_VERSION: string

export const DOM_EVENTS: Array<string>

export const EVENTS: {
  [key: string]: {
    [key: string]: string
  }
}

</code>

packages\epubjs\types\utils\core.d.ts:
<code>
export function uuid(): string

export function documentHeight(): number

export function isElement(obj: object): boolean

export function isNumber(n: any): boolean

export function isFloat(n: any): boolean

export function prefixed(unprefixed: string): string

export function defaults(obj: object): object

export function extend(target: object): object

export function insert(
  item: any,
  array: Array<any>,
  compareFunction: Function,
): number

export function locationOf(
  item: any,
  array: Array<any>,
  compareFunction: Function,
  _start: Function,
  _end: Function,
): number

export function indexOfSorted(
  item: any,
  array: Array<any>,
  compareFunction: Function,
  _start: Function,
  _end: Function,
): number

export function bounds(el: Element): { width: number; height: number }

export function borders(el: Element): { width: number; height: number }

export function nodeBounds(node: Node): object

export function windowBounds(): {
  width: number
  height: number
  top: number
  left: number
  right: number
  bottom: number
}

export function indexOfNode(node: Node, typeId: string): number

export function indexOfTextNode(textNode: Node): number

export function indexOfElementNode(elementNode: Element): number

export function isXml(ext: string): boolean

export function createBlob(content: any, mime: string): Blob

export function createBlobUrl(content: any, mime: string): string

export function revokeBlobUrl(url: string): void

export function createBase64Url(content: any, mime: string): string

export function type(obj: object): string

export function parse(
  markup: string,
  mime: string,
  forceXMLDom: boolean,
): Document

export function qs(el: Element, sel: string): Element

export function qsa(el: Element, sel: string): ArrayLike<Element>

export function qsp(
  el: Element,
  sel: string,
  props: Array<object>,
): ArrayLike<Element>

export function sprint(root: Node, func: Function): void

export function treeWalker(
  root: Node,
  func: Function,
  filter: object | Function,
): void

export function walk(node: Node, callback: Function): void

export function blob2base64(blob: Blob): string

export function defer(): Promise<any>

export function querySelectorByType(
  html: Element,
  element: string,
  type: string,
): Array<Element>

export function findChildren(el: Element): Array<Element>

export function parents(node: Element): Array<Element>

export function filterChildren(
  el: Element,
  nodeName: string,
  single: boolean,
): Array<Element>

export function getParentByTagName(
  node: Element,
  tagname: string,
): Array<Element>

export class RangeObject extends Range {}

</code>

packages\epubjs\types\utils\hook.d.ts:
<code>
interface HooksObject {
  [key: string]: Hook
}

export default class Hook {
  constructor(context: any)

  register(func: Function): void
  register(arr: Array<Function>): void

  deregister(func: Function): void

  trigger(...args: any[]): Promise<any>

  list(): Array<any>

  clear(): void
}

</code>

packages\epubjs\types\utils\path.d.ts:
<code>
export default class Path {
  constructor(pathString: string)

  parse(what: string): object

  isAbsolute(what: string): boolean

  isDirectory(what: string): boolean

  resolve(what: string): string

  relative(what: string): string

  splitPath(filename: string): string

  toString(): string
}

</code>

packages\epubjs\types\utils\queue.d.ts:
<code>
import { defer } from './core'

export interface QueuedTask {
  task: any | Task
  args: any[]
  deferred: any // should be defer, but not working
  promise: Promise<any>
}

export default class Queue {
  constructor(context: any)

  enqueue(func: Promise<Function> | Function, ...args: any[]): Promise<any>

  dequeue(): Promise<QueuedTask>

  dump(): void

  run(): Promise<void>

  flush(): Promise<void>

  clear(): void

  length(): number

  pause(): void

  stop(): void
}

declare class Task {
  constructor(task: any, args: any[], context: any)
}

</code>

packages\epubjs\types\utils\replacements.d.ts:
<code>
import Contents from '../contents'
import Section from '../section'

export function replaceBase(doc: Document, section: Section): void

export function replaceCanonical(doc: Document, section: Section): void

export function replaceMeta(doc: Document, section: Section): void

export function replaceLinks(contents: Contents, fn: Function): void

export function substitute(
  contents: Contents,
  urls: string[],
  replacements: string[],
): void

</code>

packages\epubjs\types\utils\request.d.ts:
<code>
export default function request(
  url: string,
  type?: string,
  withCredentials?: boolean,
  headers?: object,
): Promise<Blob | string | JSON | Document | XMLDocument>

</code>

packages\epubjs\types\utils\scrolltype.d.ts:
<code>
export default function scrollType(): string

export function createDefiner(): Node

</code>

packages\epubjs\types\utils\url.d.ts:
<code>
import Path from './path'

export default class Url {
  constructor(urlString: string, baseString: string)

  path(): Path

  resolve(what: string): string

  relative(what: string): string

  toString(): string
}

</code>

packages\internal\package.json:
<code>
{
  "name": "@flow/internal",
  "version": "0.0.0",
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "license": "MIT",
  "devDependencies": {
    "@types/react": "17.0.43",
    "@types/react-dom": "18.0.0"
  }
}

</code>

packages\internal\tsconfig.json:
<code>
{
  "extends": "../../tsconfig.react.json",
  "include": ["."],
  "exclude": ["dist", "build", "node_modules"]
}

</code>

packages\internal\src\index.ts:
<code>
export * from './lib'

</code>

packages\internal\src\lib.ts:
<code>
export const str = 'Hello world'

export function range(n: number) {
  return [...new Array(n)].map((_, i) => i)
}

</code>

packages\tailwind\package.json:
<code>
{
  "name": "@flow/tailwind",
  "version": "0.0.0",
  "license": "MIT",
  "main": "./src/index.js",
  "devDependencies": {
    "tailwindcss": "3.2.0"
  }
}

</code>

packages\tailwind\src\colors.js:
<code>
function makeColorString(variable, opacity) {
  if (opacity === undefined) {
    return `rgb(var(${variable}))`
  }
  return `rgb(var(${variable}) / ${opacity})`
}

function withOpacity(variable, opacityPreset) {
  return ({ opacityValue }) => {
    const opacity = opacityPreset || opacityValue
    return makeColorString(variable, opacity)
  }
}

function makeLinearGradient(color) {
  return `linear-gradient(${color},${color})`
}

const colorKeys = [
  'primary',
  'secondary',
  'tertiary',
  'error',
  'neutral',
  'neutral-variant',
]
const tones = [50, 60, 70, 80]
exports.tones = tones

const names = [
  'primary',
  'on-primary',
  'primary-container',
  'on-primary-container',
  'secondary',
  'on-secondary',
  'secondary-container',
  'on-secondary-container',
  'tertiary',
  'on-tertiary',
  'tertiary-container',
  'on-tertiary-container',
  'error',
  'on-error',
  'error-container',
  'on-error-container',
  'background',
  'on-background',
  'surface',
  'on-surface',
  'surface-variant',
  'on-surface-variant',
  'outline',
  'outline-variant',
  'shadow',
  'inverse-surface',
  'inverse-on-surface',
  'inverse-primary',
]

const theme = {
  // Derived colors
  disabled: makeColorString('--md-sys-color-on-surface', 0.12),
  'on-disabled': makeColorString('--md-sys-color-on-surface', 0.38),
}

colorKeys.forEach((colorKey) => {
  tones.forEach((t) => {
    const key = `${colorKey}${t}`
    theme[`${colorKey}${t}`] = withOpacity(`--md-ref-palette-${key}`)
  })
})

names.forEach((name) => {
  theme[name] = withOpacity(`--md-sys-color-${name}`)
})

exports.theme = theme

const utilities = {}

const surfaceMap = {
  1: 0.05,
  2: 0.08,
  3: 0.11,
  4: 0.12,
  5: 0.14,
}

Object.entries(surfaceMap).forEach(([level, opacity]) => {
  utilities[`.bg-surface${level}`] = {
    backgroundImage: makeLinearGradient(
      makeColorString(`--md-sys-color-primary`, opacity),
    ),
    backgroundColor: makeColorString('--md-sys-color-surface'),
  }
})

exports.utilities = utilities

</code>

packages\tailwind\src\elevation.js:
<code>
const KEY = 'rgba(0, 0, 0, 0.15)'
const AMBIENT = 'rgba(0, 0, 0, 0.3)'

exports.base = {
  '--md-sys-elevation-level1': `0px 1px 3px 1px ${KEY}, 0px 1px 2px ${AMBIENT};`,
  '--md-sys-elevation-level2': `0px 2px 6px 2px ${KEY}, 0px 1px 2px ${AMBIENT};`,
  '--md-sys-elevation-level3': `0px 4px 8px 3px ${KEY}, 0px 1px 3px ${AMBIENT};`,
  '--md-sys-elevation-level4': `0px 6px 10px 4px ${KEY}, 0px 2px 3px ${AMBIENT};`,
  '--md-sys-elevation-level5': `0px 8px 12px 6px ${KEY}, 0px 4px 4px ${AMBIENT};`,
}

exports.map = {
  1: 'var(--md-sys-elevation-level1)',
  2: 'var(--md-sys-elevation-level2)',
  3: 'var(--md-sys-elevation-level3)',
  4: 'var(--md-sys-elevation-level4)',
  5: 'var(--md-sys-elevation-level5)',
}

</code>

packages\tailwind\src\index.js:
<code>
const plugin = require('tailwindcss/plugin')

const colors = require('./colors')
const elevation = require('./elevation')
const state = require('./state')
const typography = require('./typography')

module.exports = plugin.withOptions(
  () => {
    return ({ addUtilities, addBase }) => {
      addBase({
        ':root': {
          ...typography.base,
          ...state.base,
          ...elevation.base,
        },
      })

      addUtilities({
        ...colors.utilities,
        ...typography.utilities,
      })
    }
  },
  function () {
    return {
      theme: {
        extend: {
          colors: colors.theme,
          opacity: state.map,
          boxShadow: elevation.map,
        },
      },
    }
  },
)

</code>

packages\tailwind\src\state.js:
<code>
exports.base = {
  '--md-sys-state-hover-state-layer-opacity': '0.08',
  '--md-sys-state-focus-state-layer-opacity': '0.12',
  '--md-sys-state-pressed-state-layer-opacity': '0.12',
  '--md-sys-state-dragged-state-layer-opacity': '0.16',
}

exports.map = {
  hover: 'var(--md-sys-state-hover-state-layer-opacity)',
  focus: 'var(--md-sys-state-focus-state-layer-opacity)',
  pressed: 'var(--md-sys-state-pressed-state-layer-opacity)',
  dragged: 'var(--md-sys-state-dragged-state-layer-opacity)',
}

</code>

packages\tailwind\src\typography.js:
<code>
exports.base = {
  /** Display large */
  '--md-sys-typescale-display-large-family': 'Roboto',
  '--md-sys-typescale-display-large-line-height': '64px',
  '--md-sys-typescale-display-large-size': '57px',
  '--md-sys-typescale-display-large-tracking': '0',
  '--md-sys-typescale-display-large-weight': '400',

  /** Display medium */
  '--md-sys-typescale-display-medium-family': 'Roboto',
  '--md-sys-typescale-display-medium-line-height': '52px',
  '--md-sys-typescale-display-medium-size': '45px',
  '--md-sys-typescale-display-medium-tracking': '0',
  '--md-sys-typescale-display-medium-weight': '400',

  /** Display small */
  '--md-sys-typescale-display-small-family': 'Roboto',
  '--md-sys-typescale-display-small-line-height': '44px',
  '--md-sys-typescale-display-small-size': '36px',
  '--md-sys-typescale-display-small-tracking': '0',
  '--md-sys-typescale-display-small-weight': '400',

  /** Headline large */
  '--md-sys-typescale-headline-large-family': 'Roboto',
  '--md-sys-typescale-headline-large-line-height': '40px',
  '--md-sys-typescale-headline-large-size': '32px',
  '--md-sys-typescale-headline-large-tracking': '0',
  '--md-sys-typescale-headline-large-weight': '400',

  /** Headline medium */
  '--md-sys-typescale-headline-medium-family': 'Roboto',
  '--md-sys-typescale-headline-medium-line-height': '36px',
  '--md-sys-typescale-headline-medium-size': '28px',
  '--md-sys-typescale-headline-medium-tracking': '0',
  '--md-sys-typescale-headline-medium-weight': '400',

  /** Headline small */
  '--md-sys-typescale-headline-small-family': 'Roboto',
  '--md-sys-typescale-headline-small-line-height': '32px',
  '--md-sys-typescale-headline-small-size': '24px',
  '--md-sys-typescale-headline-small-tracking': '0',
  '--md-sys-typescale-headline-small-weight': '400',

  /** Title large */
  '--md-sys-typescale-title-large-family': 'Roboto',
  '--md-sys-typescale-title-large-line-height': '28px',
  '--md-sys-typescale-title-large-size': '22px',
  '--md-sys-typescale-title-large-tracking': '0',
  '--md-sys-typescale-title-large-weight': '400',

  /** Title medium */
  '--md-sys-typescale-title-medium-family': 'Roboto',
  '--md-sys-typescale-title-medium-line-height': '24px',
  '--md-sys-typescale-title-medium-size': '16px',
  '--md-sys-typescale-title-medium-tracking': '0.5px',
  '--md-sys-typescale-title-medium-weight': '500',

  /** Title small */
  '--md-sys-typescale-title-small-family': 'Roboto',
  '--md-sys-typescale-title-small-line-height': '20px',
  '--md-sys-typescale-title-small-size': '14px',
  '--md-sys-typescale-title-small-tracking': '0.1px',
  '--md-sys-typescale-title-small-weight': '500',

  /** Label large */
  '--md-sys-typescale-label-large-family': 'Roboto',
  '--md-sys-typescale-label-large-line-height': '20px',
  '--md-sys-typescale-label-large-size': '14px',
  '--md-sys-typescale-label-large-tracking': '0.1px',
  '--md-sys-typescale-label-large-weight': '500',

  /** Label medium */
  '--md-sys-typescale-label-medium-family': 'Roboto',
  '--md-sys-typescale-label-medium-line-height': '16px',
  '--md-sys-typescale-label-medium-size': '12px',
  '--md-sys-typescale-label-medium-tracking': '0.5px',
  '--md-sys-typescale-label-medium-weight': '500',

  /** Label small */
  '--md-sys-typescale-label-small-family': 'Roboto',
  '--md-sys-typescale-label-small-line-height': '16px',
  '--md-sys-typescale-label-small-size': '11px',
  '--md-sys-typescale-label-small-tracking': '0.5px',
  '--md-sys-typescale-label-small-weight': '500',

  /** Body large */
  '--md-sys-typescale-body-large-family': 'Roboto',
  '--md-sys-typescale-body-large-line-height': '24px',
  '--md-sys-typescale-body-large-size': '16px',
  '--md-sys-typescale-body-large-tracking': '0.5px',
  '--md-sys-typescale-body-large-weight': '400',

  /** Body medium */
  '--md-sys-typescale-body-medium-family': 'Roboto',
  '--md-sys-typescale-body-medium-line-height': '20px',
  '--md-sys-typescale-body-medium-size': '14px',
  '--md-sys-typescale-body-medium-tracking': '0.5px',
  '--md-sys-typescale-body-medium-weight': '400',

  /** Body small */
  '--md-sys-typescale-body-small-family': 'Roboto',
  '--md-sys-typescale-body-small-line-height': '16px',
  '--md-sys-typescale-body-small-size': '12px',
  '--md-sys-typescale-body-small-tracking': '0.4px',
  '--md-sys-typescale-body-small-weight': '400',
}

const roles = ['display', 'headline', 'title', 'label', 'body']
const levels = ['large', 'medium', 'small']

const utilities = {}

roles.forEach((role) => {
  levels.forEach((level) => {
    utilities[`.typescale-${role}-${level}`] = {
      fontFamily: `var(--md-sys-typescale-${role}-${level}-family)`,
      lineHeight: `var(--md-sys-typescale-${role}-${level}-line-height)`,
      fontSize: `var(--md-sys-typescale-${role}-${level}-size)`,
      letterSpacing: `var(--md-sys-typescale-${role}-${level}-tracking)`,
      fontWeight: `var(--md-sys-typescale-${role}-${level}-weight)`,
    }
  })
})

exports.utilities = utilities

</code>


<notes>Some files may have been skipped, to save tokens or because they didn't seem relevant. Ask about them if needed.</notes>
